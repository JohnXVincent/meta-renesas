From fc06cee4dd0f958f6149272602e453bc6f8099e0 Mon Sep 17 00:00:00 2001
From: Binh Nguyen <binh.nguyen.jz@renesas.com>
Date: Thu, 3 Dec 2020 11:49:01 +0700
Subject: [PATCH 011/135] clk: renesas-rzg2l-cpg/r9a07g044l-cpg: Add new CPG
 driver for RZG2L

Add a new CPG driver initial support RZG2L family, started with
r9a07g044l(1/2).

Signed-off-by: Binh Nguyen <binh.nguyen.jz@renesas.com>
---
 drivers/clk/renesas/Kconfig                |   12 +
 drivers/clk/renesas/Makefile               |    2 +
 drivers/clk/renesas/r9a07g044l-cpg.c       |  452 +++++++++++
 drivers/clk/renesas/renesas-rzg2l-cpg.c    | 1189 ++++++++++++++++++++++++++++
 drivers/clk/renesas/renesas-rzg2l-cpg.h    |  265 +++++++
 include/dt-bindings/clock/r9a07g044l-cpg.h |   90 +++
 6 files changed, 2010 insertions(+)
 create mode 100644 drivers/clk/renesas/r9a07g044l-cpg.c
 create mode 100644 drivers/clk/renesas/renesas-rzg2l-cpg.c
 create mode 100644 drivers/clk/renesas/renesas-rzg2l-cpg.h
 create mode 100644 include/dt-bindings/clock/r9a07g044l-cpg.h

diff --git a/drivers/clk/renesas/Kconfig b/drivers/clk/renesas/Kconfig
index 1ea3b31..e0f8d23 100644
--- a/drivers/clk/renesas/Kconfig
+++ b/drivers/clk/renesas/Kconfig
@@ -27,6 +27,18 @@ config CLK_RENESAS
 	select CLK_R9A06G032 if ARCH_R9A06G032
 	select CLK_SH73A0 if ARCH_SH73A0
 
+config CLK_RENESAS_RZG2L
+	bool "Renesas RZG2L SoC clock support" if COMPILE_TEST && !ARCH_RENESAS
+	default y if ARCH_RENESAS
+	select CLK_R9A07G044L if ARCH_R9A07G044L2
+
+if CLK_RENESAS_RZG2L
+
+config CLK_R9A07G044L
+	bool "RZG2L clock support" if COMPILE_TEST
+
+endif # CLK_RENESAS_RZG2L
+
 if CLK_RENESAS
 
 config CLK_RENESAS_LEGACY
diff --git a/drivers/clk/renesas/Makefile b/drivers/clk/renesas/Makefile
index 350016c..20668f0 100644
--- a/drivers/clk/renesas/Makefile
+++ b/drivers/clk/renesas/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_CLK_R8A77470)		+= r8a77470-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774A1)		+= r8a774a1-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774B1)		+= r8a774b1-cpg-mssr.o
 obj-$(CONFIG_CLK_R8A774C0)		+= r8a774c0-cpg-mssr.o
+obj-$(CONFIG_CLK_R9A07G044L)		+= r9a07g044l-cpg.o
 obj-$(CONFIG_CLK_R8A7778)		+= clk-r8a7778.o
 obj-$(CONFIG_CLK_R8A7779)		+= clk-r8a7779.o
 obj-$(CONFIG_CLK_R8A7790)		+= r8a7790-cpg-mssr.o
@@ -36,3 +37,4 @@ obj-$(CONFIG_CLK_RCAR_USB2_CLOCK_SEL)	+= rcar-usb2-clock-sel.o
 obj-$(CONFIG_CLK_RENESAS_CPG_MSSR)	+= renesas-cpg-mssr.o
 obj-$(CONFIG_CLK_RENESAS_CPG_MSTP)	+= clk-mstp.o
 obj-$(CONFIG_CLK_RENESAS_DIV6)		+= clk-div6.o
+obj-$(CONFIG_CLK_RENESAS_RZG2L)		+= renesas-rzg2l-cpg.o
diff --git a/drivers/clk/renesas/r9a07g044l-cpg.c b/drivers/clk/renesas/r9a07g044l-cpg.c
new file mode 100644
index 0000000..5e8d0a6
--- /dev/null
+++ b/drivers/clk/renesas/r9a07g044l-cpg.c
@@ -0,0 +1,452 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RZG2L Clock Pulse Generator
+ *
+ * Copyright (C) 2020 Renesas Electronics Corp.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+
+#include <dt-bindings/clock/r9a07g044l-cpg.h>
+
+#include "renesas-rzg2l-cpg.h"
+
+enum clk_ids {
+	/* Core Clock Outputs exported to DT */
+	LAST_DT_CORE_CLK = R9A07G044L_OSCCLK,
+
+	/* External Input Clocks */
+	CLK_XINCLK,
+
+	/* Internal Core Clocks */
+	CLK_OSC_DIV1000,
+	CLK_PLL1,
+	CLK_SEL_PLL1,
+	CLK600,
+	CLK_PLL2,
+	CLK_PLL2_1,
+	CLK_SEL_PLL2_1,
+	CLK800FIX_C,
+	CLK800FIX_CDIV2,
+	CLK200FIX_C,
+	CLK200_C,
+	CLK100FIX_C,
+	CLK_PLL2_2,
+	CLK_SEL_PLL2_2,
+	CLK533_C,
+	CLK533_CDIV2,
+	CLK533FIX_C,
+	CLK533FIX_CDIV2,
+	CLK533FIX_LPCLK,
+	CLK_PLL3,
+	CLK_PLL3_1,
+	CLK_SEL_PLL3_1,
+	CLK800FIX_CD,
+	CLK800FIX_DIV2,
+	CLK200FIX_CD,
+	CLK200_CD,
+	CLK100FIX_CD,
+	CLK100_CD,
+	CLK_PLL3_2,
+	CLK_SEL_PLL3_2,
+	CLK_PLL3_3,
+	CLK_SEL_PLL3_3,
+	CLK533_CD,
+	CLK533FIX_CD,
+	CLK_PLL4,
+	CLK_SEL_PLL4,
+	CLK_PLL5,
+	CLK_PLL5_1,
+	CLK_SEL_PLL5_1,
+	CLK_PLL5_3,
+	CLK_SEL_PLL5_3,
+	CLK_PLL5_2,
+	CLK_SEL_PLL5_2,
+	CLK_SEL_PLL5_4,
+	CLK_250,
+	CLK_PLL6,
+	CLK_PLL6_1,
+	CLK_SEL_PLL6_1,
+	CLK_SEL_G1_1,
+	CLK_SEL_G1_2,
+	CLK_SEL_G2,
+	CLK_PLL6_DIV2,
+	CLK_SEL_PLL6_2,
+
+	/* Module Clocks */
+	CLK_MODE_BASE,
+};
+
+/*Divider tables*/
+static struct clk_div_table divdsilpcl[] = {
+	{0, 16},
+	{1, 32},
+	{2, 64},
+	{3, 128},
+};
+
+static struct clk_div_table dtable_2b[] = {
+	{0, 1},
+	{1, 2},
+	{2, 4},
+	{3, 8},
+};
+
+static struct clk_div_table dtable_3b[] = {
+	{0, 1},
+	{1, 2},
+	{2, 4},
+	{3, 8},
+	{4, 32},
+};
+
+static struct clk_div_table dtable_4b[] = {
+	{0, 1},
+	{1, 2},
+	{2, 3},
+	{3, 4},
+	{4, 5},
+	{5, 6},
+	{6, 7},
+	{7, 8},
+	{8, 9},
+	{9, 10},
+	{10, 11},
+	{11, 12},
+	{12, 13},
+	{13, 14},
+	{14, 15},
+	{15, 16},
+};
+
+/*MUX clock tables*/
+static const char *sel_pll1[]	= {"xinclk", ".pll1"};
+static const char *sel_pll2_1[]	= {"xinclk", ".pll2_1"};
+static const char *sel_pll2_2[]	= {"xinclk", ".pll2_2"};
+static const char *sel_pll3_1[]	= {"xinclk", ".pll3_1"};
+static const char *sel_pll3_2[]	= {"xinclk", ".pll3_2"};
+static const char *sel_pll3_3[]	= {".sel_pll3_2", ".pll3_3"};
+static const char *sel_pll4[]	= {".osc_div1000", ".pll4"};
+static const char *sel_pll5_1[]	= {"xinclk", ".pll5_1"};
+static const char *sel_pll5_3[]	= {"xinclk", ".pll5_3"};
+static const char *sel_pll5_4[]	= {".sel_pll5_1", ".sel_pll5_3"};
+static const char *sel_pll5_2[]	= {"xinclk", ".pll5_2"};
+static const char *sel_pll6_1[]	= {"xinclk", ".pll6"};
+static const char *sel_g1_1[]	= {".sel_pll6_1", ".clk600"};
+static const char *sel_g1_2[]	= {".clk533fix_cd", ".clk800fix_div2"};
+static const char *sel_g2[]	= {".sel_g1_1", ".sel_g1_2"};
+static const char *sel_pll6_2[]	= {".pll6_div2", ".clk250"};
+static const char *sel_eth[]	= {"xinclk", ".sel_pll6_2"};
+static const char *sel_shdi[]	= {".clk800fix_c", ".clk533_c",
+				   ".clk800fix_cdiv2", ".clk533_cdiv2"};
+
+static const struct cpg_core_clk r9a07g044l_core_clks[] __initconst = {
+	/* External Clock Inputs */
+	DEF_INPUT("xinclk",	 CLK_XINCLK),
+
+	/* Internal Core Clocks */
+	DEF_FIXED(".osc", R9A07G044L_OSCCLK, CLK_XINCLK, 1, 1),
+	DEF_FIXED(".osc_div1000", CLK_OSC_DIV1000, CLK_XINCLK, 1, 1000),
+	DEF_PLL(".pll1", CLK_PLL1, CLK_TYPE_SAM_PLL, CLK_XINCLK,
+		PLL146_CONF(0), PLL146_STBY(0), PLL146_MON(0)),
+	DEF_PLL(".pll2", CLK_PLL2, CLK_TYPE_SI_PLL, CLK_XINCLK,
+		PLL235_CONF(0), PLL235_STBY(0), PLL235_MON(0)),
+	DEF_PLL(".pll3", CLK_PLL3, CLK_TYPE_SI_PLL, CLK_XINCLK,
+		PLL235_CONF(1), PLL235_STBY(1), PLL235_MON(1)),
+	DEF_PLL(".pll4", CLK_PLL4, CLK_TYPE_SAM_PLL, CLK_XINCLK,
+		PLL146_CONF(1), PLL146_STBY(1), PLL146_MON(1)),
+	DEF_PLL(".pll5", CLK_PLL5, CLK_TYPE_SI_PLL, CLK_XINCLK,
+		PLL235_CONF(2), PLL235_STBY(2), PLL235_MON(2)),
+	DEF_PLL(".pll6", CLK_PLL6, CLK_TYPE_SAM_PLL, CLK_XINCLK,
+		PLL146_CONF(2), PLL146_STBY(2), PLL146_MON(2)),
+	DEF_MUX(".sel_pll1", CLK_SEL_PLL1, SEL_PLL1,
+			sel_pll1, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".clk600", CLK600, CLK_PLL1, 1, 2),
+	DEF_FIXED(".pll2_1", CLK_PLL2_1, CLK_PLL2, 1, 2),
+	DEF_MUX(".sel_pll2_1", CLK_SEL_PLL2_1, SEL_PLL2_1,
+			sel_pll2_1, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".clk800fix_c", CLK800FIX_C, CLK_SEL_PLL2_1, 1, 2),
+	DEF_FIXED(".clk800fix_cdiv2", CLK800FIX_CDIV2, CLK800FIX_C, 1, 2),
+	DEF_FIXED(".clk200fix_c", CLK200FIX_C, CLK800FIX_C, 1, 4),
+	DEF_DIV(".clk200_c", CLK200_C, CLK200FIX_C,
+			DIVPL2B, dtable_3b, 0),
+	DEF_FIXED(".clk100fix_c", CLK100FIX_C, CLK200FIX_C, 1, 2),
+	DEF_FIXED(".pll2_2", CLK_PLL2_2, CLK_PLL2, 1, 6),
+	DEF_MUX(".sel_pll2_2", CLK_SEL_PLL2_2, SEL_PLL2_2,
+			sel_pll2_2, 2, CLK_MUX_READ_ONLY),
+	DEF_DIV(".clk533_c", CLK533_C, CLK_SEL_PLL2_2,
+			DIVPL2C, dtable_3b, 0),
+	DEF_FIXED(".clk533_cdiv2", CLK533_CDIV2, CLK533_C, 1, 2),
+	DEF_FIXED(".clk533fix_c", CLK533FIX_C, CLK_SEL_PLL2_2, 1, 1),
+	DEF_FIXED(".clk533fix_cdiv2", CLK533FIX_CDIV2, CLK533FIX_C, 1, 2),
+	DEF_FIXED(".clk533fix_lpclk", CLK533FIX_LPCLK, CLK533FIX_C, 1, 2),
+	DEF_FIXED(".pll3_1", CLK_PLL3_1, CLK_PLL3, 1, 2),
+	DEF_MUX(".sel_pll3_1", CLK_SEL_PLL3_1, SEL_PLL3_1,
+			sel_pll3_1, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".clk800fix_cd", CLK800FIX_CD, CLK_SEL_PLL3_1, 1, 2),
+	DEF_FIXED(".clk800fix_div2", CLK800FIX_DIV2, CLK800FIX_CD, 1, 2),
+	DEF_FIXED(".clk200fix_cd", CLK200FIX_CD, CLK800FIX_CD, 1, 4),
+	DEF_FIXED(".clk100fix_cd", CLK100FIX_CD, CLK200FIX_CD, 1, 2),
+	DEF_FIXED(".pll3_2", CLK_PLL3_2, CLK_PLL3, 1, 6),
+	DEF_MUX(".sel_pll3_2", CLK_SEL_PLL3_2, SEL_PLL3_2,
+			sel_pll3_2, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".pll3_3", CLK_PLL3_3, CLK_PLL3, 1, 8),
+	DEF_MUX(".sel_pll3_3", CLK_SEL_PLL3_3, SEL_PLL3_3,
+			sel_pll3_3, 2, CLK_MUX_READ_ONLY),
+	DEF_DIV(".clk533_cd", CLK533_CD, CLK_SEL_PLL3_3,
+			DIVPL3C, dtable_3b, 0),
+	DEF_FIXED(".clk533fix_cd", CLK533FIX_CD, CLK_SEL_PLL3_2, 1, 1),
+	DEF_MUX(".sel_pll4", CLK_SEL_PLL4, SEL_PLL4,
+			sel_pll4, 2, 0),
+	DEF_FIXED(".pll5_1", CLK_PLL5_1, CLK_PLL5, 1, 1),
+	DEF_MUX(".sel_pll5_1", CLK_SEL_PLL5_1, SEL_PLL5_1,
+			sel_pll5_1, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".pll5_3", CLK_PLL5_3, CLK_PLL5, 1, 2),
+	DEF_MUX(".sel_pll5_3", CLK_SEL_PLL5_3, SEL_PLL5_3,
+			sel_pll5_3, 2, CLK_MUX_READ_ONLY),
+	DEF_MUX(".sel_pll5_4", CLK_SEL_PLL5_4, SEL_PLL5_4,
+			sel_pll5_4, 2, 0),
+	DEF_FIXED(".pll5_2", CLK_PLL5_2, CLK_PLL5, 1, 6),
+	DEF_MUX(".sel_pll5_2", CLK_SEL_PLL5_2, SEL_PLL5_2,
+			sel_pll5_2, 2, CLK_MUX_READ_ONLY),
+	DEF_FIXED(".clk250", CLK_250, CLK_SEL_PLL5_2, 1, 2),
+	DEF_MUX(".sel_pll6_1", CLK_SEL_PLL6_1, SEL_PLL6_1,
+			sel_pll6_1, 2, CLK_MUX_READ_ONLY),
+	DEF_MUX(".sel_g1_1", CLK_SEL_G1_1, SEL_G1_1,
+			sel_g1_1, 2, CLK_MUX_READ_ONLY),
+	DEF_MUX(".sel_g1_2", CLK_SEL_G1_2, SEL_G1_2,
+			sel_g1_2, 2, CLK_MUX_READ_ONLY),
+	DEF_MUX(".sel_g2", CLK_SEL_G2, SEL_G2,
+			sel_g2, 2, 0),
+	DEF_FIXED(".pll6_div2", CLK_PLL6_DIV2, CLK_PLL6, 1, 2),
+	DEF_MUX(".sel_pll6_2", CLK_SEL_PLL6_2, SEL_PLL6_2,
+			sel_pll6_2, 2, 0),
+
+	/* Core output clk*/
+	DEF_DIV("I", R9A07G044L_CLK_I, CLK_SEL_PLL1,
+			DIVPL1, NULL, CLK_DIVIDER_POWER_OF_TWO),
+	DEF_DIV("I2", R9A07G044L_CLK_I2, CLK200FIX_CD,
+		DIVPL3CLK200FIX, dtable_3b, 0),
+	DEF_DIV("G", R9A07G044L_CLK_G, CLK_SEL_G2,
+			DIVGPU, NULL, CLK_DIVIDER_POWER_OF_TWO),
+	DEF_FIXED("S0", R9A07G044L_CLK_S0, CLK_SEL_PLL4, 1, 2),
+	DEF_FIXED("S1", R9A07G044L_CLK_S0, CLK_SEL_PLL4, 1, 4),
+	DEF_FIXED("SPI0", R9A07G044L_CLK_SPI0, CLK533_CD, 1, 2),
+	DEF_FIXED("SPI1", R9A07G044L_CLK_SPI1, CLK533_CD, 1, 4),
+	DEF_MUX("SD0", R9A07G044L_CLK_SD0, SEL_SDHI0,
+			sel_shdi, 4, 0),
+	DEF_MUX("SD1", R9A07G044L_CLK_SD1, SEL_SDHI1,
+			sel_shdi, 4, 0),
+	DEF_FIXED("M0", R9A07G044L_CLK_M0, CLK200FIX_CD, 1, 1),
+	DEF_FIXED("M1", R9A07G044L_CLK_M1, CLK_SEL_PLL5_1, 1, 1),
+	DEF_FIXED("M2", R9A07G044L_CLK_M2, CLK533FIX_CD, 1, 2),
+	DEF_2DIV("M3", R9A07G044L_CLK_M3, CLK_SEL_PLL5_4,
+		DIVDSIA, DIVDSIB, dtable_2b, dtable_4b, 0),
+	DEF_DIV("M4", R9A07G044L_CLK_M4, CLK533FIX_LPCLK,
+			DIVDSILPCL, divdsilpcl, 0),
+	DEF_MUX("HP", R9A07G044L_CLK_HP, SEL_ETH, sel_eth, 2, 0),
+	DEF_FIXED("TSU", R9A07G044L_CLK_TSU, CLK800FIX_C, 1, 10),
+	DEF_FIXED("ZT", R9A07G044L_CLK_ZT, CLK100FIX_CD, 1, 1),
+	DEF_DIV("P0", R9A07G044L_CLK_P0, CLK100FIX_C,
+			DIVPL2A, dtable_3b, 0),
+	DEF_DIV("P1", R9A07G044L_CLK_P1, CLK200FIX_CD,
+			DIVPL3B, dtable_3b, 0),
+	DEF_DIV("P2", R9A07G044L_CLK_P2, CLK100FIX_CD,
+			DIVPL3A, dtable_3b, 0),
+	DEF_FIXED("AT", R9A07G044L_CLK_AT, CLK800FIX_CD, 1, 2),
+};
+
+static struct mssr_mod_clk r9a07g044l_mod_clks[] = {
+	DEF_MOD("gic",		R9A07G044L_CLK_GIC600,
+				R9A07G044L_CLK_P1,
+				MSSR(5, BIT(0), (BIT(0) | BIT(1)))),
+	DEF_MOD("ia55",		R9A07G044L_CLK_IA55,
+				R9A07G044L_CLK_P1,
+				MSSR(6, (BIT(0) | BIT(1)), BIT(0))),
+	DEF_MOD("syc",		R9A07G044L_CLK_SYC,
+				CLK_XINCLK,
+				MSSR(10, BIT(0), BIT(0))),
+	DEF_MOD("dmac",		R9A07G044L_CLK_DMAC,
+				R9A07G044L_CLK_P1,
+				MSSR(11, (BIT(0) | BIT(1)),
+					 (BIT(0) | BIT(1)))),
+	DEF_MOD("sysc",		R9A07G044L_CLK_SYSC,
+				CLK_XINCLK,
+				MSSR(12, (BIT(0) | BIT(1)),
+					 (BIT(0) | BIT(1) | BIT(2)))),
+	DEF_MOD("mtu3",		R9A07G044L_CLK_MTU,
+				R9A07G044L_CLK_P0,
+				MSSR(14, BIT(0), BIT(0))),
+	DEF_MOD("gpt",		R9A07G044L_CLK_GPT,
+				R9A07G044L_CLK_P0,
+				MSSR(16, BIT(0), BIT(0))),
+	DEF_MOD("eth0",		R9A07G044L_CLK_ETH0,
+				R9A07G044L_CLK_HP,
+				MSSR(31, BIT(0), BIT(0))),
+	DEF_MOD("eth1",		R9A07G044L_CLK_ETH1,
+				R9A07G044L_CLK_HP,
+				MSSR(31, BIT(1), BIT(1))),
+	DEF_MOD("i2c0",		R9A07G044L_CLK_I2C0,
+				R9A07G044L_CLK_P0,
+				MSSR(32, BIT(0), BIT(0))),
+	DEF_MOD("i2c1",		R9A07G044L_CLK_I2C1,
+				R9A07G044L_CLK_P0,
+				MSSR(32, BIT(1), BIT(1))),
+	DEF_MOD("i2c2",		R9A07G044L_CLK_I2C2,
+				R9A07G044L_CLK_P0,
+				MSSR(32, BIT(2), BIT(2))),
+	DEF_MOD("i2c3",		R9A07G044L_CLK_I2C3,
+				R9A07G044L_CLK_P0,
+				MSSR(32, BIT(3), BIT(3))),
+	DEF_MOD("scif0",	R9A07G044L_CLK_SCIF0,
+				R9A07G044L_CLK_P0,
+				MSSR(33, BIT(0), BIT(0))),
+	DEF_MOD("scif1",	R9A07G044L_CLK_SCIF1,
+				R9A07G044L_CLK_P0,
+				MSSR(33, BIT(1), BIT(1))),
+	DEF_MOD("scif2",	R9A07G044L_CLK_SCIF2,
+				R9A07G044L_CLK_P0,
+				MSSR(33, BIT(2), BIT(2))),
+	DEF_MOD("scif3",	R9A07G044L_CLK_SCIF3,
+				R9A07G044L_CLK_P0,
+				MSSR(33, BIT(3), BIT(3))),
+	DEF_MOD("scif4",	R9A07G044L_CLK_SCIF4,
+				R9A07G044L_CLK_P0,
+				MSSR(33, BIT(4), BIT(4))),
+	DEF_MOD("sci0",		R9A07G044L_CLK_SCI0,
+				R9A07G044L_CLK_P0,
+				MSSR(34, BIT(0), BIT(0))),
+	DEF_MOD("sci1",		R9A07G044L_CLK_SCI1,
+				R9A07G044L_CLK_P0,
+				MSSR(34, BIT(1), BIT(1))),
+	DEF_MOD("gpio",		R9A07G044L_CLK_GPIO,
+				CLK_XINCLK,
+				MSSR(38, BIT(0),
+					(BIT(0) | BIT(1) | BIT(2)))),
+	DEF_MOD("sdhi0",	R9A07G044L_CLK_SDHI0,
+				R9A07G044L_CLK_SD0,
+				MSSR(21, (BIT(0) | BIT(1) | BIT(2) | BIT(3)),
+					 BIT(0))),
+	DEF_MOD("sdhi1",	R9A07G044L_CLK_SDHI1,
+				R9A07G044L_CLK_SD1,
+				MSSR(21, (BIT(4) | BIT(5) | BIT(6) | BIT(7)),
+					 BIT(1))),
+	DEF_MOD("usb0",		R9A07G044L_CLK_USB0,
+				R9A07G044L_CLK_P1,
+				MSSR(30, (BIT(0) | BIT(2) | BIT(3)),
+					 (BIT(0) | BIT(2) | BIT(3)))),
+	DEF_MOD("usb1",		R9A07G044L_CLK_USB1,
+				R9A07G044L_CLK_P1,
+				MSSR(30, (BIT(1) | BIT(3)),
+					 (BIT(1) | BIT(3)))),
+	DEF_MOD("canfd",	R9A07G044L_CLK_CANFD,
+				R9A07G044L_CLK_P0,
+				MSSR(37, BIT(0), (BIT(0) | BIT(1)))),
+	DEF_MOD("ssi0",		R9A07G044L_CLK_SSI0,
+				R9A07G044L_CLK_P0,
+				MSSR(28, (BIT(0) | BIT(1)), BIT(0))),
+	DEF_MOD("ssi1",		R9A07G044L_CLK_SSI1,
+				R9A07G044L_CLK_P0,
+				MSSR(28, (BIT(2) | BIT(3)), BIT(1))),
+	DEF_MOD("ssi2",		R9A07G044L_CLK_SSI2,
+				R9A07G044L_CLK_P0,
+				MSSR(28, (BIT(4) | BIT(5)), BIT(2))),
+	DEF_MOD("ssi3",		R9A07G044L_CLK_SSI3,
+				R9A07G044L_CLK_P0,
+				MSSR(28, (BIT(6) | BIT(7)), BIT(3))),
+	DEF_MOD("mhu",		R9A07G044L_CLK_MHU,
+				R9A07G044L_CLK_P1,
+				MSSR(8, BIT(0), BIT(0))),
+	DEF_MOD("ostm0",	R9A07G044L_CLK_OSTM0,
+				R9A07G044L_CLK_P0,
+				MSSR(13, BIT(0), BIT(0))),
+	DEF_MOD("ostm1",	R9A07G044L_CLK_OSTM1,
+				R9A07G044L_CLK_P0,
+				MSSR(13, BIT(1), BIT(1))),
+	DEF_MOD("ostm2",	R9A07G044L_CLK_OSTM2,
+				R9A07G044L_CLK_P0,
+				MSSR(13, BIT(2), BIT(3))),
+	DEF_MOD("wdt0",		R9A07G044L_CLK_WDT0,
+				R9A07G044L_CLK_P0,
+				MSSR(18, (BIT(0) | BIT(1)), BIT(0))),
+	DEF_MOD("wdt1",		R9A07G044L_CLK_WDT1,
+				R9A07G044L_CLK_P0,
+				MSSR(18, (BIT(2) | BIT(3)), BIT(1))),
+	DEF_MOD("wdt2",		R9A07G044L_CLK_WDT2,
+				R9A07G044L_CLK_P0,
+				MSSR(18, (BIT(4) | BIT(5)), BIT(2))),
+	DEF_MOD("wdt_pon",	R9A07G044L_CLK_WDT_PON,
+				R9A07G044L_CLK_P0,
+				MSSR(18, (BIT(6) | BIT(7)), BIT(3))),
+	DEF_MOD("gpu",		R9A07G044L_CLK_GPU,
+				R9A07G044L_CLK_G,
+				MSSR(22, (BIT(0) | BIT(1) | BIT(2)),
+					 (BIT(0) | BIT(1) | BIT(2)))),
+	DEF_MOD("isu",		R9A07G044L_CLK_ISU,
+				R9A07G044L_CLK_P1,
+				MSSR(23, (BIT(0) | BIT(1)), (BIT(0) | BIT(1)))),
+	DEF_MOD("h264",		R9A07G044L_CLK_H264,
+				R9A07G044L_CLK_M0,
+				MSSR(24, BIT(0), (BIT(0) | BIT(1)))),
+	DEF_MOD("cru",		R9A07G044L_CLK_CRU,
+				R9A07G044L_CLK_M2,
+				MSSR(25, (BIT(0) | BIT(1) | BIT(3) | BIT(4)),
+					 (BIT(0) | BIT(1) | BIT(2)))),
+	DEF_MOD("mipi_dsi",	R9A07G044L_CLK_MIPI_DSI,
+				R9A07G044L_CLK_P2,
+				MSSR(26, (BIT(0) | BIT(1) | BIT(2) | BIT(3)
+							  | BIT(4) | BIT(5)),
+					 (BIT(0) | BIT(1) | BIT(2)))),
+	DEF_MOD("lcdc",		R9A07G044L_CLK_LCDC,
+				R9A07G044L_CLK_M3,
+				MSSR(27, (BIT(0) | BIT(1)), BIT(0))),
+	DEF_MOD("src",		R9A07G044L_CLK_SRC,
+				R9A07G044L_CLK_P0,
+				MSSR(29, BIT(0), BIT(0))),
+	DEF_MOD("rspi0",	R9A07G044L_CLK_RSPI0,
+				R9A07G044L_CLK_P0,
+				MSSR(36, BIT(0), BIT(0))),
+	DEF_MOD("rspi1",	R9A07G044L_CLK_RSPI1,
+				R9A07G044L_CLK_P0,
+				MSSR(36, BIT(1), BIT(1))),
+	DEF_MOD("rspi2",	R9A07G044L_CLK_RSPI2,
+				R9A07G044L_CLK_P0,
+				MSSR(36, BIT(2), BIT(2))),
+	DEF_MOD("adc",		R9A07G044L_CLK_ADC,
+				R9A07G044L_CLK_TSU,
+				MSSR(42, (BIT(0) | BIT(1)), (BIT(0) | BIT(1)))),
+	DEF_MOD("tsu",		R9A07G044L_CLK_TSU_PCLK,
+				R9A07G044L_CLK_TSU,
+				MSSR(43, BIT(0), BIT(0))),
+	DEF_MOD("spi-multi",	R9A07G044L_CLK_SPI,
+				R9A07G044L_CLK_SPI1,
+				MSSR(21, (BIT(0) | BIT(1)), BIT(0))),
+	DEF_MOD("mipi_dsi_v",	R9A07G044L_CLK_MIPI_DSI_V,
+				R9A07G044L_CLK_M3, 0),
+	DEF_MOD("mipi_dsi_pin", R9A07G044L_CLK_MIPI_DSI_PIN,
+				R9A07G044L_CLK_M1, 0),
+};
+
+static const unsigned int r9a07g044l_crit_mod_clks[] __initconst = {
+	CLK_MODE_BASE + R9A07G044L_CLK_GIC600,
+};
+
+const struct cpg_mssr_info r9a07g044l_cpg_info = {
+	/* Core clk */
+	.core_clks = r9a07g044l_core_clks,
+	.num_core_clks = ARRAY_SIZE(r9a07g044l_core_clks),
+	.last_dt_core_clk = LAST_DT_CORE_CLK,
+	.num_total_core_clks = CLK_MODE_BASE,
+	/* Critical Module Clocks */
+	.crit_mod_clks = r9a07g044l_crit_mod_clks,
+	.num_crit_mod_clks = ARRAY_SIZE(r9a07g044l_crit_mod_clks),
+	/* Module clk */
+	.mod_clks = r9a07g044l_mod_clks,
+	.num_mod_clks = ARRAY_SIZE(r9a07g044l_mod_clks),
+	.num_hw_mod_clks = R9A07G044L_CLK_MIPI_DSI_PIN + 1,
+};
diff --git a/drivers/clk/renesas/renesas-rzg2l-cpg.c b/drivers/clk/renesas/renesas-rzg2l-cpg.c
new file mode 100644
index 0000000..a4ce18b
--- /dev/null
+++ b/drivers/clk/renesas/renesas-rzg2l-cpg.c
@@ -0,0 +1,1189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RZG2L Clock Pulse Generator
+ *
+ * Copyright (C) 2020 Renesas Electronics Corp.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/renesas.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_clock.h>
+#include <linux/pm_domain.h>
+#include <linux/psci.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <dt-bindings/clock/renesas-cpg-mssr.h>
+
+#include "renesas-rzg2l-cpg.h"
+
+#ifdef DEBUG
+#define WARN_DEBUG(x)	WARN_ON(x)
+#else
+#define WARN_DEBUG(x)	do { } while (0)
+#endif
+
+/*register value parser*/
+/*Right shift and apply mask*/
+#define DIV_RSMASK(v, s, m)	((v >> s) & m)
+#define GET_REG(val)		((val >> 20) & 0xfff)
+#define GET_SHIFT(val)		((val >> 12) & 0xff)
+#define GET_WIDTH(val)		((val >> 8) & 0xf)
+
+#define KDIV(val)		DIV_RSMASK(val, 16, 0xffff)
+#define MDIV(val)		DIV_RSMASK(val, 6, 0x3ff)
+#define PDIV(val)		DIV_RSMASK(val, 0, 0x3f)
+#define SDIV(val)		DIV_RSMASK(val, 0, 0x7)
+#define REFDIV(val)		DIV_RSMASK(val, 8, 0x3f)
+#define POSTDIV1(val)		DIV_RSMASK(val, 0, 0x7)
+#define POSTDIV2(val)		DIV_RSMASK(val, 4, 0x7)
+#define FRACIN(val)		DIV_RSMASK(val, 8, 0xffffff)
+#define INITIN(val)		DIV_RSMASK(val, 16, 0xfff)
+
+/**
+ * Clock Pulse Generator Private Data
+ *
+ * @dev: CPG/MSSR device
+ * @base: CPG/MSSR register block base address
+ * @rmw_lock: protects RMW register accesses
+ * @clks: Array containing all Core and Module Clocks
+ * @num_core_clks: Number of Core Clocks in clks[]
+ * @num_mod_clks: Number of Module Clocks in clks[]
+ * @last_dt_core_clk: ID of the last Core Clock exported to DT
+ * @notifiers: Notifier chain to save/restore clock state for system resume
+ */
+struct cpg_mssr_priv {
+#ifdef CONFIG_RESET_CONTROLLER
+	struct reset_controller_dev rcdev;
+#endif
+	struct device *dev;
+	void __iomem *base;
+	spinlock_t rmw_lock;
+
+	struct clk **clks;
+	unsigned int num_core_clks;
+	unsigned int num_mod_clks;
+	unsigned int last_dt_core_clk;
+
+	struct raw_notifier_head notifiers;
+	const struct cpg_mssr_info *info;
+};
+
+static const struct of_device_id rzg2l_cpg_match[] = {
+#ifdef CONFIG_CLK_R9A07G044L
+	{
+		.compatible = "renesas,r9a07g044l-cpg",
+		.data = &r9a07g044l_cpg_info,
+	},
+#endif
+	{ /* sentinel */ }
+};
+
+static void rzg2l_cpg_del_clk_provider(void *data)
+{
+	of_clk_del_provider(data);
+}
+
+struct clk * __init rzg2l_cpg_div_clk_register(const struct cpg_core_clk *core,
+						struct clk **clks,
+						void __iomem *base,
+						struct cpg_mssr_priv *priv)
+{
+	const struct clk *parent;
+	struct clk_hw *clk_hw;
+	struct device *dev = priv->dev;
+	const char *parent_name;
+
+	parent = clks[core->parent & 0xffff];   /* some types use high bits */
+	if (IS_ERR(parent))
+		return ERR_CAST(parent);
+
+	parent_name = __clk_get_name(parent);
+
+	if (core->dtable)
+		clk_hw = clk_hw_register_divider_table(dev,
+			core->name, parent_name, 0,
+			base + GET_REG(core->conf),
+			GET_SHIFT(core->conf), GET_WIDTH(core->conf),
+			core->flag, core->dtable, &priv->rmw_lock);
+	else
+		clk_hw = clk_hw_register_divider(dev, core->name,
+			parent_name, 0, base + GET_REG(core->conf),
+			GET_SHIFT(core->conf), GET_WIDTH(core->conf),
+			core->flag, &priv->rmw_lock);
+
+	if (IS_ERR(clk_hw))
+		return NULL;
+
+	return clk_hw->clk;
+}
+
+struct clk * __init rzg2l_cpg_sell_clk_register(const struct cpg_core_clk *core,
+		void __iomem *base, struct cpg_mssr_priv *priv)
+{
+	const struct clk_hw *clk_hw;
+
+	clk_hw = clk_hw_register_mux(priv->dev, core->name,
+			core->parent_names, core->num_parents,
+			core->flag == CLK_MUX_READ_ONLY ?
+					CLK_SET_RATE_PARENT : 0,
+			base + GET_REG(core->conf),
+			GET_SHIFT(core->conf), GET_WIDTH(core->conf),
+			core->flag, &priv->rmw_lock);
+
+	if (IS_ERR(clk_hw))
+		return NULL;
+
+	return clk_hw->clk;
+}
+
+struct div2_clk {
+	struct clk_hw hw;
+	unsigned int conf;
+	struct clk_div_table *dtable;
+	unsigned int confs;
+	struct clk_div_table *dtables;
+	void __iomem *base;
+	struct cpg_mssr_priv *priv;
+};
+
+#define to_d2clk(_hw)	container_of(_hw, struct div2_clk, hw)
+unsigned int div2_clock_get_div(unsigned int val,
+			struct clk_div_table *t,
+			int length)
+{
+	int i;
+
+	for (i = 0; i <= length; i++)
+		if (val == t[i].val)
+			return t[i].div;
+
+	/*return div as 1 if failed*/
+	return 1;
+}
+
+static unsigned long rzg2l_cpg_div2_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct div2_clk *d2clk = to_d2clk(hw);
+	u32 div, divs, val, vals;
+
+	val = readl(d2clk->base + GET_REG(d2clk->conf));
+	div = DIV_RSMASK(val, GET_SHIFT(d2clk->conf),
+			(BIT(GET_WIDTH(d2clk->conf)) - 1));
+	div = div2_clock_get_div(div, d2clk->dtable,
+			(BIT(GET_WIDTH(d2clk->conf)) - 1));
+
+	vals = readl(d2clk->base + GET_REG(d2clk->confs));
+	divs = DIV_RSMASK(val, GET_SHIFT(d2clk->confs),
+			(BIT(GET_WIDTH(d2clk->confs)) - 1));
+	divs = div2_clock_get_div(divs, d2clk->dtables,
+			(BIT(GET_WIDTH(d2clk->confs)) - 1));
+
+	div = div * divs;
+
+	return DIV_ROUND_CLOSEST_ULL((u64)parent_rate, div);
+}
+
+static long rzg2l_cpg_div2_clk_round_rate(struct clk_hw *hw,
+					unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct div2_clk *d2clk = to_d2clk(hw);
+	unsigned long best_diff = (unsigned long)-1;
+	unsigned long diff;
+	unsigned int best_div, best_divs, div, divs;
+	int i, j, n, ns;
+
+	n = BIT(GET_WIDTH(d2clk->conf)) - 1;
+	ns = BIT(GET_WIDTH(d2clk->confs)) - 1;
+	for (i = 0; i <= n; i++) {
+		for (j = 0; j <= ns; j++) {
+			div = div2_clock_get_div(i, d2clk->dtable, n);
+			divs = div2_clock_get_div(j, d2clk->dtables, ns);
+			diff = abs(*parent_rate - (rate * div * divs));
+			if (best_diff > diff) {
+				best_diff = diff;
+				best_div = div;
+				best_divs = divs;
+			}
+		}
+	}
+
+	return DIV_ROUND_CLOSEST_ULL((u64)*parent_rate, best_div * best_divs);
+}
+
+static int rzg2l_cpg_div2_clk_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct div2_clk *d2clk = to_d2clk(hw);
+	struct cpg_mssr_priv *priv = d2clk->priv;
+	unsigned long best_diff = (unsigned long)-1;
+	unsigned long diff, flags;
+	unsigned int div, divs, val, vals, n, ns;
+	int i, j;
+
+	n = BIT(GET_WIDTH(d2clk->conf)) - 1;
+	ns = BIT(GET_WIDTH(d2clk->confs)) - 1;
+	for (i = 0; i <= n; i++) {
+		for (j = 0; j <= ns; j++) {
+			div = div2_clock_get_div(i, d2clk->dtable, n);
+			divs = div2_clock_get_div(j, d2clk->dtables, ns);
+			diff = abs(parent_rate - (rate * div * divs));
+			if (best_diff > diff) {
+				best_diff = diff;
+				val = i;
+				vals = j;
+			}
+		}
+	}
+
+	spin_lock_irqsave(&priv->rmw_lock, flags);
+
+	val = (val << GET_SHIFT(d2clk->conf))
+	    | (0x1 << (GET_SHIFT(d2clk->conf) + 16));
+	writel(val, d2clk->base + GET_REG(d2clk->conf));
+
+	vals = (vals << GET_SHIFT(d2clk->confs))
+	    | (0x1 << (GET_SHIFT(d2clk->confs) + 16));
+	writel(vals, d2clk->base + GET_REG(d2clk->confs));
+
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops rzg2l_cpg_div2_ops = {
+	.recalc_rate = rzg2l_cpg_div2_clk_recalc_rate,
+	.round_rate = rzg2l_cpg_div2_clk_round_rate,
+	.set_rate = rzg2l_cpg_div2_clk_set_rate,
+};
+
+struct clk * __init rzg2l_cpg_div2_clk_register(const struct cpg_core_clk *core,
+						struct clk **clks,
+						void __iomem *base,
+						struct cpg_mssr_priv *priv)
+{
+	const struct clk *parent;
+	struct clk_init_data init;
+	struct div2_clk *d2clk;
+	struct device *dev = priv->dev;
+	struct clk *clk;
+	const char *parent_name;
+
+	parent = clks[core->parent & 0xffff];   /* some types use high bits */
+	if (IS_ERR(parent))
+		return ERR_CAST(parent);
+
+	d2clk = devm_kzalloc(dev, sizeof(*d2clk), GFP_KERNEL);
+	if (!d2clk) {
+		clk = ERR_PTR(-ENOMEM);
+		return NULL;
+	}
+
+	parent_name = __clk_get_name(parent);
+	init.name = core->name;
+	init.ops = &rzg2l_cpg_div2_ops;
+	init.flags = 0;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	d2clk->hw.init = &init;
+	d2clk->conf = core->conf;
+	d2clk->confs = core->confs;
+	d2clk->dtable = core->dtable;
+	d2clk->dtables = core->dtables;
+	d2clk->base = base;
+	d2clk->priv = priv;
+
+	clk = clk_register(NULL, &d2clk->hw);
+	if (IS_ERR(clk))
+		kfree(d2clk);
+
+	return clk;
+}
+
+struct pll_clk {
+	struct clk_hw hw;
+	unsigned int stby_conf;
+	unsigned int mon_conf;
+	unsigned int conf;
+	void __iomem *base;
+	struct cpg_mssr_priv *priv;
+	unsigned int type;
+};
+
+#define to_pll(_hw)	container_of(_hw, struct pll_clk, hw)
+
+static int rzg2l_pll_clock_endisable(struct clk_hw *hw, bool enable)
+{
+	struct pll_clk *pll_clk = to_pll(hw);
+	struct cpg_mssr_priv *priv = pll_clk->priv;
+	struct device *dev = priv->dev;
+	unsigned long flags;
+	u32 value;
+
+	dev_dbg(dev, "PLL CLK_ON %pC %s\n", hw->clk,
+		enable ? "ON" : "OFF");
+	spin_lock_irqsave(&priv->rmw_lock, flags);
+
+	if (enable) {
+		value = PLL_RES(pll_clk->stby_conf)
+			| PLL_RES(pll_clk->stby_conf) << 16;
+		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
+		udelay(10);
+		value = PLL_EN(pll_clk->stby_conf)
+			| PLL_EN(pll_clk->stby_conf) << 16;
+		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
+		udelay(10);
+
+		if(!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
+			& PLL_EN(pll_clk->mon_conf))
+		  && !!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
+			& PLL_RES(pll_clk->mon_conf)))
+			goto failed;
+	} else {
+		value = PLL_EN(pll_clk->stby_conf) << 16;
+		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
+		udelay(10);
+		value = PLL_RES(pll_clk->stby_conf) << 16;
+		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
+		udelay(10);
+
+		if(!!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
+			& PLL_EN(pll_clk->mon_conf))
+		  && !(readl(priv->base + PLL_REG(pll_clk->mon_conf))
+			& PLL_RES(pll_clk->mon_conf)))
+			goto failed;
+	}
+
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+	return 0;
+
+failed:
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+	dev_err(dev, "Failed to %s %pC\n",
+			enable ? "Enable" : "Disable",
+			hw->clk);
+	return -ETIMEDOUT;
+}
+
+static int rzg2l_pll_clock_enable(struct clk_hw *hw)
+{
+	return rzg2l_pll_clock_endisable(hw, true);
+}
+
+static void rzg2l_pll_clock_disable(struct clk_hw *hw)
+{
+	rzg2l_pll_clock_endisable(hw, false);
+}
+
+static int rzg2l_pll_clock_is_enabled(struct clk_hw *hw)
+{
+	struct pll_clk *pll_clk = to_pll(hw);
+	struct cpg_mssr_priv *priv = pll_clk->priv;
+	u32 value;
+
+	value = readl(priv->base + PLL_REG(pll_clk->mon_conf));
+
+	return (!(value & PLL_EN(pll_clk->mon_conf))
+		  && !!(value & PLL_RES(pll_clk->mon_conf)));
+}
+
+static unsigned long rzg2l_cpg_pll_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct pll_clk *pll_clk = to_pll(hw);
+	struct cpg_mssr_priv *priv = pll_clk->priv;
+	unsigned int mult = 1;
+	unsigned int div = 1;
+	unsigned int val1, val2;
+
+	if (pll_clk->type == CLK_TYPE_SAM_PLL) {
+		val1 = readl(priv->base + GET_REG1(pll_clk->conf));
+		val2 = readl(priv->base + GET_REG2(pll_clk->conf));
+		mult = MDIV(val1) + KDIV(val1)/65536;
+		div = PDIV(val1) * (1 << SDIV(val2));
+	} else if (pll_clk->type == CLK_TYPE_SI_PLL) {
+		unsigned int val3;
+
+		val1 = readl(priv->base + GET_REG1(pll_clk->conf));
+		val2 = readl(priv->base + GET_REG2(pll_clk->conf));
+		val3 = readl(priv->base + GET_REG3(pll_clk->conf));
+
+		mult = INITIN(val3) + FRACIN(val2)/(0x1<<24);
+		div = POSTDIV1(val1) * POSTDIV2(val1) * REFDIV(val1);
+	} else {
+		return 0;
+	}
+
+	return DIV_ROUND_CLOSEST_ULL((u64)parent_rate * mult, div);
+}
+
+static long rzg2l_cpg_pll_clk_round_rate(struct clk_hw *hw,
+					unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct pll_clk *pll_clk = to_pll(hw);
+	unsigned long best_diff = (unsigned long)-1;
+	unsigned long diff;
+	unsigned int div, mult, best_mult, best_div;
+
+	if (pll_clk->type == CLK_TYPE_SAM_PLL) {
+		unsigned int m, p, s;
+		/*we will not support Floating point*/
+		/*mult = m + (k/65536) => mult = m*/
+		for (m = 64; m < 534; m++) {
+			for (p = 1; p < 5; p++) {
+				for (s = 0; s < 7; s++) {
+					div = p * (0x1 << s);
+					mult  = m;
+					diff = abs((*parent_rate * mult)
+						- (rate * div));
+					if (best_diff > diff) {
+						best_diff = diff;
+						best_mult = mult;
+						best_div = div;
+					}
+				}
+			}
+		}
+	} else if (pll_clk->type == CLK_TYPE_SI_PLL) {
+		unsigned int p1, p2, ref, fracin, intin;
+		/*we will not support Floating point*/
+		/*mult = intin + fracin/(0x1<<24) => mult = intin*/
+		fracin = 0;
+		for (p1 = 1; p1 <= 7; p1++) {
+			for (p2 = 1; p2 <= 7; p2++) {
+				for (ref = 1; ref <= 63; ref++) {
+					for (intin = 0; intin < 4096; intin++) {
+						mult = intin;
+						div = ref * p1 * p2;
+						diff = abs((*parent_rate * mult)
+							- (rate * div));
+						if (best_diff > diff) {
+							best_diff = diff;
+							best_mult = mult;
+							best_div = div;
+						}
+					}
+				}
+			}
+		}
+	} else {
+		return 0;
+	}
+
+	return DIV_ROUND_CLOSEST_ULL((u64)*parent_rate * best_mult, best_div);
+}
+
+static int rzg2l_cpg_pll_clk_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct pll_clk *pll_clk = to_pll(hw);
+	struct cpg_mssr_priv *priv = pll_clk->priv;
+	unsigned long best_diff = (unsigned long)-1;
+	unsigned long diff, flags;
+	unsigned int div, mult, val1, val2;
+
+
+	if (pll_clk->type == CLK_TYPE_SAM_PLL) {
+		unsigned int m, p, s, best_m, best_p, best_s;
+		short best_k, k;
+		/*we will not support Floating point*/
+		/*mult = m + (k/65536) => mult = m*/
+		k = 0;
+		for (m = 64; m < 534; m++) {
+			for (p = 1; p < 5; p++) {
+				for (s = 0; s < 7; s++) {
+					div = p * (0x1 << s);
+					mult  = m;
+					diff = abs((parent_rate * mult)
+						- (rate * div));
+					if (best_diff > diff) {
+						best_diff = diff;
+						best_k = k;
+						best_m = m;
+						best_p = p;
+						best_s = s;
+					}
+				}
+			}
+		}
+
+		spin_lock_irqsave(&priv->rmw_lock, flags);
+
+		val1 = (best_k << 16) | best_m << 6 | best_p;
+		writel(val1, pll_clk->base + GET_REG1(pll_clk->conf));
+
+		val2 = (readl(pll_clk->base + GET_REG2(pll_clk->conf))
+			& (~0xf)) | best_s;
+		writel(val2, pll_clk->base + GET_REG2(pll_clk->conf));
+
+		spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+	} else if (pll_clk->type == CLK_TYPE_SI_PLL) {
+		unsigned int p1, p2, ref, fracin, intin, val3;
+		unsigned int best_p1, best_p2, best_ref,
+				best_fracin, best_intin;
+		/*we will not support Floating point*/
+		/*mult = intin + fracin/(0x1<<24) => mult = intin*/
+		fracin = 0;
+		for (p1 = 1; p1 <= 7; p1++) {
+			for (p2 = 1; p2 <= 7; p2++) {
+				for (ref = 1; ref <= 63; ref++) {
+					for (intin = 0; intin < 4096; intin++) {
+						mult = intin;
+						div = ref * p1 * p2;
+						diff = abs((parent_rate * mult)
+							- (rate * div));
+						if (best_diff > diff) {
+							best_diff = diff;
+							best_p1 = p1;
+							best_p2 = p2;
+							best_ref = ref;
+							best_fracin = fracin;
+							best_intin = intin;
+						}
+					}
+				}
+			}
+		}
+
+		spin_lock_irqsave(&priv->rmw_lock, flags);
+
+		val1 = (best_ref << 8) | (best_p2 << 4) | best_p1
+			| (0x1 << 24) | (0x1 << 20) | (0x1 << 16);
+		writel(val1, pll_clk->base + GET_REG1(pll_clk->conf));
+
+		val2 = (readl(pll_clk->base + GET_REG2(pll_clk->conf))
+			& (~0xffffff00)) | (best_fracin << 8);
+		writel(val2, pll_clk->base + GET_REG2(pll_clk->conf));
+
+		val3 = (readl(pll_clk->base + GET_REG3(pll_clk->conf))
+			& (~0x0fff0000)) | (best_intin << 16);
+		writel(val3, pll_clk->base + GET_REG3(pll_clk->conf));
+
+		spin_unlock_irqrestore(&priv->rmw_lock, flags);
+	}
+
+	return 0;
+}
+
+static const struct clk_ops rzg2l_cpg_pll_ops = {
+	.recalc_rate = rzg2l_cpg_pll_clk_recalc_rate,
+	.round_rate = rzg2l_cpg_pll_clk_round_rate,
+	.set_rate = rzg2l_cpg_pll_clk_set_rate,
+	.enable = rzg2l_pll_clock_enable,
+	.disable = rzg2l_pll_clock_disable,
+	.is_enabled = rzg2l_pll_clock_is_enabled,
+};
+
+struct clk * __init rzg2l_cpg_pll_clk_register(const struct cpg_core_clk *core,
+						struct clk **clks,
+						void __iomem *base,
+						struct cpg_mssr_priv *priv)
+{
+	const struct clk *parent;
+	struct clk_init_data init;
+	struct pll_clk *pll_clk;
+	struct device *dev = priv->dev;
+	struct clk *clk;
+	const char *parent_name;
+
+	parent = clks[core->parent & 0xffff];   /* some types use high bits */
+	if (IS_ERR(parent))
+		return ERR_CAST(parent);
+
+	pll_clk = devm_kzalloc(dev, sizeof(*pll_clk), GFP_KERNEL);
+	if (!pll_clk) {
+		clk = ERR_PTR(-ENOMEM);
+		return NULL;
+	}
+
+	parent_name = __clk_get_name(parent);
+	init.name = core->name;
+	init.ops = &rzg2l_cpg_pll_ops;
+	init.flags = 0;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	pll_clk->hw.init = &init;
+	pll_clk->stby_conf = core->stby_conf;
+	pll_clk->mon_conf = core->mon_conf;
+	pll_clk->conf = core->conf;
+	pll_clk->base = base;
+	pll_clk->priv = priv;
+	pll_clk->type = core->type;
+
+	clk = clk_register(NULL, &pll_clk->hw);
+	if (IS_ERR(clk))
+		kfree(pll_clk);
+
+	return clk;
+}
+
+static struct clk *rzg2l_cpg_clk_src_twocell_get(
+				struct of_phandle_args *clkspec,
+				void *data)
+{
+	unsigned int clkidx = clkspec->args[1];
+	struct cpg_mssr_priv *priv = data;
+	struct device *dev = priv->dev;
+	const char *type;
+	struct clk *clk;
+
+	switch (clkspec->args[0]) {
+	case CPG_CORE:
+		type = "core";
+		if (clkidx > priv->last_dt_core_clk) {
+			dev_err(dev, "Invalid %s clock index %u\n", type,
+			       clkidx);
+			return ERR_PTR(-EINVAL);
+		}
+		clk = priv->clks[clkidx];
+		break;
+
+	case CPG_MOD:
+		type = "module";
+		if (clkidx > priv->num_core_clks + priv->num_mod_clks) {
+			dev_err(dev, "Invalid %s clock index %u\n", type,
+				clkidx);
+			return ERR_PTR(-EINVAL);
+		}
+		clk = priv->clks[priv->num_core_clks + clkidx];
+		break;
+
+	default:
+		dev_err(dev, "Invalid CPG clock type %u\n", clkspec->args[0]);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (IS_ERR(clk))
+		dev_err(dev, "Cannot get %s clock %u: %ld", type, clkidx,
+			PTR_ERR(clk));
+	else
+		dev_dbg(dev, "clock (%u, %u) is %pC at %lu Hz\n",
+			clkspec->args[0], clkspec->args[1], clk,
+			clk_get_rate(clk));
+	return clk;
+}
+
+static void __init rzg2l_cpg_register_core_clk(const struct cpg_core_clk *core,
+			const struct cpg_mssr_info *info,
+			struct cpg_mssr_priv *priv)
+{
+	struct clk *clk = ERR_PTR(-ENOTSUPP), *parent;
+	struct device *dev = priv->dev;
+	unsigned int id = core->id, div = core->div;
+	const char *parent_name;
+
+	WARN_DEBUG(id >= priv->num_core_clks);
+	WARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);
+
+	if (!core->name) {
+		/* Skip NULLified clock */
+		return;
+	}
+
+	switch (core->type) {
+	case CLK_TYPE_IN:
+		clk = of_clk_get_by_name(priv->dev->of_node, core->name);
+		break;
+	case CLK_TYPE_FF:
+		WARN_DEBUG(core->parent >= priv->num_core_clks);
+		parent = priv->clks[core->parent];
+		if (IS_ERR(parent)) {
+			clk = parent;
+			goto fail;
+		}
+
+		parent_name = __clk_get_name(parent);
+		clk = clk_register_fixed_factor(NULL, core->name,
+				parent_name, CLK_SET_RATE_PARENT,
+				core->mult, div);
+		break;
+	case CLK_TYPE_SAM_PLL:
+	case CLK_TYPE_SI_PLL:
+		clk = rzg2l_cpg_pll_clk_register(core, priv->clks,
+						 priv->base, priv);
+		break;
+	case CLK_TYPE_DIV:
+		clk = rzg2l_cpg_div_clk_register(core, priv->clks,
+						 priv->base, priv);
+		break;
+	case CLK_TYPE_2DIV:
+		clk = rzg2l_cpg_div2_clk_register(core, priv->clks,
+						  priv->base, priv);
+		break;
+	case CLK_TYPE_MUX:
+		clk = rzg2l_cpg_sell_clk_register(core, priv->base, priv);
+		break;
+	default:
+		goto fail;
+	};
+
+	if (IS_ERR_OR_NULL(clk))
+		goto fail;
+
+	dev_dbg(dev, "Core clock %pC at %lu Hz\n", clk, clk_get_rate(clk));
+	priv->clks[id] = clk;
+	return;
+
+fail:
+	dev_err(dev, "Failed to register %s clock %s: %ld\n", "core",
+		core->name, PTR_ERR(clk));
+}
+
+/**
+ * struct mstp_clock - MSTP gating clock
+ * @hw: handle between common and hardware-specific interfaces
+ * @bit: 16bits register offset, 8bits ON/MON, 8bits RESET
+ * @priv: CPG/MSSR private data
+ */
+struct mstp_clock {
+	struct clk_hw hw;
+	u32 bit;
+	struct cpg_mssr_priv *priv;
+};
+
+#define to_mod_clock(_hw) container_of(_hw, struct mstp_clock, hw)
+
+static int rzg2l_mod_clock_endisable(struct clk_hw *hw, bool enable)
+{
+	struct mstp_clock *clock = to_mod_clock(hw);
+	struct cpg_mssr_priv *priv = clock->priv;
+	unsigned int reg = MSSR_OFF(clock->bit) * 4;
+	struct device *dev = priv->dev;
+	unsigned long flags;
+	unsigned int i;
+	u32 value;
+
+	if (clock->bit == 0) {
+		dev_dbg(dev, "%pC does not support ON/OFF\n",  hw->clk);
+		return 0;
+	}
+
+	dev_dbg(dev, "CLK_ON %u@%u/%pC %s\n",
+			CLK_ON_R(reg), clock->bit, hw->clk,
+			enable ? "ON" : "OFF");
+	spin_lock_irqsave(&priv->rmw_lock, flags);
+
+	if (enable)
+		value = (MSSR_ON(clock->bit) << 16) | MSSR_ON(clock->bit);
+	else
+		value = MSSR_ON(clock->bit) << 16;
+	writel(value, priv->base + CLK_ON_R(reg));
+
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+
+	if (!enable)
+		return 0;
+
+	for (i = 1000; i > 0; --i) {
+		if (((readl(priv->base + CLK_MON_R(reg)))
+			& MSSR_ON(clock->bit)))
+			break;
+		cpu_relax();
+	}
+
+	if (!i) {
+		dev_err(dev, "Failed to enable CLK_ON %p\n",
+			priv->base + CLK_ON_R(reg));
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int rzg2l_mod_clock_enable(struct clk_hw *hw)
+{
+	return rzg2l_mod_clock_endisable(hw, true);
+}
+
+static void rzg2l_mod_clock_disable(struct clk_hw *hw)
+{
+	rzg2l_mod_clock_endisable(hw, false);
+}
+
+static int rzg2l_mod_clock_is_enabled(struct clk_hw *hw)
+{
+	struct mstp_clock *clock = to_mod_clock(hw);
+	struct cpg_mssr_priv *priv = clock->priv;
+	u32 value;
+
+	if (clock->bit == 0) {
+		dev_dbg(priv->dev, "%pC does not support ON/OFF\n",  hw->clk);
+		return 1;
+	}
+
+	value = readl(priv->base + CLK_MON_R(MSSR_OFF(clock->bit) * 4));
+
+	return !(value & (MSSR_ON(clock->bit)));
+}
+
+static const struct clk_ops rzg2l_mod_clock_ops = {
+	.enable = rzg2l_mod_clock_enable,
+	.disable = rzg2l_mod_clock_disable,
+	.is_enabled = rzg2l_mod_clock_is_enabled,
+};
+
+static void __init rzg2l_cpg_register_mod_clk(const struct mssr_mod_clk *mod,
+				     const struct cpg_mssr_info *info,
+				     struct cpg_mssr_priv *priv)
+{
+	struct mstp_clock *clock = NULL;
+	struct device *dev = priv->dev;
+	unsigned int id = mod->id;
+	struct clk_init_data init;
+	struct clk *parent, *clk;
+	const char *parent_name;
+	unsigned int i;
+
+	WARN_DEBUG(id < priv->num_core_clks);
+	WARN_DEBUG(id >= priv->num_core_clks + priv->num_mod_clks);
+	WARN_DEBUG(mod->parent >= priv->num_core_clks + priv->num_mod_clks);
+	WARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);
+
+	if (!mod->name) {
+		/* Skip NULLified clock */
+		return;
+	}
+
+	parent = priv->clks[mod->parent];
+	if (IS_ERR(parent)) {
+		clk = parent;
+		goto fail;
+	}
+
+	clock = devm_kzalloc(dev, sizeof(*clock), GFP_KERNEL);
+	if (!clock) {
+		clk = ERR_PTR(-ENOMEM);
+		goto fail;
+	}
+
+	init.name = mod->name;
+	init.ops = &rzg2l_mod_clock_ops;
+	init.flags = CLK_SET_RATE_PARENT;
+	for (i = 0; i < info->num_crit_mod_clks; i++)
+		if (id == info->crit_mod_clks[i]) {
+			dev_dbg(dev, "CPG %s setting CLK_IS_CRITICAL\n",
+				mod->name);
+			init.flags |= CLK_IS_CRITICAL;
+			break;
+		}
+
+	parent_name = __clk_get_name(parent);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	clock->bit = mod->bit;
+	clock->priv = priv;
+	clock->hw.init = &init;
+
+	clk = clk_register(NULL, &clock->hw);
+	if (IS_ERR(clk))
+		goto fail;
+
+	dev_dbg(dev, "Module clock %pC at %lu Hz\n", clk, clk_get_rate(clk));
+	priv->clks[id] = clk;
+	return;
+
+fail:
+	dev_err(dev, "Failed to register %s clock %s: %ld\n", "module",
+		mod->name, PTR_ERR(clk));
+	kfree(clock);
+}
+
+#ifdef CONFIG_RESET_CONTROLLER
+
+#define rcdev_to_priv(x)	container_of(x, struct cpg_mssr_priv, rcdev)
+
+static int rzg2l_cpg_reset(struct reset_controller_dev *rcdev,
+			  unsigned long id)
+{
+	struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+	const struct cpg_mssr_info *info = priv->info;
+	unsigned int reg = MSSR_OFF(info->mod_clks[id].bit) * 0x4;
+	u32 dis = MSSR_RES(info->mod_clks[id].bit);
+	u32 we = dis << 16;
+
+	dev_dbg(rcdev->dev, "reset %u%02u\n", reg, info->mod_clks[id].bit);
+
+	/* Reset module */
+	writel(we, priv->base + CLK_RST_R(reg));
+
+	/* Wait for at least one cycle of the RCLK clock (@ ca. 32 kHz) */
+	udelay(35);
+
+	/* Release module from reset state */
+	writel(we | dis, priv->base + CLK_RST_R(reg));
+
+	return 0;
+}
+
+static int rzg2l_cpg_assert(struct reset_controller_dev *rcdev,
+			unsigned long id)
+{
+	struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+	const struct cpg_mssr_info *info = priv->info;
+	unsigned int reg = MSSR_OFF(info->mod_clks[id].bit) * 0x4;
+	u32 value = MSSR_RES(info->mod_clks[id].bit) << 16;
+
+	dev_dbg(rcdev->dev, "assert %u%02u\n", reg, info->mod_clks[id].bit);
+
+	writel(value, priv->base + CLK_RST_R(reg));
+	return 0;
+}
+
+static int rzg2l_cpg_deassert(struct reset_controller_dev *rcdev,
+			     unsigned long id)
+{
+	struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+	const struct cpg_mssr_info *info = priv->info;
+	unsigned int reg = MSSR_OFF(info->mod_clks[id].bit) * 0x4;
+	u32 dis = MSSR_RES(info->mod_clks[id].bit);
+	u32 value = (dis << 16) | dis;
+
+	dev_dbg(rcdev->dev, "deassert %u%02u\n", reg, info->mod_clks[id].bit);
+
+	writel(value, priv->base + CLK_RST_R(reg));
+	return 0;
+}
+
+static int rzg2l_cpg_status(struct reset_controller_dev *rcdev,
+			   unsigned long id)
+{
+	struct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);
+	const struct cpg_mssr_info *info = priv->info;
+	unsigned int reg = MSSR_OFF(info->mod_clks[id].bit) * 0x4;
+	u32 bitmask = MSSR_RES(info->mod_clks[id].bit);
+
+	return !(readl(priv->base + CLK_MRST_R(reg)) & bitmask);
+}
+
+static const struct reset_control_ops rzg2l_cpg_reset_ops = {
+	.reset = rzg2l_cpg_reset,
+	.assert = rzg2l_cpg_assert,
+	.deassert = rzg2l_cpg_deassert,
+	.status = rzg2l_cpg_status,
+};
+
+static int rzg2l_cpg_reset_xlate(struct reset_controller_dev *rcdev,
+				const struct of_phandle_args *reset_spec)
+{
+	unsigned int id = reset_spec->args[0];
+
+	if (id >= rcdev->nr_resets) {
+		dev_err(rcdev->dev, "Invalid reset index %u\n", id);
+		return -EINVAL;
+	}
+
+	return id;
+}
+
+static int rzg2l_cpg_reset_controller_register(struct cpg_mssr_priv *priv)
+{
+	priv->rcdev.ops = &rzg2l_cpg_reset_ops;
+	priv->rcdev.of_node = priv->dev->of_node;
+	priv->rcdev.dev = priv->dev;
+	priv->rcdev.of_reset_n_cells = 1;
+	priv->rcdev.of_xlate = rzg2l_cpg_reset_xlate;
+	priv->rcdev.nr_resets = priv->num_mod_clks;
+
+	return devm_reset_controller_register(priv->dev, &priv->rcdev);
+}
+
+#else /* !CONFIG_RESET_CONTROLLER */
+static int rzg2l_cpg_reset_controller_register(struct cpg_mssr_priv *priv)
+{
+	return 0;
+}
+#endif /* !CONFIG_RESET_CONTROLLER */
+
+static bool rzg2l_cpg_is_pm_clk(const struct of_phandle_args *clkspec)
+{
+	if (clkspec->args_count != 2)
+		return false;
+
+	switch (clkspec->args[0]) {
+	case CPG_MOD:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+int rzg2l_cpg_attach_dev(struct generic_pm_domain *unused, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct of_phandle_args clkspec;
+	struct clk *clk;
+	int i = 0;
+	int error;
+
+	while (!of_parse_phandle_with_args(np, "clocks", "#clock-cells", i,
+					   &clkspec)) {
+		if (rzg2l_cpg_is_pm_clk(&clkspec))
+			goto found;
+
+		of_node_put(clkspec.np);
+		i++;
+	}
+
+	return 0;
+
+found:
+	clk = of_clk_get_from_provider(&clkspec);
+	of_node_put(clkspec.np);
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	error = pm_clk_create(dev);
+	if (error)
+		goto fail_put;
+
+	error = pm_clk_add_clk(dev, clk);
+	if (error)
+		goto fail_destroy;
+
+	return 0;
+
+fail_destroy:
+	pm_clk_destroy(dev);
+fail_put:
+	clk_put(clk);
+	return error;
+}
+
+void rzg2l_cpg_detach_dev(struct generic_pm_domain *unused, struct device *dev)
+{
+	if (!pm_clk_no_clocks(dev))
+		pm_clk_destroy(dev);
+}
+
+static int __init rzg2l_cpg_add_clk_domain(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct generic_pm_domain *genpd;
+
+	genpd = devm_kzalloc(dev, sizeof(*genpd), GFP_KERNEL);
+	if (!genpd)
+		return -ENOMEM;
+
+	genpd->name = np->name;
+	genpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ALWAYS_ON |
+		       GENPD_FLAG_ACTIVE_WAKEUP;
+	genpd->attach_dev = rzg2l_cpg_attach_dev;
+	genpd->detach_dev = rzg2l_cpg_detach_dev;
+	pm_genpd_init(genpd, &pm_domain_always_on_gov, false);
+
+	of_genpd_add_provider_simple(np, genpd);
+	return 0;
+}
+
+static int __init rzg2l_cpg_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	const struct cpg_mssr_info *info;
+	struct cpg_mssr_priv *priv;
+	unsigned int nclks, i;
+	struct resource *res;
+	struct clk **clks;
+	int error;
+
+	info = of_device_get_match_data(dev);
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	priv->info = info;
+	spin_lock_init(&priv->rmw_lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	nclks = info->num_total_core_clks + info->num_hw_mod_clks;
+	clks = devm_kmalloc_array(dev, nclks, sizeof(*clks), GFP_KERNEL);
+	if (!clks)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, priv);
+	priv->clks = clks;
+	priv->num_core_clks = info->num_total_core_clks;
+	priv->num_mod_clks = info->num_hw_mod_clks;
+	priv->last_dt_core_clk = info->last_dt_core_clk;
+
+	for (i = 0; i < nclks; i++)
+		clks[i] = ERR_PTR(-ENOENT);
+
+	for (i = 0; i < info->num_core_clks; i++)
+		rzg2l_cpg_register_core_clk(&info->core_clks[i], info, priv);
+
+	for (i = 0; i < info->num_mod_clks; i++)
+		rzg2l_cpg_register_mod_clk(&info->mod_clks[i], info, priv);
+
+	error = of_clk_add_provider(np, rzg2l_cpg_clk_src_twocell_get, priv);
+	if (error)
+		return error;
+
+	error = devm_add_action_or_reset(dev,
+					 rzg2l_cpg_del_clk_provider,
+					 np);
+	if (error)
+		return error;
+
+	error = rzg2l_cpg_add_clk_domain(dev);
+	if (error)
+		return error;
+
+	error = rzg2l_cpg_reset_controller_register(priv);
+	if (error)
+		return error;
+	{
+
+		/*
+		 * Workaround: For all IPs that can use generic DMAC,
+		 * interrupt signals come to CA55 via DMAC. This Workaround
+		 * enable DMAC clock, required while DMAC was not available yet.
+		 */
+
+		writel(0x00030003, priv->base + 0x082C);
+		udelay(10);
+		writel(0x00030003, priv->base + 0x052C);
+	}
+
+	return 0;
+}
+
+static struct platform_driver rzg2l_cpg_driver = {
+	.driver		= {
+		.name	= "rzg2l-cpg",
+		.of_match_table = rzg2l_cpg_match,
+	},
+};
+
+static int __init rzg2l_cpg_init(void)
+{
+	return platform_driver_probe(&rzg2l_cpg_driver, rzg2l_cpg_probe);
+}
+
+subsys_initcall(rzg2l_cpg_init);
diff --git a/drivers/clk/renesas/renesas-rzg2l-cpg.h b/drivers/clk/renesas/renesas-rzg2l-cpg.h
new file mode 100644
index 0000000..66a96ed
--- /dev/null
+++ b/drivers/clk/renesas/renesas-rzg2l-cpg.h
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RZG2L Clock Pulse Generator
+ *
+ * Copyright (C) 2020 Renesas Electronics Corp.
+ *
+ */
+
+#ifndef __RENESAS_RZG2L_CPG_H__
+#define __RENESAS_RZG2L_CPG_H__
+
+/*Register offset*/
+/*n : 0, 1, 2 : PLL1, PLL4, PLL6*/
+#define PLL146_CLK1_R(n)	(0x04 + (16 * n))
+#define PLL146_CLK2_R(n)	(0x08 + (16 * n))
+#define PLL146_MON_R(n)		(0x0C + (16 * n))
+#define PLL146_STBY_R(n)	(0x00 + (16 * n))
+/*n : 0, 1, 2 : PLL2, PLL3, PLL5*/
+#define PLL235_CLK1_R(n)	(0x104 + (32 * n))
+#define PLL235_CLK3_R(n)	(0x10c + (32 * n))
+#define PLL235_CLK4_R(n)	(0x110 + (32 * n))
+#define PLL235_MON_R(n)		(0x11C + (32 * n))
+#define PLL235_STBY_R(n)	(0x100 + (32 * n))
+/*offset(32->16):shift(15->8):mask(7->0)*/
+#define PLL1_DIV_R		(0x200)
+#define PLL2_DIV_R		(0x204)
+#define PLL3A_DIV_R		(0x208)
+#define PLL3B_DIV_R		(0x20c)
+#define PLL6_DIV_R		(0x210)
+#define PL2SDHI_SEL_R		(0x218)
+#define CLK_STATUS_R		(0x280)
+#define CA55_SSEL_R		(0x400)
+#define PL2_SSEL_R		(0x404)
+#define PL3_SSEL_R		(0x408)
+#define PL4_DSEL_R		(0x21C)
+#define PL5_SSEL_R		(0x410)
+#define PL6_SSEL_R		(0x414)
+#define PL6_ETH_SSEL_R		(0x418)
+#define PL5_SDIV_R		(0x420)
+#define OTHERFUNC1_R		(0xBE8)
+#define CLK_ON_R(reg)		(0x500 + reg)
+#define CLK_MON_R(reg)		(0x680 + reg)
+#define CLK_RST_R(reg)		(0x800 + reg)
+#define CLK_MRST_R(reg)		(0x980 + reg)
+
+/*12bits register offset, 8bits shifter, 4bits width, 8bits reserved*/
+#define SEL_PLL1	(CA55_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL2_1	(PL2_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL2_2	(PL2_SSEL_R << 20	| 4 << 12	| 1 << 8)
+#define SEL_PLL3_1	(PL3_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL3_2	(PL3_SSEL_R << 20	| 4 << 12	| 1 << 8)
+#define SEL_PLL3_3	(PL3_SSEL_R << 20	| 8 << 12	| 1 << 8)
+#define SEL_PLL4	(PL4_DSEL_R << 20	| 8 << 12	| 1 << 8)
+#define SEL_PLL5_1	(PL5_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL5_2	(PL5_SSEL_R << 20	| 4 << 12	| 1 << 8)
+#define SEL_PLL5_3	(PL5_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL5_4	(OTHERFUNC1_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL6_1	(PL6_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_PLL6_2	(PL6_ETH_SSEL_R << 20	| 0 << 12	| 1 << 8)
+#define SEL_ETH		(PL6_ETH_SSEL_R << 20	| 4 << 12	| 1 << 8)
+#define SEL_G1_1	(PL6_SSEL_R << 20	| 4 << 12	| 1 << 8)
+#define SEL_G1_2	(PL6_SSEL_R << 20	| 8 << 12	| 1 << 8)
+#define SEL_G2		(PL6_SSEL_R << 20	| 12 << 12	| 1 << 8)
+#define SEL_SDHI0	(PL2SDHI_SEL_R << 20	| 0 << 12	| 2 << 8)
+#define SEL_SDHI1	(PL2SDHI_SEL_R << 20	| 4 << 12	| 2 << 8)
+#define DIVPL1		(PLL1_DIV_R << 20	| 0 << 12	| 2 << 8)
+#define DIVPL2A		(PLL2_DIV_R << 20	| 0 << 12	| 3 << 8)
+#define DIVPL2B		(PLL2_DIV_R << 20	| 4 << 12	| 3 << 8)
+#define DIVPL2C		(PLL2_DIV_R << 20	| 8 << 12	| 3 << 8)
+#define DIVDSILPCL	(PLL2_DIV_R << 20	| 12 << 12	| 2 << 8)
+#define DIVPL3A		(PLL3A_DIV_R << 20	| 0 << 12	| 3 << 8)
+#define DIVPL3B		(PLL3A_DIV_R << 20	| 4 << 12	| 3 << 8)
+#define DIVPL3C		(PLL3A_DIV_R << 20	| 8 << 12	| 3 << 8)
+#define DIVPL3CLK200FIX	(PLL3B_DIV_R << 20	| 0 << 12	| 3 << 8)
+#define DIVGPU		(PLL6_DIV_R << 20	| 0 << 12	| 2 << 8)
+#define DIVDSIB		(PL5_SDIV_R << 20	| 8 << 12	| 4 << 8)
+#define DIVDSIA		(PL5_SDIV_R << 20	| 0 << 12	| 2 << 8)
+
+/*12 bits register offset, 4 bits EN/LOCK bit shifter
+ *4 bits for Reset bit shifter
+ */
+#define PLL146_STBY(n)	(PLL146_STBY_R(n) << 20 | 2 << 16  | 0 << 12)
+#define PLL146_MON(n)	(PLL146_MON_R(n) << 20  | 4 << 16  | 0 << 12)
+#define PLL235_STBY(n)	(PLL235_STBY_R(n) << 20 | 2 << 16  | 0 << 12)
+#define PLL235_MON(n)	(PLL235_MON_R(n) << 20  | 4 << 16  | 0 << 12)
+
+#define PLL_REG(val)		((val >> 20) & 0xfff)
+#define PLL_EN(val)		BIT(((val >> 16) & 0xf))
+#define PLL_RES(val)		BIT(((val >> 12) & 0xf))
+
+/*10 bits register offset1, 10 bits register offset2
+ *10 bits register offset3
+ */
+#define PLL146_CONF(n)	(PLL146_CLK1_R(n) << 22 \
+			| PLL146_CLK2_R(n) << 12 \
+			| 0)
+#define PLL235_CONF(n)	(PLL235_CLK1_R(n) << 22 \
+			| PLL235_CLK3_R(n) << 12 \
+			| PLL235_CLK4_R(n))
+
+#define GET_REG1(val)	((val >> 22) & 0x3ff)
+#define GET_REG2(val)	((val >> 12) & 0x3ff)
+#define GET_REG3(val)	(val & 0x3ff)
+
+/*16bits register offset, 8bits ON/MON, 8bits RESET*/
+#define MSSR(off, on, res)	((off & 0xffff) << 16	\
+				| (on & 0xff) << 8	\
+				| (res & 0xff))
+#define MSSR_OFF(val)		((val >> 16) & 0xffff)
+#define MSSR_ON(val)		((val >> 8) & 0xff)
+#define MSSR_RES(val)		(val & 0xff)
+
+/*
+ * Definitions of CPG Core Clocks
+ *
+ * These include:
+ *   - Clock outputs exported to DT
+ *   - External input clocks
+ *   - Internal CPG clocks
+ */
+
+struct cpg_core_clk {
+	/* Common */
+	const char *name;
+	unsigned int id;
+	unsigned int parent;
+	unsigned int div;
+	unsigned int mult;
+	unsigned int type;
+	unsigned int conf;
+	struct clk_div_table *dtable;
+	int flag;
+	char const **parent_names;
+	int num_parents;
+	/*used for clocks have two config info*/
+	unsigned int confs;
+	struct clk_div_table *dtables;
+	/*used for clocks have two config info*/
+	unsigned int stby_conf;
+	unsigned int mon_conf;
+};
+
+enum clk_types {
+	/* Generic */
+	CLK_TYPE_IN,		/* External Clock Input */
+	CLK_TYPE_FF,		/* Fixed Factor Clock */
+	CLK_TYPE_SAM_PLL,
+	CLK_TYPE_SI_PLL,
+
+	/*Clock have divider*/
+	CLK_TYPE_DIV,
+	CLK_TYPE_2DIV,
+
+	/*Clock have selector*/
+	CLK_TYPE_MUX,
+
+	/* Custom definitions start here */
+	CLK_TYPE_CUSTOM,
+};
+
+#define DEF_TYPE(_name, _id, _type...) \
+	{ .name = _name, .id = _id, .type = _type }
+#define DEF_BASE(_name, _id, _type, _parent...) \
+	DEF_TYPE(_name, _id, _type, .parent = _parent)
+#define DEF_PLL(_name, _id, _type, _parent, _conf, _stby_conf, _mon_conf) \
+	DEF_TYPE(_name, _id, _type, .parent = _parent, .conf = _conf, \
+		.stby_conf = _stby_conf, .mon_conf = _mon_conf)
+#define DEF_INPUT(_name, _id) \
+	DEF_TYPE(_name, _id, CLK_TYPE_IN)
+#define DEF_FIXED(_name, _id, _parent, _mult, _div) \
+	DEF_BASE(_name, _id, CLK_TYPE_FF, _parent, .div = _div, .mult = _mult)
+#define DEF_DIV(_name, _id, _parent, _conf, _dtable, _flag) \
+	DEF_TYPE(_name, _id, CLK_TYPE_DIV, .conf = _conf, \
+		.parent = _parent, .dtable = _dtable, .flag = _flag)
+#define DEF_MUX(_name, _id, _conf, _parent_names, _num_parents, _flag) \
+	DEF_TYPE(_name, _id, CLK_TYPE_MUX, .conf = _conf, \
+		.parent_names = _parent_names, \
+		.num_parents = _num_parents, .flag = _flag)
+/*Clock have two dividors */
+#define DEF_2DIV(_name, _id, _parent, _conf, _confs, _dtable, _dtables, _flag) \
+	DEF_TYPE(_name, _id, CLK_TYPE_2DIV, .parent = _parent, \
+		.conf = _conf, .confs = _confs, \
+		.dtable = _dtable, .dtables = _dtables, .flag = _flag)
+
+/*
+ * Definitions of Module Clocks
+ * @name: handle between common and hardware-specific interfaces
+ * @id: clock index in array containing all Core and Module Clocks
+ * @parent: id of parent clock
+ * @offset: CLK_ON/MON register offset
+ * @bit: 16bits register offset, 8bits ON/MON, 8bits RESET
+ */
+
+struct mssr_mod_clk {
+	const char *name;
+	unsigned int id;
+	unsigned int parent;
+	unsigned int bit;
+};
+
+#define DEF_MOD(_name, _id, _parent, _bit)	\
+	{ .name = _name, .id = CLK_MODE_BASE + _id, .parent = _parent,\
+	.bit = _bit }
+
+struct device_node;
+
+/*
+ * PLL register info
+ * @type: PLL Clock type
+ * @reg1: PLL register offset 1
+ * @reg2: PLL register offset 2
+ * @reg3: PLL register offset 3
+ */
+struct cpg_pll_info {
+	unsigned int type;
+	unsigned int reg1;
+	unsigned int reg2;
+	unsigned int reg3;
+};
+
+/**
+ * SoC-specific CPG/MSSR Description
+ *
+ * @core_clks: Array of Core Clock definitions
+ * @num_core_clks: Number of entries in core_clks[]
+ * @last_dt_core_clk: ID of the last Core Clock exported to DT
+ * @num_total_core_clks: Total number of Core Clocks (exported + internal)
+ *
+ * @pll_info: array of PLL register info
+ * @pll_info_size: Total number of PLL registers info
+ *
+ * @mod_clks: Array of Module Clock definitions
+ * @num_mod_clks: Number of entries in mod_clks[]
+ * @num_hw_mod_clks: Number of Module Clocks supported by the hardware
+ *
+ * @crit_mod_clks: Array with Module Clock IDs of critical clocks that
+ *                 should not be disabled without a knowledgeable driver
+ * @num_crit_mod_clks: Number of entries in crit_mod_clks[]
+ */
+
+struct cpg_mssr_info {
+	/* Core Clocks */
+	const struct cpg_core_clk *core_clks;
+	unsigned int num_core_clks;
+	unsigned int last_dt_core_clk;
+	unsigned int num_total_core_clks;
+
+	/* PLL register info*/
+	const struct cpg_pll_info *pll_info;
+	unsigned int pll_info_size;
+
+	/* Module Clocks */
+	const struct mssr_mod_clk *mod_clks;
+	unsigned int num_mod_clks;
+	unsigned int num_hw_mod_clks;
+	struct cpg_sel_div_table *div_table;
+	struct cpg_sel_div_table *sel_table;
+
+	/* Critical Module Clocks that should not be disabled */
+	const unsigned int *crit_mod_clks;
+	unsigned int num_crit_mod_clks;
+};
+
+extern const struct cpg_mssr_info r9a07g044l_cpg_info;
+#endif
diff --git a/include/dt-bindings/clock/r9a07g044l-cpg.h b/include/dt-bindings/clock/r9a07g044l-cpg.h
new file mode 100644
index 0000000..2d3b1b1
--- /dev/null
+++ b/include/dt-bindings/clock/r9a07g044l-cpg.h
@@ -0,0 +1,90 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2020 Renesas Electronics Corp.
+ */
+#ifndef __DT_BINDINGS_CLOCK_R9A07G044L_CPG_MSSR_H__
+#define __DT_BINDINGS_CLOCK_R9A07G044L_CPG_MSSR_H__
+
+#include <dt-bindings/clock/renesas-cpg-mssr.h>
+
+/* r9a07g044l CPG Core Clocks */
+#define R9A07G044L_CLK_I		0
+#define R9A07G044L_CLK_I2		1
+#define R9A07G044L_CLK_G		2
+#define R9A07G044L_CLK_S0		3
+#define R9A07G044L_CLK_S1		4
+#define R9A07G044L_CLK_SPI0		5
+#define R9A07G044L_CLK_SPI1		6
+#define R9A07G044L_CLK_SD0		7
+#define R9A07G044L_CLK_SD1		8
+#define R9A07G044L_CLK_M0		9
+#define R9A07G044L_CLK_M1		10
+#define R9A07G044L_CLK_M2		11
+#define R9A07G044L_CLK_M3		12
+#define R9A07G044L_CLK_M4		13
+#define R9A07G044L_CLK_HP		14
+#define R9A07G044L_CLK_TSU		15
+#define R9A07G044L_CLK_ZT		16
+#define R9A07G044L_CLK_P0		17
+#define R9A07G044L_CLK_P1		18
+#define R9A07G044L_CLK_P2		19
+#define R9A07G044L_CLK_AT		20
+#define R9A07G044L_OSCCLK		21
+
+/* r9a07g044l Module Clocks */
+
+#define R9A07G044L_CLK_GIC600		0
+#define R9A07G044L_CLK_IA55		1
+#define R9A07G044L_CLK_SYC		2
+#define R9A07G044L_CLK_DMAC		3
+#define R9A07G044L_CLK_SYSC		4
+#define R9A07G044L_CLK_MTU		5
+#define R9A07G044L_CLK_GPT		6
+#define R9A07G044L_CLK_ETH0		7
+#define R9A07G044L_CLK_ETH1		8
+#define R9A07G044L_CLK_I2C0		9
+#define R9A07G044L_CLK_I2C1		10
+#define R9A07G044L_CLK_I2C2		11
+#define R9A07G044L_CLK_I2C3		12
+#define R9A07G044L_CLK_SCIF0		13
+#define R9A07G044L_CLK_SCIF1		14
+#define R9A07G044L_CLK_SCIF2		15
+#define R9A07G044L_CLK_SCIF3		16
+#define R9A07G044L_CLK_SCIF4		17
+#define R9A07G044L_CLK_SCI0		18
+#define R9A07G044L_CLK_SCI1		19
+#define R9A07G044L_CLK_GPIO		20
+#define R9A07G044L_CLK_SDHI0		21
+#define R9A07G044L_CLK_SDHI1		22
+#define R9A07G044L_CLK_USB0		23
+#define R9A07G044L_CLK_USB1		24
+#define R9A07G044L_CLK_CANFD		25
+#define R9A07G044L_CLK_SSI0		26
+#define R9A07G044L_CLK_SSI1		27
+#define R9A07G044L_CLK_SSI2		28
+#define R9A07G044L_CLK_SSI3		29
+#define R9A07G044L_CLK_MHU		30
+#define R9A07G044L_CLK_OSTM0		31
+#define R9A07G044L_CLK_OSTM1		32
+#define R9A07G044L_CLK_OSTM2		33
+#define R9A07G044L_CLK_WDT0		34
+#define R9A07G044L_CLK_WDT1		35
+#define R9A07G044L_CLK_WDT2		36
+#define R9A07G044L_CLK_WDT_PON		37
+#define R9A07G044L_CLK_GPU		38
+#define R9A07G044L_CLK_ISU		39
+#define R9A07G044L_CLK_H264		40
+#define R9A07G044L_CLK_CRU		41
+#define R9A07G044L_CLK_MIPI_DSI		42
+#define R9A07G044L_CLK_LCDC		43
+#define R9A07G044L_CLK_SRC		44
+#define R9A07G044L_CLK_RSPI0		45
+#define R9A07G044L_CLK_RSPI1		46
+#define R9A07G044L_CLK_RSPI2		47
+#define R9A07G044L_CLK_ADC		48
+#define R9A07G044L_CLK_TSU_PCLK		49
+#define R9A07G044L_CLK_SPI		50
+#define R9A07G044L_CLK_MIPI_DSI_V	51
+#define R9A07G044L_CLK_MIPI_DSI_PIN	52
+
+#endif /* __DT_BINDINGS_CLOCK_R9A07G044L_CPG_H__ */
-- 
2.7.4


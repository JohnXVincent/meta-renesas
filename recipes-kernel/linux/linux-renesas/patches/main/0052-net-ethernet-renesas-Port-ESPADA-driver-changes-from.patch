From 9819f181101fe81e8a691440f7d3ac91d344101b Mon Sep 17 00:00:00 2001
From: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
Date: Mon, 8 Feb 2021 11:18:40 +0000
Subject: [PATCH 052/135] net: ethernet: renesas: Port ESPADA driver changes
 from Redmine #291007

Signed-off-by: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
---
 drivers/net/ethernet/renesas/Kconfig              |    6 +
 drivers/net/ethernet/renesas/Makefile             |    2 +
 drivers/net/ethernet/renesas/espada_gnetsetting.c |  591 ++++++++++++
 drivers/net/ethernet/renesas/espada_gnetsetting.h |  224 +++++
 drivers/net/ethernet/renesas/ravb.h               |   13 +-
 drivers/net/ethernet/renesas/ravb_main.c          | 1002 ++++++++++-----------
 6 files changed, 1289 insertions(+), 549 deletions(-)
 create mode 100644 drivers/net/ethernet/renesas/espada_gnetsetting.c
 create mode 100644 drivers/net/ethernet/renesas/espada_gnetsetting.h

diff --git a/drivers/net/ethernet/renesas/Kconfig b/drivers/net/ethernet/renesas/Kconfig
index ed4afb0..1524cec 100644
--- a/drivers/net/ethernet/renesas/Kconfig
+++ b/drivers/net/ethernet/renesas/Kconfig
@@ -50,4 +50,10 @@ config RAVB
 	  This driver supports the following SoCs:
 		- R8A779x.
 
+config GNETSETTING
+	tristate "Renesas Ethernet Sysfs support"
+	select ARCH_ESPADA
+	help
+	  Renesas Ethernet Sysfs device driver.
+
 endif # NET_VENDOR_RENESAS
diff --git a/drivers/net/ethernet/renesas/Makefile b/drivers/net/ethernet/renesas/Makefile
index f21ab8c..b767fb8 100644
--- a/drivers/net/ethernet/renesas/Makefile
+++ b/drivers/net/ethernet/renesas/Makefile
@@ -8,3 +8,5 @@ obj-$(CONFIG_SH_ETH) += sh_eth.o
 ravb-objs := ravb_main.o ravb_ptp.o
 
 obj-$(CONFIG_RAVB) += ravb.o
+
+obj-$(CONFIG_GNETSETTING) += espada_gnetsetting.o
diff --git a/drivers/net/ethernet/renesas/espada_gnetsetting.c b/drivers/net/ethernet/renesas/espada_gnetsetting.c
new file mode 100644
index 0000000..686144b
--- /dev/null
+++ b/drivers/net/ethernet/renesas/espada_gnetsetting.c
@@ -0,0 +1,591 @@
+/* Renesas Standby response extension setting module driver
+ *
+ * Copyright (C) 2017 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License version 2,
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <linux/bitops.h>
+
+#include "espada_gnetsetting.h"
+
+#define ESPADA_GNETSETTING_DRV_NAME "etheravb-espada"
+
+#define ESPADA_GNETSETTING_MAX_DATA_SIZE 1500
+#define ESPADA_GNETSETTING_MAX_DATA_SIZE_INT (ESPADA_GNETSETTING_MAX_DATA_SIZE \
+								/ sizeof(u32))
+#define ESPADA_GNETSETTING_BIT_SIZE 32
+#define ESPADA_GNETSETTING_MAX_REG 512
+
+#define _ESPADA_GNETSETTING_BYTE1(x) (x         & 0xFF)
+#define _ESPADA_GNETSETTING_BYTE2(x) ((x >>  8) & 0xFF)
+#define _ESPADA_GNETSETTING_BYTE3(x) ((x >> 16) & 0xFF)
+#define _ESPADA_GNETSETTING_BYTE4(x) ((x >> 24) & 0xFF)
+
+#define ESPADA_GNETSETTING_BYTE_SWAP_32(x) \
+	((uint32_t)(_ESPADA_GNETSETTING_BYTE1(x)<<24 | \
+		    _ESPADA_GNETSETTING_BYTE2(x)<<16 | \
+		    _ESPADA_GNETSETTING_BYTE3(x)<<8 | \
+		    _ESPADA_GNETSETTING_BYTE4(x)))
+
+#define	ESPADA_GNETSETTING_BIT_GET_F(nr, f) ((f[nr] - f[0]) / sizeof(u32))
+
+struct espada_gnetsetting_data {
+	void __iomem *baseaddr;
+	const u32 *reglist;
+	unsigned int reglistsize;
+	unsigned int offset;
+	DECLARE_BITMAP(chkreglist, ESPADA_GNETSETTING_MAX_REG);
+	u32 bit_ptn[10];
+	unsigned int addr;
+	unsigned int size;
+	unsigned int datacnt;
+	unsigned int data[ESPADA_GNETSETTING_MAX_DATA_SIZE_INT];
+};
+
+struct espada_gnetsetting_periodicalsending_data {
+	void __iomem *baseaddr;
+	unsigned long time;
+	unsigned int size;
+	unsigned int data[ESPADA_GNETSETTING_MAX_DATA_SIZE_INT];
+};
+
+struct espada_gnetsetting_device {
+	struct espada_gnetsetting_data	filtering;
+	struct espada_gnetsetting_data	autoresponse;
+	struct espada_gnetsetting_periodicalsending_data periodicalsending;
+};
+
+static struct espada_gnetsetting_device *gnetsetting_device;
+
+static struct class *espada_class;
+static struct device *gnetsetting_dev;
+
+static int espada_gnetsetting_get_data(const char **buf,
+				       struct espada_gnetsetting_data *data)
+{
+	char		*strvalue;
+	unsigned int	offset;
+	unsigned int	size;
+	unsigned long	value;
+	unsigned int	datacnt;
+	unsigned int	storedata[ESPADA_GNETSETTING_MAX_DATA_SIZE_INT];
+	int ret;
+
+	data->addr = 0;
+	data->size = 0;
+	data->datacnt = 0;
+
+	/* Obtain offset address */
+	strvalue = strsep((char **)buf, ",");
+	if (!strvalue)
+		return -EINVAL;
+
+	ret = kstrtoul(strvalue, 16, &value);
+	if (ret)
+		return ret;
+	offset = value;
+
+	/* Obtain size */
+	strvalue = strsep((char **)buf, ",");
+	if (!strvalue)
+		return -EINVAL;
+
+	ret = kstrtoul(strvalue, 10, &value);
+	if (ret)
+		return ret;
+
+	size = value;
+
+	if ((offset % sizeof(u32) != 0)
+	 || (size % sizeof(u32) != 0) || (size == 0))
+		return -EINVAL;
+
+	datacnt = 0;
+	while ((strvalue = strsep((char **)buf, ",")) != NULL) {
+		ret = kstrtoul(strvalue, 16, &value);
+		if (ret)
+			return ret;
+
+		storedata[datacnt] = value;
+
+		datacnt++;
+	}
+	if (datacnt != 0) {
+		if ((size / sizeof(u32)) != datacnt)
+			return -EINVAL;
+
+		memcpy(data->data, storedata, size);
+	}
+
+	data->addr = offset;
+	data->size = size;
+	data->datacnt = datacnt;
+
+	return 0;
+}
+
+static void espada_gnetsetting_set_chkreglist(
+			struct espada_gnetsetting_data *data)
+{
+	int i;
+
+	bitmap_zero(data->chkreglist, ESPADA_GNETSETTING_MAX_REG);
+
+	for (i = 0; i < data->reglistsize; i++)
+		set_bit(((data->reglist[i] - data->offset) / sizeof(u32)),
+							data->chkreglist);
+}
+
+static bool espada_gnetsetting_chk_reg(
+				struct espada_gnetsetting_data *data,
+				u32 reg)
+{
+	bool ret;
+
+	if (test_bit((reg - data->offset) / sizeof(u32), data->chkreglist))
+		ret = true;
+	else
+		ret = false;
+
+	return ret;
+}
+
+static int espada_gnetsetting_write_data(struct espada_gnetsetting_data *data)
+{
+	int i;
+
+	/* range check */
+	if ((data->reglist[0] > data->addr)
+	 || (data->reglist[data->reglistsize - 1] + 4
+	     < (data->addr + data->size))) {
+		return -EINVAL;
+	}
+
+	/* write register */
+	/* Skip addresses that do not exist in the register list. */
+	for (i = 0; i < data->size; i += sizeof(u32)) {
+		if (espada_gnetsetting_chk_reg(data, data->addr+i)) {
+			espada_gnetsetting_write(data->baseaddr,
+						 data->data[i/sizeof(u32)],
+						 data->addr+i);
+		}
+	}
+
+	return 0;
+}
+
+static int espada_gnetsetting_read_data(struct espada_gnetsetting_data *data)
+{
+	int i;
+
+	/* range check */
+	if ((data->reglist[0] > data->addr)
+	 || (data->reglist[data->reglistsize - 1] + 4
+	     < (data->addr + data->size))) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < data->size; i += sizeof(u32)) {
+		if (espada_gnetsetting_chk_reg(data, data->addr + i))
+			data->data[i/sizeof(u32)]
+				= espada_gnetsetting_read(data->baseaddr,
+							  data->addr+i);
+		else
+			data->data[i/sizeof(u32)] = 0;
+	}
+
+	return 0;
+}
+
+static ssize_t espada_gnetsetting_show_data(
+	struct espada_gnetsetting_data *data, char *buf)
+{
+	int i;
+	char *cp;
+
+	cp = buf;
+	for (i = 0; i < data->size; i += sizeof(u32)) {
+		cp += snprintf(cp,
+			       PAGE_SIZE - (cp - buf),
+			       "%8x,",
+			       data->data[i/sizeof(u32)]);
+	}
+	cp--;
+	cp += snprintf(cp, PAGE_SIZE - (cp - buf), "\n");
+	return cp - buf;
+}
+
+static ssize_t espada_gnetsetting_filtering_show(struct kobject *kobj,
+						 struct kobj_attribute *attr,
+						 char *buf)
+{
+	int ret;
+
+	ret = espada_gnetsetting_read_data(&(gnetsetting_device->filtering));
+	if (ret)
+		return ret;
+
+	return espada_gnetsetting_show_data(&(gnetsetting_device->filtering),
+					    buf);
+}
+
+static ssize_t espada_gnetsetting_filtering_store(struct kobject *kobj,
+						  struct kobj_attribute *attr,
+						  const char *buf,
+						  size_t count)
+{
+	int ret;
+
+	ret = espada_gnetsetting_get_data(&buf,
+		&gnetsetting_device->filtering);
+	if (ret)
+		return ret;
+	gnetsetting_device->filtering.addr
+		+= gnetsetting_device->filtering.offset;
+
+	if (gnetsetting_device->filtering.datacnt != 0) {
+		ret = espada_gnetsetting_write_data(
+			&(gnetsetting_device->filtering));
+		if (ret)
+			return ret;
+	}
+
+	return count;
+}
+
+static ssize_t espada_gnetsetting_autoresponse_show(struct kobject *kobj,
+						    struct kobj_attribute *attr,
+						    char *buf)
+{
+	int ret;
+
+	ret = espada_gnetsetting_read_data(
+		&(gnetsetting_device->autoresponse));
+	if (ret)
+		return ret;
+
+	return espada_gnetsetting_show_data(
+		&(gnetsetting_device->autoresponse), buf);
+}
+
+static ssize_t espada_gnetsetting_autoresponse_store(
+					struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf,
+					size_t count)
+{
+	int ret;
+
+	ret = espada_gnetsetting_get_data(&buf,
+		&gnetsetting_device->autoresponse);
+	if (ret)
+		return ret;
+
+	gnetsetting_device->autoresponse.addr
+		+= gnetsetting_device->autoresponse.offset;
+
+	if (gnetsetting_device->autoresponse.datacnt != 0) {
+		ret = espada_gnetsetting_write_data(
+			&(gnetsetting_device->autoresponse));
+		if (ret)
+			return ret;
+	}
+
+	return count;
+}
+
+static ssize_t espada_gnetsetting_periodicalsending_show(
+						struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int i;
+	char *cp;
+	struct espada_gnetsetting_periodicalsending_data *data
+		= &(gnetsetting_device->periodicalsending);
+
+	cp = buf;
+	cp += snprintf(cp, PAGE_SIZE - (cp - buf), "%ld,", data->time);
+	cp += snprintf(cp, PAGE_SIZE - (cp - buf), "%4d,", data->size);
+
+	if (data->size != 0) {
+		for (i = 0; i < data->size; i += sizeof(u32))
+			cp += snprintf(cp,
+				      PAGE_SIZE - (cp - buf),
+				      "%8X,", data->data[i/sizeof(u32)]);
+	}
+	cp--;
+	cp += snprintf(cp, PAGE_SIZE - (cp - buf), "\n");
+	return cp-buf;
+}
+
+static ssize_t espada_gnetsetting_periodicalsending_store(
+						struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf,
+						size_t count)
+{
+
+	char		*strvalue;
+	unsigned long	time;
+	unsigned int	size;
+	unsigned long	value;
+	unsigned int	datacnt;
+	unsigned int	cnt;
+	unsigned int	storedata[ESPADA_GNETSETTING_MAX_DATA_SIZE_INT];
+	int ret;
+	struct espada_gnetsetting_periodicalsending_data *data
+		= &(gnetsetting_device->periodicalsending);
+
+	strvalue = strsep((char **)&buf, ",");
+	if (!strvalue)
+		return -EINVAL;
+
+	ret = kstrtoul(strvalue, 10, &value);
+	if (ret)
+		return ret;
+
+	time = value;
+
+	if (time == 0) {
+		data->time = 0;
+		data->size = 0;
+		return count;
+	}
+
+	strvalue = strsep((char **)&buf, ",");
+	if (!strvalue)
+		return -EINVAL;
+
+	ret = kstrtoul(strvalue, 10, &value);
+	if (ret)
+		return ret;
+
+	size = value;
+	if ((size == 0)
+	 || (size > ESPADA_GNETSETTING_MAX_DATA_SIZE))
+		return -EINVAL;
+
+	/* Obtain data */
+	datacnt = 0;
+	cnt = 0;
+	while ((strvalue = strsep((char **)&buf, ",")) != NULL) {
+		ret = kstrtoul(strvalue, 16, &value);
+		if (ret)
+			return ret;
+
+		storedata[cnt] = value;
+		cnt++;
+		datacnt += strlen(strvalue);
+	}
+
+	if (size != ((datacnt - 1) / 2))
+		return -EINVAL;
+
+	data->time = time;
+	data->size = size;
+	memcpy(data->data, storedata, size);
+
+	return count;
+}
+
+void espada_gnetsetting_set_gberam(void)
+{
+	int i;
+
+	struct espada_gnetsetting_periodicalsending_data *data
+		= &(gnetsetting_device->periodicalsending);
+
+	/* GbE RAM Write */
+	espada_gnetsetting_write(data->baseaddr, data->time, GBE_RAM_TIME);
+	espada_gnetsetting_write(data->baseaddr, data->size, GBE_RAM_SIZE);
+
+	for (i = 0; i < ((data->size / sizeof(u32))
+		+ ((data->size % sizeof(u32) ? 1 : 0))); i++)
+		espada_gnetsetting_write(
+			data->baseaddr,
+			ESPADA_GNETSETTING_BYTE_SWAP_32(data->data[i] <<
+				(((i + 1) * sizeof(u32) > data->size)
+				? (sizeof(u32) - (data->size % sizeof(u32))) * 8
+				: 0)),
+			GBE_RAM_SEND_DATA + (i * sizeof(u32)));
+}
+EXPORT_SYMBOL_GPL(espada_gnetsetting_set_gberam);
+
+void espada_gnetsetting_set_gberam_suspend(unsigned int data)
+{
+	struct espada_gnetsetting_periodicalsending_data *periodicalsending_data
+		= &(gnetsetting_device->periodicalsending);
+
+	/* GbE RAM Write */
+	espada_gnetsetting_write(periodicalsending_data->baseaddr, data, GBE_RAM_SUSPEND);
+}
+EXPORT_SYMBOL_GPL(espada_gnetsetting_set_gberam_suspend);
+
+unsigned int espada_gnetsetting_get_gberam_suspend(void)
+{
+	struct espada_gnetsetting_periodicalsending_data *periodicalsending_data
+		= &(gnetsetting_device->periodicalsending);
+
+	/* GbE RAM Read */
+	return espada_gnetsetting_read(periodicalsending_data->baseaddr, GBE_RAM_SUSPEND);
+}
+EXPORT_SYMBOL_GPL(espada_gnetsetting_get_gberam_suspend);
+
+static struct kobj_attribute espada_gnetsetting_filtering_attribute
+	= __ATTR(filtering, 0644, espada_gnetsetting_filtering_show,
+				espada_gnetsetting_filtering_store);
+static struct kobj_attribute espada_gnetsetting_autoresponse_attribute
+	= __ATTR(autoresponse, 0644, espada_gnetsetting_autoresponse_show,
+				espada_gnetsetting_autoresponse_store);
+static struct kobj_attribute espada_gnetsetting_periodicalsending_attribute
+	= __ATTR(periodicalsending, 0644,
+			espada_gnetsetting_periodicalsending_show,
+			espada_gnetsetting_periodicalsending_store);
+
+static struct attribute *espada_gnetsetting_attrs[] = {
+	&espada_gnetsetting_filtering_attribute.attr,
+	&espada_gnetsetting_autoresponse_attribute.attr,
+	&espada_gnetsetting_periodicalsending_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group espada_gnetsetting_attr_group = {
+	.attrs = espada_gnetsetting_attrs,
+};
+
+static const struct of_device_id
+	espada_gnetsetting_dt_ids[] __initdata = {
+		{.compatible = "renesas,espada_gnetsetting",},
+		{},
+};
+
+static int __init espada_gnetsetting_init(void)
+{
+	int retval;
+	struct device_node *np;
+	struct resource res;
+	resource_size_t size;
+
+	espada_class = class_create(THIS_MODULE, "espada");
+	if (IS_ERR(espada_class)) {
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	gnetsetting_dev =
+		device_create(espada_class, NULL, 0, NULL, "gnetsetting");
+	if (!gnetsetting_dev) {
+		retval = -ENOMEM;
+		goto err_alloc_device;
+	}
+
+	retval = sysfs_create_group(&gnetsetting_dev->kobj,
+				&espada_gnetsetting_attr_group);
+	if (retval) {
+		retval = -ENOMEM;
+		goto err_alloc;
+	}
+
+	gnetsetting_device = kzalloc(sizeof(struct espada_gnetsetting_device),
+				     GFP_KERNEL);
+	if (!gnetsetting_device) {
+		retval = -ENOMEM;
+		goto err_alloc;
+	}
+
+	for_each_matching_node(np, espada_gnetsetting_dt_ids) {
+		retval = of_address_to_resource(np, 0, &res);
+		if (retval)
+			goto err_alloc;
+
+		size = resource_size(&res);
+
+		gnetsetting_device->filtering.baseaddr
+			= ioremap_nocache(res.start, size);
+
+		if (!gnetsetting_device->filtering.baseaddr) {
+			retval = -ENOMEM;
+			goto err_alloc;
+		}
+
+		gnetsetting_device->filtering.reglist
+			= espada_gnetsetting_filtering_reg;
+		gnetsetting_device->filtering.reglistsize
+			= ARRAY_SIZE(espada_gnetsetting_filtering_reg);
+		gnetsetting_device->filtering.offset
+			= ESPADA_GNETSETTING_FILTERING_REG_OFFSET;
+		espada_gnetsetting_set_chkreglist(
+			&gnetsetting_device->filtering);
+
+		gnetsetting_device->autoresponse.baseaddr
+			= gnetsetting_device->filtering.baseaddr;
+		gnetsetting_device->autoresponse.reglist
+			= espada_gnetsetting_autoresponse_reg;
+		gnetsetting_device->autoresponse.reglistsize
+			= ARRAY_SIZE(espada_gnetsetting_autoresponse_reg);
+		gnetsetting_device->autoresponse.offset
+			= ESPADA_GNETSETTING_AUTORESPONSE_REG_OFFSET;
+		espada_gnetsetting_set_chkreglist(
+			&gnetsetting_device->autoresponse);
+
+		retval = of_address_to_resource(np, 1, &res);
+		if (retval)
+			goto err_alloc;
+
+		size = resource_size(&res);
+		if (!request_mem_region(res.start, size,
+				ESPADA_GNETSETTING_DRV_NAME)) {
+			retval = -EBUSY;
+			goto err_alloc;
+		}
+
+		gnetsetting_device->periodicalsending.baseaddr
+			= ioremap(res.start, size);
+		if (!(gnetsetting_device->autoresponse.baseaddr)) {
+			retval = -ENOMEM;
+			goto err_alloc;
+		}
+
+		gnetsetting_device->periodicalsending.time = 0;
+		gnetsetting_device->periodicalsending.size = 0;
+		memset(gnetsetting_device->periodicalsending.data, 0,
+				ESPADA_GNETSETTING_MAX_DATA_SIZE_INT);
+	}
+
+	return 0;
+
+err_alloc:
+	device_destroy(espada_class, 0);
+err_alloc_device:
+	class_destroy(espada_class);
+	kfree(gnetsetting_device);
+exit:
+	return retval;
+}
+
+static void __exit espada_gnetsetting_exit(void)
+{
+	device_destroy(espada_class, 0);
+	class_destroy(espada_class);
+	kfree(gnetsetting_device);
+}
+
+module_init(espada_gnetsetting_init);
+module_exit(espada_gnetsetting_exit);
+
+MODULE_DESCRIPTION("Renesas Standby response extension setting module driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/renesas/espada_gnetsetting.h b/drivers/net/ethernet/renesas/espada_gnetsetting.h
new file mode 100644
index 0000000..be44869
--- /dev/null
+++ b/drivers/net/ethernet/renesas/espada_gnetsetting.h
@@ -0,0 +1,224 @@
+/* Renesas Ethernet AVB device driver
+ *
+ * Copyright (C) 2014-2015 Renesas Electronics Corporation
+ * Copyright (C) 2015 Renesas Solutions Corp.
+ * Copyright (C) 2015 Cogent Embedded, Inc. <source@cogentembedded.com>
+ *
+ * Based on the SuperH Ethernet driver
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License version 2,
+ * as published by the Free Software Foundation.
+ */
+
+#ifndef __ESPADA_GNETSETTING_H__
+#define __ESPADA_GNETSETTING_H__
+
+#include <linux/io.h>
+
+enum espada_gnetsetting_reg {
+	CSFR00		= 0x000,
+	CSFR01		= 0x004,
+	CSFR02_0	= 0x008,
+	CSFR02_1	= 0x00C,
+	CSFR02_2	= 0x010,
+	CSFR02_3	= 0x014,
+	CSFR03_U	= 0x018,
+	CSFR03_L	= 0x01C,
+	CSFR04		= 0x020,
+	CSFR10_0	= 0x030,
+	CSFR10_1	= 0x034,
+	CSFR10_2	= 0x038,
+	CSFR10_3	= 0x03C,
+	CSFR10		= 0x040,
+	CSFR11_0	= 0x044,
+	CSFR11_1	= 0x048,
+	CSFR11_2	= 0x04C,
+	CSFR11_3	= 0x050,
+	CSFR11		= 0x054,
+	CSFR12_0	= 0x058,
+	CSFR12_1	= 0x05C,
+	CSFR12_2	= 0x060,
+	CSFR12_3	= 0x064,
+	CSFR12_4	= 0x068,
+	CSFR12_5	= 0x06C,
+	CSFR12_6	= 0x070,
+	CSFR12_7	= 0x074,
+	CSFR12_8	= 0x078,
+	CSFR12_9	= 0x07C,
+	CSFR12_10	= 0x080,
+	CSFR12_11	= 0x084,
+	CSFR12		= 0x088,
+	CSFR13_U	= 0x08C,
+	CSFR13_L	= 0x090,
+	CSFR14_U	= 0x094,
+	CSFR14_L	= 0x098,
+	CSFR15_U_0	= 0x09C,
+	CSFR15_L_0	= 0x0A0,
+	CSFR15_U_1	= 0x0A4,
+	CSFR15_L_1	= 0x0A8,
+	CSFR15_U_2	= 0x0AC,
+	CSFR15_L_2	= 0x0B0,
+	CSFR15_U_3	= 0x0B4,
+	CSFR15_L_3	= 0x0B8,
+	CSFR15_U_4	= 0x0BC,
+	CSFR15_L_4	= 0x0C0,
+	CSFR15_U_5	= 0x0C4,
+	CSFR15_L_5	= 0x0C8,
+	CSFR15_U_6	= 0x0CC,
+	CSFR15_L_6	= 0x0D0,
+	CSFR15_U_7	= 0x0D4,
+	CSFR15_L_7	= 0x0D8,
+	CSFR15_U_8	= 0x0DC,
+	CSFR15_L_8	= 0x0E0,
+	CSFR15_U_9	= 0x0E4,
+	CSFR15_L_9	= 0x0E8,
+	CSFR15_U_10	= 0x0EC,
+	CSFR15_L_10	= 0x0F0,
+	CSFR15_U_11	= 0x0F4,
+	CSFR15_L_11	= 0x0F8,
+	CSFR15_U_12	= 0x0FC,
+	CSFR15_L_12	= 0x100,
+	CSFR15_U_13	= 0x104,
+	CSFR15_L_13	= 0x108,
+	CSFR15_U_14	= 0x10C,
+	CSFR15_L_14	= 0x110,
+	CSFR15_U_15	= 0x114,
+	CSFR15_L_15	= 0x118,
+	CSFR15_U_16	= 0x11C,
+	CSFR15_L_16	= 0x120,
+	CSFR15_U_17	= 0x124,
+	CSFR15_L_17	= 0x128,
+	CSFR15_U_18	= 0x12C,
+	CSFR15_L_18	= 0x130,
+	CSFR15_U_19	= 0x134,
+	CSFR15_L_19	= 0x138,
+	CSFR15		= 0x13C,
+	CSFR16_0	= 0x140,
+	CSFR16_1	= 0x144,
+	CSFR16_2	= 0x148,
+	CSFR16		= 0x14C,
+	CSFR20		= 0x160,
+	CSFR21		= 0x164,
+	CSFR30		= 0x170,
+	CSFR31		= 0x174,
+	CSFR40		= 0x180,
+	CSFR41		= 0x184,
+};
+
+static const u32 espada_gnetsetting_filtering_reg[] = {
+	CSFR00,
+	CSFR01,
+	CSFR02_0,
+	CSFR02_1,
+	CSFR02_2,
+	CSFR02_3,
+	CSFR03_U,
+	CSFR03_L,
+	CSFR04,
+	CSFR10_0,
+	CSFR10_1,
+	CSFR10_2,
+	CSFR10_3,
+	CSFR10,
+	CSFR11_0,
+	CSFR11_1,
+	CSFR11_2,
+	CSFR11_3,
+	CSFR11,
+	CSFR12_0,
+	CSFR12_1,
+	CSFR12_2,
+	CSFR12_3,
+	CSFR12_4,
+	CSFR12_5,
+	CSFR12_6,
+	CSFR12_7,
+	CSFR12_8,
+	CSFR12_9,
+	CSFR12_10,
+	CSFR12_11,
+	CSFR12,
+	CSFR13_U,
+	CSFR13_L,
+	CSFR14_U,
+	CSFR14_L,
+	CSFR15_U_0,
+	CSFR15_L_0,
+	CSFR15_U_1,
+	CSFR15_L_1,
+	CSFR15_U_2,
+	CSFR15_L_2,
+	CSFR15_U_3,
+	CSFR15_L_3,
+	CSFR15_U_4,
+	CSFR15_L_4,
+	CSFR15_U_5,
+	CSFR15_L_5,
+	CSFR15_U_6,
+	CSFR15_L_6,
+	CSFR15_U_7,
+	CSFR15_L_7,
+	CSFR15_U_8,
+	CSFR15_L_8,
+	CSFR15_U_9,
+	CSFR15_L_9,
+	CSFR15_U_10,
+	CSFR15_L_10,
+	CSFR15_U_11,
+	CSFR15_L_11,
+	CSFR15_U_12,
+	CSFR15_L_12,
+	CSFR15_U_13,
+	CSFR15_L_13,
+	CSFR15_U_14,
+	CSFR15_L_14,
+	CSFR15_U_15,
+	CSFR15_L_15,
+	CSFR15_U_16,
+	CSFR15_L_16,
+	CSFR15_U_17,
+	CSFR15_L_17,
+	CSFR15_U_18,
+	CSFR15_L_18,
+	CSFR15_U_19,
+	CSFR15_L_19,
+	CSFR15,
+	CSFR16_0,
+	CSFR16_1,
+	CSFR16_2,
+	CSFR16,
+	CSFR20,
+	CSFR21
+};
+
+static const u32 espada_gnetsetting_autoresponse_reg[] = {
+	CSFR30,
+	CSFR31,
+	CSFR40,
+	CSFR41,
+};
+
+enum espada_gnetsetting_gberam_offset {
+	GBE_RAM_TIME		= 0x00000,
+	GBE_RAM_SIZE		= 0x00004,
+	GBE_RAM_SUSPEND		= 0x00100,
+	GBE_RAM_SEND_DATA	= 0x18000,
+};
+
+static inline u32 espada_gnetsetting_read(void __iomem *baseaddr,
+					  unsigned int reg)
+{
+	return ioread32(baseaddr + reg);
+}
+
+static inline void espada_gnetsetting_write(void __iomem *baseaddr,
+					    u32 data, unsigned int reg)
+{
+	iowrite32(data, baseaddr + reg);
+}
+
+#define ESPADA_GNETSETTING_FILTERING_REG_OFFSET		0
+#define ESPADA_GNETSETTING_AUTORESPONSE_REG_OFFSET (CSFR30 - CSFR00)
+
+#endif	/* #ifndef __ESPADA_GNETSETTING_H__ */
diff --git a/drivers/net/ethernet/renesas/ravb.h b/drivers/net/ethernet/renesas/ravb.h
index e3cbbce..e5407f9 100644
--- a/drivers/net/ethernet/renesas/ravb.h
+++ b/drivers/net/ethernet/renesas/ravb.h
@@ -21,6 +21,8 @@
 #include <linux/ptp_clock_kernel.h>
 #include <linux/reset.h>
 
+#define NUM_TX_DESC	2	/* TX descriptors per packet */
+
 #define BE_TX_RING_SIZE	64	/* TX ring size for Best Effort */
 #define BE_RX_RING_SIZE	1024	/* RX ring size for Best Effort */
 #define NC_TX_RING_SIZE	64	/* TX ring size for Network Control */
@@ -955,9 +957,7 @@ enum TID_BIT {
 enum ECMR_BIT {
 	ECMR_PRM	= 0x00000001,
 	ECMR_DM		= 0x00000002,
-#ifdef CONFIG_ARCH_ESPADA
 	CXR20_LPM	= 0x00000010,
-#endif /* CONFIG_ARCH_ESPADA */
 	ECMR_TE		= 0x00000020,
 	ECMR_RE		= 0x00000040,
 	ECMR_MPDE	= 0x00000200,
@@ -1320,13 +1320,14 @@ struct ravb_backup {
 #define LPTXMTH1_RESOLUTION 320
 #define RAVB_NS2MS 1000
 #define RAVB_RCV_DESCRIPTOR_DATA_SIZE 4080
-#define RAVB_RCV_BUFF_MAX 8192
 #define RAVB_MDIO_STAT1_CLKSTOP_EN 0x40
-#define RAVB_NOT_SUSPEND 0
-#define RAVB_SUSPEND 1
 #define RAVB_SET_SUSPEND_ROLLBACK 0x80000000
 #endif	/* CONFIG_ARCH_ESPADA */
 
+#define RAVB_NOT_SUSPEND 0
+#define RAVB_SUSPEND 1
+#define RAVB_RCV_BUFF_MAX 8192
+
 struct ravb_private {
 	struct net_device *ndev;
 	struct platform_device *pdev;
@@ -1367,12 +1368,14 @@ struct ravb_private {
 	struct work_struct work;
 	/* MII transceiver section. */
 	struct mii_bus *mii_bus;	/* MDIO bus control */
+	struct phy_device *phydev;	/* PHY device control */
 	int link;
 	phy_interface_t phy_interface;
 	int msg_enable;
 	int speed;
 	int duplex;
 	int emac_irq;
+	int toe_irq;
 	enum ravb_chip_id chip_id;
 	int rx_irqs[NUM_RX_QUEUE];
 	int tx_irqs[NUM_TX_QUEUE];
diff --git a/drivers/net/ethernet/renesas/ravb_main.c b/drivers/net/ethernet/renesas/ravb_main.c
index 8ea93a5..31c0cae 100644
--- a/drivers/net/ethernet/renesas/ravb_main.c
+++ b/drivers/net/ethernet/renesas/ravb_main.c
@@ -40,16 +40,6 @@
 		 NETIF_MSG_RX_ERR | \
 		 NETIF_MSG_TX_ERR)
 
-static const char *ravb_rx_irqs[NUM_RX_QUEUE] = {
-	"ch0", /* RAVB_BE */
-	"ch1", /* RAVB_NC */
-};
-
-static const char *ravb_tx_irqs[NUM_TX_QUEUE] = {
-	"ch18", /* RAVB_BE */
-	"ch19", /* RAVB_NC */
-};
-
 void ravb_modify(struct net_device *ndev, enum ravb_reg reg, u32 clear,
 		 u32 set)
 {
@@ -73,7 +63,8 @@ static int ravb_config(struct net_device *ndev)
 	int error;
 
 	/* Set config mode */
-	ravb_modify(ndev, CCC, CCC_OPC, CCC_OPC_CONFIG);
+	ravb_write(ndev, (ravb_read(ndev, CCC) & ~CCC_OPC) | CCC_OPC_CONFIG,
+		   CCC);
 	/* Check if the operating mode is changed to the config mode */
 	error = ravb_wait(ndev, CSR, CSR_OPS, CSR_OPS_CONFIG);
 	if (error)
@@ -134,18 +125,12 @@ static void ravb_read_mac_address(struct net_device *ndev, const u8 *mac)
 		u32 mahr = ravb_read(ndev, MAHR);
 		u32 malr = ravb_read(ndev, MALR);
 
-	//	ndev->dev_addr[0] = (mahr >> 24) & 0xFF;
-	//	ndev->dev_addr[1] = (mahr >> 16) & 0xFF;
-	//	ndev->dev_addr[2] = (mahr >>  8) & 0xFF;
-	//	ndev->dev_addr[3] = (mahr >>  0) & 0xFF;
-	//	ndev->dev_addr[4] = (malr >>  8) & 0xFF;
-	//	ndev->dev_addr[5] = (malr >>  0) & 0xFF;
-		ndev->dev_addr[0] = 0x74;
-		ndev->dev_addr[1] = 0x90;
-		ndev->dev_addr[2] = 0x50;
-		ndev->dev_addr[3] = 0x00;
-		ndev->dev_addr[4] = 0x00;
-		ndev->dev_addr[5] = 0x61;
+		ndev->dev_addr[0] = (mahr >> 24) & 0xFF;
+		ndev->dev_addr[1] = (mahr >> 16) & 0xFF;
+		ndev->dev_addr[2] = (mahr >>  8) & 0xFF;
+		ndev->dev_addr[3] = (mahr >>  0) & 0xFF;
+		ndev->dev_addr[4] = (malr >>  8) & 0xFF;
+		ndev->dev_addr[5] = (malr >>  0) & 0xFF;
 	}
 }
 
@@ -198,7 +183,6 @@ static int ravb_tx_free(struct net_device *ndev, int q, bool free_txed_only)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
 	struct net_device_stats *stats = &priv->stats[q];
-	int num_tx_desc = priv->num_tx_desc;
 	struct ravb_tx_desc *desc;
 	int free_num = 0;
 	int entry;
@@ -208,7 +192,7 @@ static int ravb_tx_free(struct net_device *ndev, int q, bool free_txed_only)
 		bool txed;
 
 		entry = priv->dirty_tx[q] % (priv->num_tx_ring[q] *
-					     num_tx_desc);
+					     NUM_TX_DESC);
 		desc = &priv->tx_ring[q][entry];
 		txed = desc->die_dt == DT_FEMPTY;
 		if (free_txed_only && !txed)
@@ -217,12 +201,12 @@ static int ravb_tx_free(struct net_device *ndev, int q, bool free_txed_only)
 		dma_rmb();
 		size = le16_to_cpu(desc->ds_tagl) & TX_DS;
 		/* Free the original skb. */
-		if (priv->tx_skb[q][entry / num_tx_desc]) {
+		if (priv->tx_skb[q][entry / NUM_TX_DESC]) {
 			dma_unmap_single(ndev->dev.parent, le32_to_cpu(desc->dptr),
 					 size, DMA_TO_DEVICE);
 			/* Last packet descriptor? */
-			if (entry % num_tx_desc == num_tx_desc - 1) {
-				entry /= num_tx_desc;
+			if (entry % NUM_TX_DESC == NUM_TX_DESC - 1) {
+				entry /= NUM_TX_DESC;
 				dev_kfree_skb_any(priv->tx_skb[q][entry]);
 				priv->tx_skb[q][entry] = NULL;
 				if (txed)
@@ -241,36 +225,35 @@ static int ravb_tx_free(struct net_device *ndev, int q, bool free_txed_only)
 static void ravb_ring_free(struct net_device *ndev, int q)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
-	int num_tx_desc = priv->num_tx_desc;
 	int ring_size;
 	int i;
 
 	if (priv->rx_ring[q]) {
 		for (i = 0; i < priv->num_rx_ring[q]; i++) {
-#ifndef CONFIG_ARCH_ESPADA
-			struct ravb_ex_rx_desc *desc = &priv->rx_ring[q][i];
-#else
+#if defined(CONFIG_ARCH_ESPADA)
 			struct ravb_rx_desc *desc = &priv->rx_ring[q][i];
-#endif
+#else  /* CONFIG_ARCH_ESPADA */
+			struct ravb_ex_rx_desc *desc = &priv->rx_ring[q][i];
+#endif  /* CONFIG_ARCH_ESPADA */
 
 			if (!dma_mapping_error(ndev->dev.parent,
 					       le32_to_cpu(desc->dptr)))
 				dma_unmap_single(ndev->dev.parent,
 						 le32_to_cpu(desc->dptr),
-#ifdef CONFIG_ARCH_ESPADA
+#if defined(CONFIG_ARCH_ESPADA)
 						 RAVB_RCV_BUFF_MAX,
-#else
-						 priv->rx_buf_sz,
-#endif
+#else  /* CONFIG_ARCH_ESPADA */
+						 PKT_BUF_SZ,
+#endif  /* CONFIG_ARCH_ESPADA */
 						 DMA_FROM_DEVICE);
 		}
-#ifdef CONFIG_ARCH_ESPADA
+#if defined(CONFIG_ARCH_ESPADA)
 		ring_size = sizeof(struct ravb_rx_desc) *
 			    (priv->num_rx_ring[q] + 1);
 #else  /* CONFIG_ARCH_ESPADA */
 		ring_size = sizeof(struct ravb_ex_rx_desc) *
 			    (priv->num_rx_ring[q] + 1);
-#endif
+#endif  /* CONFIG_ARCH_ESPADA */
 		dma_free_coherent(ndev->dev.parent, ring_size, priv->rx_ring[q],
 				  priv->rx_desc_dma[q]);
 		priv->rx_ring[q] = NULL;
@@ -280,7 +263,7 @@ static void ravb_ring_free(struct net_device *ndev, int q)
 		ravb_tx_free(ndev, q, false);
 
 		ring_size = sizeof(struct ravb_tx_desc) *
-			    (priv->num_tx_ring[q] * num_tx_desc + 1);
+			    (priv->num_tx_ring[q] * NUM_TX_DESC + 1);
 		dma_free_coherent(ndev->dev.parent, ring_size, priv->tx_ring[q],
 				  priv->tx_desc_dma[q]);
 		priv->tx_ring[q] = NULL;
@@ -309,17 +292,16 @@ static void ravb_ring_free(struct net_device *ndev, int q)
 static void ravb_ring_format(struct net_device *ndev, int q)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
-	int num_tx_desc = priv->num_tx_desc;
-#ifdef CONFIG_ARCH_ESPADA
+#if defined(CONFIG_ARCH_ESPADA)
 	struct ravb_rx_desc *rx_desc;
 #else  /* CONFIG_ARCH_ESPADA */
 	struct ravb_ex_rx_desc *rx_desc;
-#endif
+#endif  /* CONFIG_ARCH_ESPADA */
 	struct ravb_tx_desc *tx_desc;
 	struct ravb_desc *desc;
 	int rx_ring_size = sizeof(*rx_desc) * priv->num_rx_ring[q];
 	int tx_ring_size = sizeof(*tx_desc) * priv->num_tx_ring[q] *
-			   num_tx_desc;
+			   NUM_TX_DESC;
 	dma_addr_t dma_addr;
 	int i;
 
@@ -333,18 +315,20 @@ static void ravb_ring_format(struct net_device *ndev, int q)
 	for (i = 0; i < priv->num_rx_ring[q]; i++) {
 		/* RX descriptor */
 		rx_desc = &priv->rx_ring[q][i];
-#ifdef CONFIG_ARCH_ESPADA
+		/* The size of the buffer should be on 16-byte boundary. */
+#if defined(CONFIG_ARCH_ESPADA)
 		rx_desc->ds_cc = cpu_to_le16(RAVB_RCV_DESCRIPTOR_DATA_SIZE);
 		dma_addr = dma_map_single(ndev->dev.parent,
 					  priv->rx_skb[q][i]->data,
 					  ALIGN(RAVB_RCV_BUFF_MAX, 16),
 					  DMA_FROM_DEVICE);
 #else  /* CONFIG_ARCH_ESPADA */
-		rx_desc->ds_cc = cpu_to_le16(priv->rx_buf_sz);
-		dma_addr = dma_map_single(ndev->dev.parent, priv->rx_skb[q][i]->data,
-					  priv->rx_buf_sz,
+		rx_desc->ds_cc = cpu_to_le16(ALIGN(PKT_BUF_SZ, 16));
+		dma_addr = dma_map_single(ndev->dev.parent,
+					  priv->rx_skb[q][i]->data,
+					  ALIGN(PKT_BUF_SZ, 16),
 					  DMA_FROM_DEVICE);
-#endif
+#endif  /* CONFIG_ARCH_ESPADA */
 		/* We just set the data size to 0 for a failed mapping which
 		 * should prevent DMA from happening...
 		 */
@@ -362,10 +346,8 @@ static void ravb_ring_format(struct net_device *ndev, int q)
 	for (i = 0, tx_desc = priv->tx_ring[q]; i < priv->num_tx_ring[q];
 	     i++, tx_desc++) {
 		tx_desc->die_dt = DT_EEMPTY;
-		if (num_tx_desc > 1) {
-			tx_desc++;
-			tx_desc->die_dt = DT_EEMPTY;
-		}
+		tx_desc++;
+		tx_desc->die_dt = DT_EEMPTY;
 	}
 	tx_desc->dptr = cpu_to_le32((u32)priv->tx_desc_dma[q]);
 	tx_desc->die_dt = DT_LINKFIX; /* type */
@@ -385,14 +367,10 @@ static void ravb_ring_format(struct net_device *ndev, int q)
 static int ravb_ring_init(struct net_device *ndev, int q)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
-	int num_tx_desc = priv->num_tx_desc;
 	struct sk_buff *skb;
 	int ring_size;
 	int i;
 
-	priv->rx_buf_sz = (ndev->mtu <= 1492 ? PKT_BUF_SZ : ndev->mtu) +
-		ETH_HLEN + VLAN_HLEN + sizeof(__sum16);
-
 	/* Allocate RX and TX skb rings */
 	priv->rx_skb[q] = kcalloc(priv->num_rx_ring[q],
 				  sizeof(*priv->rx_skb[q]), GFP_KERNEL);
@@ -402,23 +380,30 @@ static int ravb_ring_init(struct net_device *ndev, int q)
 		goto error;
 
 	for (i = 0; i < priv->num_rx_ring[q]; i++) {
-		skb = netdev_alloc_skb(ndev, priv->rx_buf_sz + RAVB_ALIGN - 1);
+#if defined(CONFIG_ARCH_ESPADA)
+		skb = netdev_alloc_skb(ndev,
+			RAVB_RCV_BUFF_MAX + RAVB_ALIGN - 1);
+#else  /* CONFIG_ARCH_ESPADA */
+		skb = netdev_alloc_skb(ndev, PKT_BUF_SZ + RAVB_ALIGN - 1);
+#endif  /* CONFIG_ARCH_ESPADA */
 		if (!skb)
 			goto error;
 		ravb_set_buffer_align(skb);
 		priv->rx_skb[q][i] = skb;
 	}
 
-	if (num_tx_desc > 1) {
-		/* Allocate rings for the aligned buffers */
-		priv->tx_align[q] = kmalloc(DPTR_ALIGN * priv->num_tx_ring[q] +
-					    DPTR_ALIGN - 1, GFP_KERNEL);
-		if (!priv->tx_align[q])
-			goto error;
-	}
+	/* Allocate rings for the aligned buffers */
+	priv->tx_align[q] = kmalloc(DPTR_ALIGN * priv->num_tx_ring[q] +
+				    DPTR_ALIGN - 1, GFP_KERNEL);
+	if (!priv->tx_align[q])
+		goto error;
 
 	/* Allocate all RX descriptors. */
+#if defined(CONFIG_ARCH_ESPADA)
+	ring_size = sizeof(struct ravb_rx_desc) * (priv->num_rx_ring[q] + 1);
+#else  /* CONFIG_ARCH_ESPADA */
 	ring_size = sizeof(struct ravb_ex_rx_desc) * (priv->num_rx_ring[q] + 1);
+#endif  /* CONFIG_ARCH_ESPADA */
 	priv->rx_ring[q] = dma_alloc_coherent(ndev->dev.parent, ring_size,
 					      &priv->rx_desc_dma[q],
 					      GFP_KERNEL);
@@ -429,7 +414,7 @@ static int ravb_ring_init(struct net_device *ndev, int q)
 
 	/* Allocate all TX descriptors. */
 	ring_size = sizeof(struct ravb_tx_desc) *
-		    (priv->num_tx_ring[q] * num_tx_desc + 1);
+		    (priv->num_tx_ring[q] * NUM_TX_DESC + 1);
 	priv->tx_ring[q] = dma_alloc_coherent(ndev->dev.parent, ring_size,
 					      &priv->tx_desc_dma[q],
 					      GFP_KERNEL);
@@ -451,23 +436,19 @@ static void ravb_emac_init(struct net_device *ndev)
 	u32 ecmr;
 
 	/* Receive frame limit set register */
-	ravb_write(ndev, ndev->mtu + ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN, RFLR);
+	ravb_write(ndev, RAVB_RCV_BUFF_MAX + ETH_FCS_LEN, RFLR);
 
+	/* PAUSE prohibition */
 	ecmr =  ravb_read(ndev, ECMR);
 	ecmr &= ECMR_DM;
-
-#ifndef CONFIG_ARCH_ESPADA
-	/* EMAC Mode: PAUSE prohibition; Duplex; RX Checksum; TX; RX */
-	ravb_write(ndev, ECMR_ZPF | ECMR_DM |
-		   (ndev->features & NETIF_F_RXCSUM ? ECMR_RCSC : 0) |
-		   ECMR_TE | ECMR_RE, ECMR);
-#else	
+#if defined(CONFIG_ARCH_ESPADA)
 	ecmr |=  ECMR_ZPF | (priv->duplex ? ECMR_DM : 0) |
-	                ECMR_TE | ECMR_RE | CXR20_RCPT |
-	                ECMR_TXF | ECMR_RXF | ECMR_PRM;
-	
+			 ECMR_TE | ECMR_RE | CXR20_RCPT |
+			 ECMR_TXF | ECMR_RXF | ECMR_PRM;
+#else /* CONFIG_ARCH_ESPADA */
+	ecmr |= ECMR_ZPF | (priv->duplex ? ECMR_DM : 0) | ECMR_TE | ECMR_RE;
+#endif /* CONFIG_ARCH_ESPADA */
 	ravb_write(ndev, ecmr, ECMR);
-#endif
 
 	ravb_set_rate(ndev);
 
@@ -478,51 +459,39 @@ static void ravb_emac_init(struct net_device *ndev)
 	ravb_write(ndev,
 		   (ndev->dev_addr[4] << 8)  | (ndev->dev_addr[5]), MALR);
 
-#ifndef CONFIG_ARCH_ESPADA
-	/* E-MAC status register clear */
-	ravb_write(ndev, ECSR_ICD | ECSR_MPD, ECSR);
+	ravb_write(ndev, 1, MPR);
 
-	/* E-MAC interrupt enable register */
-	ravb_write(ndev, ECSIPR_ICDIP | ECSIPR_MPDIP | ECSIPR_LCHNGIP, ECSIPR);
-#else
 	/* E-MAC status register clear */
+#if defined(CONFIG_ARCH_ESPADA)
 	ravb_write(ndev, ECSR_ICD | ECSR_MPD | ECSR_LCHNG |
-	                                 ECSR_RFRI, ECSR);
+					 ECSR_RFRI, ECSR);
 	ravb_write(ndev, CSR0_TPE | CSR0_RPE, CSR0);
-
-	ravb_write(ndev, 0x3, CXR2C);
-
-	ravb_write(ndev, 0x1F40, CXR2A);
-
-	ravb_write(ndev, 0x1, CXR71);
-
-	ravb_write(ndev, 0, CXR21);
-
-	ravb_write(ndev, 0x1D, CXR22);
-
-	ravb_write(ndev, 0x8, CXR2G);
+#else /* CONFIG_ARCH_ESPADA */
+	ravb_write(ndev, ECSR_ICD | ECSR_MPD, ECSR);
+#endif /* CONFIG_ARCH_ESPADA */
 
 	/* E-MAC interrupt enable register */
+#if defined(CONFIG_ARCH_ESPADA)
 	ravb_write(ndev, ECSIPR_ICDIP, ECSIPR);
-	
+
 	ravb_write(ndev, ravb_read(ndev, CXR31)
-	                 & ~CXR31_SEL_LINK1, CXR31);
+			 & ~CXR31_SEL_LINK1, CXR31);
 	if (priv->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) {
-	        ravb_write(ndev, ravb_read(ndev, CXR31)
-	                 | CXR31_SEL_LINK0, CXR31);
+		ravb_write(ndev, ravb_read(ndev, CXR31)
+			 | CXR31_SEL_LINK0, CXR31);
 	} else {
-	        ravb_write(ndev, ravb_read(ndev, CXR31)
-	                 & ~CXR31_SEL_LINK0, CXR31);
+		ravb_write(ndev, ravb_read(ndev, CXR31)
+			 & ~CXR31_SEL_LINK0, CXR31);
 	}
-#endif
+#else /* CONFIG_ARCH_ESPADA */
+	ravb_write(ndev, ECSIPR_ICDIP | ECSIPR_MPDIP | ECSIPR_LCHNGIP, ECSIPR);
+#endif /* CONFIG_ARCH_ESPADA */
+
 }
 
 /* Device init function for Ethernet AVB */
 static int ravb_dmac_init(struct net_device *ndev)
 {
-#ifndef CONFIG_ARCH_ESPADA
-	struct ravb_private *priv = netdev_priv(ndev);
-#endif
 	int error;
 
 	/* Set CONFIG mode */
@@ -544,93 +513,61 @@ static int ravb_dmac_init(struct net_device *ndev)
 	ravb_ring_format(ndev, RAVB_NC);
 
 #if defined(__LITTLE_ENDIAN)
-	ravb_modify(ndev, CCC, CCC_BOC, 0);
+	ravb_write(ndev, ravb_read(ndev, CCC) & ~CCC_BOC, CCC);
 #else
-	ravb_modify(ndev, CCC, CCC_BOC, CCC_BOC);
+	ravb_write(ndev, ravb_read(ndev, CCC) | CCC_BOC, CCC);
 #endif
 
-#ifndef CONFIG_ARCH_ESPADA
-	/* Set AVB RX */
-	ravb_write(ndev,
-		   RCR_EFFS | RCR_ENCF | RCR_ETS0 | RCR_ESF | 0x18000000, RCR);
-
-	/* Set FIFO size */
-	ravb_write(ndev, TGC_TQP_AVBMODE1 | 0x00112200, TGC);
-
-	/* Timestamp enable */
-	ravb_write(ndev, TCCR_TFEN, TCCR);
-
-	/* Interrupt init: */
-	if (priv->chip_id == RCAR_GEN3) {
-		/* Clear DIL.DPLx */
-		ravb_write(ndev, 0, DIL);
-		/* Set queue specific interrupt */
-		ravb_write(ndev, CIE_CRIE | CIE_CTIE | CIE_CL0M, CIE);
-	}
-	/* Frame receive */
-	ravb_write(ndev, RIC0_FRE0 | RIC0_FRE1, RIC0);
-	/* Disable FIFO full warning */
-	ravb_write(ndev, 0, RIC1);
-	/* Receive FIFO full error, descriptor empty */
-	ravb_write(ndev, RIC2_QFE0 | RIC2_QFE1 | RIC2_RFFE, RIC2);
-	/* Frame transmitted, timestamp FIFO updated */
-	ravb_write(ndev, TIC_FTE0 | TIC_FTE1 | TIC_TFUE, TIC);
-#else
+#if defined(CONFIG_ARCH_ESPADA)
 	/* Set AVB RX */
 	ravb_write(ndev, 0x60000000, RCR);
 
 	/* Set Max Frame Length (RTC) */
 	ravb_write(ndev, 0x7ffc0000 | RAVB_RCV_BUFF_MAX, RTC);
 
-	ravb_write(ndev, 0x101, CIE);
-
-	ravb_write(ndev, 0xfffe, DIC);
-
-	ravb_write(ndev, 0xfffe, DIE);
+	/* Set FIFO size */
+	ravb_write(ndev, 0x00222200, TGC);
 
-	ravb_write(ndev, 0xA07, EIE);
+	ravb_write(ndev, 0, TCCR);
 
-	ravb_write(ndev, 0x1, RIE0);
+	/* Interrupt enable: */
+	/* Frame receive */
+	ravb_write(ndev, RIC0_FRE0, RIC0);
 
-	ravb_write(ndev, 0x80000000, RIE1);
+	ravb_write(ndev, 0x0, RIC1);
 
-	ravb_write(ndev, 0x80000001, RIE2);
+	/* Receive FIFO full error, descriptor empty */
+	ravb_write(ndev, RIC2_QFE0 | RIC2_RFFE, RIC2);
 
-	ravb_write(ndev, 0x17C01, TIE);
+	ravb_write(ndev, 0x0, RIC3);
 
-	ravb_write(ndev, 0x1, RIE3);
+	ravb_write(ndev, TIC_FTE, TIC);
+#else   /* CONFIG_ARCH_ESPADA */
+	/* Set AVB RX */
+	ravb_write(ndev, RCR_EFFS | RCR_ENCF | RCR_ETS0 | 0x18000000, RCR);
 
 	/* Set FIFO size */
-	ravb_write(ndev, 0x00222200, TGC);
+	ravb_write(ndev, TGC_TQP_AVBMODE1 | 0x00222200, TGC);
 
-//	ravb_write(ndev, 0, TCCR);
+	/* Timestamp enable */
+	ravb_write(ndev, TCCR_TFEN, TCCR);
 
 	/* Interrupt enable: */
 	/* Frame receive */
-//	ravb_write(ndev, RIC0_FRE0, RIC0);
-//
-//	ravb_write(ndev, 0x0, RIC1);
-//
-//	/* Receive FIFO full error, descriptor empty */
-//	ravb_write(ndev, RIC2_QFE0 | RIC2_RFFE, RIC2);
-//
-//	ravb_write(ndev, 0x0, RIC3);
-
-//	ravb_write(ndev, TIC_FTE, TIC);
-#endif
+	ravb_write(ndev, RIC0_FRE0 | RIC0_FRE1, RIC0);
+	/* Receive FIFO full error, descriptor empty */
+	ravb_write(ndev, RIC2_QFE0 | RIC2_QFE1 | RIC2_RFFE, RIC2);
+	/* Frame transmitted, timestamp FIFO updated */
+	ravb_write(ndev, TIC_FTE0 | TIC_FTE1 | TIC_TFUE, TIC);
 
+#endif  /* CONFIG_ARCH_ESPADA */
 	/* Setting the control will start the AVB-DMAC process. */
-	ravb_modify(ndev, CCC, CCC_OPC, CCC_OPC_OPERATION);
-
-	ravb_write(ndev, 0x30, CSR0);
-
-	ravb_write(ndev, 0x2030273, CXR20);
-
-	ravb_write(ndev, 0x30001, TCCR);
-
+	ravb_write(ndev, (ravb_read(ndev, CCC) & ~CCC_OPC) | CCC_OPC_OPERATION,
+		   CCC);
 	return 0;
 }
 
+#ifndef CONFIG_ARCH_ESPADA
 static void ravb_get_tx_tstamp(struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
@@ -659,15 +596,13 @@ static void ravb_get_tx_tstamp(struct net_device *ndev)
 			kfree(ts_skb);
 			if (tag == tfa_tag) {
 				skb_tstamp_tx(skb, &shhwtstamps);
-				dev_consume_skb_any(skb);
 				break;
-			} else {
-				dev_kfree_skb_any(skb);
 			}
 		}
-		ravb_modify(ndev, TCCR, TCCR_TFR, TCCR_TFR);
+		ravb_write(ndev, ravb_read(ndev, TCCR) | TCCR_TFR, TCCR);
 	}
 }
+#endif
 
 #ifdef CONFIG_ARCH_ESPADA
 static void ravb_rx_csum(struct net_device *ndev, struct sk_buff *skb)
@@ -969,13 +904,13 @@ static bool ravb_rx(struct net_device *ndev, int *quota, int q)
 static void ravb_rcv_snd_disable(struct net_device *ndev)
 {
 	/* Disable TX and RX */
-	ravb_modify(ndev, ECMR, ECMR_RE | ECMR_TE, 0);
+	ravb_write(ndev, ravb_read(ndev, ECMR) & ~(ECMR_RE | ECMR_TE), ECMR);
 }
 
 static void ravb_rcv_snd_enable(struct net_device *ndev)
 {
 	/* Enable TX and RX */
-	ravb_modify(ndev, ECMR, ECMR_RE | ECMR_TE, ECMR_RE | ECMR_TE);
+	ravb_write(ndev, ravb_read(ndev, ECMR) | ECMR_RE | ECMR_TE, ECMR);
 }
 
 /* function for waiting dma process finished */
@@ -984,8 +919,13 @@ static int ravb_stop_dma(struct net_device *ndev)
 	int error;
 
 	/* Wait for stopping the hardware TX process */
+#if defined(CONFIG_ARCH_ESPADA)
+	error = ravb_wait(ndev, TCCR,
+			  TCCR_TSRQ0, 0);
+#else
 	error = ravb_wait(ndev, TCCR,
 			  TCCR_TSRQ0 | TCCR_TSRQ1 | TCCR_TSRQ2 | TCCR_TSRQ3, 0);
+#endif
 	if (error)
 		return error;
 
@@ -1007,16 +947,13 @@ static int ravb_stop_dma(struct net_device *ndev)
 }
 
 /* E-MAC interrupt handler */
-static void ravb_emac_interrupt_unlocked(struct net_device *ndev)
+static void ravb_emac_interrupt(struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
 	u32 ecsr, psr;
 
 	ecsr = ravb_read(ndev, ECSR);
 	ravb_write(ndev, ecsr, ECSR);	/* clear interrupt */
-
-	if (ecsr & ECSR_MPD)
-		pm_wakeup_event(&priv->pdev->dev, 0);
 	if (ecsr & ECSR_ICD)
 		ndev->stats.tx_carrier_errors++;
 	if (ecsr & ECSR_LCHNG) {
@@ -1026,28 +963,16 @@ static void ravb_emac_interrupt_unlocked(struct net_device *ndev)
 		psr = ravb_read(ndev, PSR);
 		if (priv->avb_link_active_low)
 			psr ^= PSR_LMON;
-		if (!(psr & PSR_LMON)) {
+
+		if (!(psr & PSR_LMON))
 			/* DIsable RX and TX */
 			ravb_rcv_snd_disable(ndev);
-		} else {
+		else
 			/* Enable RX and TX */
 			ravb_rcv_snd_enable(ndev);
-		}
 	}
 }
 
-static irqreturn_t ravb_emac_interrupt(int irq, void *dev_id)
-{
-	struct net_device *ndev = dev_id;
-	struct ravb_private *priv = netdev_priv(ndev);
-
-	spin_lock(&priv->lock);
-	ravb_emac_interrupt_unlocked(ndev);
-	mmiowb();
-	spin_unlock(&priv->lock);
-	return IRQ_HANDLED;
-}
-
 /* Error interrupt handler */
 static void ravb_error_interrupt(struct net_device *ndev)
 {
@@ -1055,11 +980,10 @@ static void ravb_error_interrupt(struct net_device *ndev)
 	u32 eis, ris2;
 
 	eis = ravb_read(ndev, EIS);
-	ravb_write(ndev, ~(EIS_QFS | EIS_RESERVED), EIS);
+	ravb_write(ndev, ~EIS_QFS, EIS);
 	if (eis & EIS_QFS) {
 		ris2 = ravb_read(ndev, RIS2);
-		ravb_write(ndev, ~(RIS2_QFF0 | RIS2_RFFF | RIS2_RESERVED),
-			   RIS2);
+		ravb_write(ndev, ~(RIS2_QFF0 | RIS2_RFFF), RIS2);
 
 		/* Receive Descriptor Empty int */
 		if (ris2 & RIS2_QFF0)
@@ -1075,6 +999,7 @@ static void ravb_error_interrupt(struct net_device *ndev)
 	}
 }
 
+#if 0
 static bool ravb_queue_interrupt(struct net_device *ndev, int q)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
@@ -1118,6 +1043,7 @@ static bool ravb_timestamp_interrupt(struct net_device *ndev)
 	}
 	return false;
 }
+#endif
 
 static irqreturn_t ravb_interrupt(int irq, void *dev_id)
 {
@@ -1130,24 +1056,56 @@ static irqreturn_t ravb_interrupt(int irq, void *dev_id)
 	/* Get interrupt status */
 	iss = ravb_read(ndev, ISS);
 
+#if defined(CONFIG_ARCH_ESPADA)
+	/* Received and transmitted interrupts */
+	if (iss & (ISS_FRS | ISS_FTS)) {
+#else  /* CONFIG_ARCH_ESPADA */
 	/* Received and transmitted interrupts */
 	if (iss & (ISS_FRS | ISS_FTS | ISS_TFUS)) {
+#endif  /* CONFIG_ARCH_ESPADA */
+		u32 ris0 = ravb_read(ndev, RIS0);
+		u32 ric0 = ravb_read(ndev, RIC0);
+		u32 tis  = ravb_read(ndev, TIS);
+		u32 tic  = ravb_read(ndev, TIC);
 		int q;
 
+#if defined(CONFIG_ARCH_ESPADA)
+#else  /* CONFIG_ARCH_ESPADA */
 		/* Timestamp updated */
-		if (ravb_timestamp_interrupt(ndev))
+		if (tis & TIS_TFUF) {
+			ravb_write(ndev, ~TIS_TFUF, TIS);
+			ravb_get_tx_tstamp(ndev);
 			result = IRQ_HANDLED;
+		}
+#endif  /* CONFIG_ARCH_ESPADA */
 
 		/* Network control and best effort queue RX/TX */
 		for (q = RAVB_NC; q >= RAVB_BE; q--) {
-			if (ravb_queue_interrupt(ndev, q))
+			if (((ris0 & ric0) & BIT(q)) ||
+			    ((tis  & tic)  & BIT(q))) {
+				if (napi_schedule_prep(&priv->napi[q])) {
+					/* Mask RX and TX interrupts */
+					ric0 &= ~BIT(q);
+					tic &= ~BIT(q);
+					ravb_write(ndev, ric0, RIC0);
+					ravb_write(ndev, tic, TIC);
+					__napi_schedule(&priv->napi[q]);
+				} else {
+					netdev_warn(ndev,
+						    "ignoring interrupt, rx status 0x%08x, rx mask 0x%08x,\n",
+						    ris0, ric0);
+					netdev_warn(ndev,
+						    "                    tx status 0x%08x, tx mask 0x%08x.\n",
+						    tis, tic);
+				}
 				result = IRQ_HANDLED;
+			}
 		}
 	}
 
 	/* E-MAC status summary */
 	if (iss & ISS_MS) {
-		ravb_emac_interrupt_unlocked(ndev);
+		ravb_emac_interrupt(ndev);
 		result = IRQ_HANDLED;
 	}
 
@@ -1157,17 +1115,21 @@ static irqreturn_t ravb_interrupt(int irq, void *dev_id)
 		result = IRQ_HANDLED;
 	}
 
-	/* gPTP interrupt status summary */
+#if defined(CONFIG_ARCH_ESPADA)
+#else  /* CONFIG_ARCH_ESPADA */
 	if (iss & ISS_CGIS) {
 		ravb_ptp_interrupt(ndev);
 		result = IRQ_HANDLED;
 	}
+#endif  /* CONFIG_ARCH_ESPADA */
 
 	mmiowb();
 	spin_unlock(&priv->lock);
+
 	return result;
 }
 
+#if 0
 /* Timestamp/Error/gPTP interrupt handler */
 static irqreturn_t ravb_multi_interrupt(int irq, void *dev_id)
 {
@@ -1227,6 +1189,7 @@ static irqreturn_t ravb_nc_interrupt(int irq, void *dev_id)
 {
 	return ravb_dma_interrupt(irq, dev_id, RAVB_NC);
 }
+#endif
 
 static int ravb_poll(struct napi_struct *napi, int budget)
 {
@@ -1236,41 +1199,24 @@ static int ravb_poll(struct napi_struct *napi, int budget)
 	int q = napi - priv->napi;
 	int mask = BIT(q);
 	int quota = budget;
-#ifndef CONFIG_ARCH_ESPADA
-	u32 ris0;
-#endif
 	u32 tis;
 	int entry;
+#if defined(CONFIG_ARCH_ESPADA)
 	struct ravb_rx_desc *desc;
+#else  /* CONFIG_ARCH_ESPADA */
+	struct ravb_ex_rx_desc *desc;
+#endif  /* CONFIG_ARCH_ESPADA */
 
 	for (;;) {
-#ifndef CONFIG_ARCH_ESPADA
-		tis = ravb_read(ndev, TIS);
-		ris0 = ravb_read(ndev, RIS0);
-		if (!((ris0 & mask) || (tis & mask)))
-			break;
-
-		/* Processing RX Descriptor Ring */
-		if (ris0 & mask) {
-			/* Clear RX interrupt */
-			ravb_write(ndev, ~(mask | RIS0_RESERVED), RIS0);
-			if (ravb_rx(ndev, &quota, q))
-				goto out;
-		}
-		/* Processing TX Descriptor Ring */
-		if (tis & mask) {
-			spin_lock_irqsave(&priv->lock, flags);
-			/* Clear TX interrupt */
-			ravb_write(ndev, ~(mask | TIS_RESERVED), TIS);
-			ravb_tx_free(ndev, q, true);
-			netif_wake_subqueue(ndev, q);
-			mmiowb();
-			spin_unlock_irqrestore(&priv->lock, flags);
-		}
-#else
 		tis = ravb_read(ndev, TIS);
 		entry = priv->cur_rx[q] % priv->num_rx_ring[q];
-		desc = &priv->rx_ring[q][entry];
+
+#if defined(CONFIG_ARCH_ESPADA)
+			desc = &priv->rx_ring[q][entry];
+#else  /* CONFIG_ARCH_ESPADA */
+			desc = &priv->rx_ring[q][entry];
+#endif  /* CONFIG_ARCH_ESPADA */
+
 		ravb_write(ndev, ~mask, RIS0);
 		if (!((tis & mask) || (desc->die_dt != DT_FEMPTY)))
 			break;
@@ -1290,22 +1236,14 @@ static int ravb_poll(struct napi_struct *napi, int budget)
 			mmiowb();
 			spin_unlock_irqrestore(&priv->lock, flags);
 		}
-#endif
 	}
 
 	napi_complete(napi);
 
 	/* Re-enable RX/TX interrupts */
 	spin_lock_irqsave(&priv->lock, flags);
-	if (priv->chip_id == RCAR_GEN2) {
-		ravb_modify(ndev, RIC0, mask, mask);
-		ravb_modify(ndev, TIC,  mask, mask);
-	} else {
-//		ravb_write(ndev, mask, RIE0);
-//		ravb_write(ndev, mask, TIE);
-		ravb_write(ndev, 0x1, RIE0);
-		ravb_write(ndev, 0x17C01, TIE);
-	}
+	ravb_write(ndev, ravb_read(ndev, RIC0) | mask, RIC0);
+	ravb_write(ndev, ravb_read(ndev, TIC)  | mask,  TIC);
 	mmiowb();
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -1326,36 +1264,7 @@ static void ravb_adjust_link(struct net_device *ndev)
 	struct ravb_private *priv = netdev_priv(ndev);
 	struct phy_device *phydev = ndev->phydev;
 	bool new_state = false;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-#ifndef CONFIG_ARCH_ESPADA
-	/* Disable TX and RX right over here, if E-MAC change is ignored */
-	if (priv->no_avb_link)
-		ravb_rcv_snd_disable(ndev);
-
-	if (phydev->link) {
-		if (phydev->speed != priv->speed) {
-			new_state = true;
-			priv->speed = phydev->speed;
-			ravb_set_rate(ndev);
-		}
-		if (!priv->link) {
-			ravb_modify(ndev, ECMR, ECMR_TXF, 0);
-			new_state = true;
-			priv->link = phydev->link;
-		}
-	} else if (priv->link) {
-		new_state = true;
-		priv->link = 0;
-		priv->speed = 0;
-	}
 
-	/* Enable TX and RX right over here, if E-MAC change is ignored */
-	if (priv->no_avb_link && phydev->link)
-		ravb_rcv_snd_enable(ndev);
-#else
 	if (phydev->link) {
 		if (phydev->duplex != priv->duplex) {
 			new_state = true;
@@ -1384,9 +1293,6 @@ static void ravb_adjust_link(struct net_device *ndev)
 		if (priv->no_avb_link)
 			ravb_rcv_snd_disable(ndev);
 	}
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&priv->lock, flags);
 
 	if (new_state && netif_msg_link(priv))
 		phy_print_status(phydev);
@@ -1404,68 +1310,80 @@ static int ravb_phy_init(struct net_device *ndev)
 	struct ravb_private *priv = netdev_priv(ndev);
 	struct phy_device *phydev;
 	struct device_node *pn;
-	int err;
+#if 0
+	u32 val;
+#endif
 
 	priv->link = 0;
 	priv->speed = 0;
+	priv->duplex = -1;
 
 	/* Try connecting to PHY */
 	pn = of_parse_phandle(np, "phy-handle", 0);
-	if (!pn) {
-		/* In the case of a fixed PHY, the DT node associated
-		 * to the PHY is the Ethernet MAC DT node.
-		 */
-		if (of_phy_is_fixed_link(np)) {
-			err = of_phy_register_fixed_link(np);
-			if (err)
-				return err;
-		}
-		pn = of_node_get(np);
-	}
 	phydev = of_phy_connect(ndev, pn, ravb_adjust_link, 0,
 				priv->phy_interface);
-	of_node_put(pn);
 	if (!phydev) {
 		netdev_err(ndev, "failed to connect PHY\n");
-		err = -ENOENT;
-		goto err_deregister_fixed_link;
+		return -ENOENT;
 	}
 
-	/* This driver only support 10/100Mbit speeds on R-Car H3 ES1.0
+	/* This driver only support 10/100Mbit speeds on Gen3
 	 * at this time.
 	 */
-	if (soc_device_match(r8a7795es10)) {
+	if (priv->chip_id == RCAR_GEN3) {
+		int err;
+
 		err = phy_set_max_speed(phydev, SPEED_100);
 		if (err) {
 			netdev_err(ndev, "failed to limit PHY to 100Mbit/s\n");
-			goto err_phy_disconnect;
+			phy_disconnect(phydev);
+			return err;
 		}
 
 		netdev_info(ndev, "limited PHY to 100Mbit/s\n");
 	}
 
-#ifndef CONFIG_ARCH_ESPADA
 	/* 10BASE is not supported */
+#if defined(CONFIG_ARCH_ESPADA)
+	phydev->drv->suspend = NULL;
+#else  /* CONFIG_ARCH_ESPADA */
 	phydev->supported &= ~PHY_10BT_FEATURES;
+#endif  /* CONFIG_ARCH_ESPADA */
+
+#if 0
+	/* near end loopback test */
+	phy_write_mmd(priv->phydev, 0x28, 0x15, 0xEEEE);
+	phy_write_mmd(priv->phydev, 0x28, 0x16, 0xEEEE);
+	phy_write_mmd(priv->phydev, 0x28, 0x18, 0xEEEE);
+	phy_write_mmd(priv->phydev, 0x28, 0x1b, 0xEEEE2);
+	val = phy_read_mmd(priv->phydev, 0, 0);
+	val |= BIT(14);
+	val |= BIT(8);
+	val |= BIT(6);
+	val &= ~BIT(13);
+	val &= ~BIT(12);
+	phy_write_mmd(priv->phydev, 0, 0, val);
+	val = phy_read_mmd(priv->phydev, 0, 9);
+	val |= BIT(12);
+	val &= ~BIT(11);
+	phy_write_mmd(priv->phydev, 0, 9, val);
 #endif
 
-#ifdef CONFIG_ARCH_ESPADA
-	if (priv->phy_interface == PHY_INTERFACE_MODE_RGMII) {
+	phy_attached_info(phydev);
+
+	priv->phydev = phydev;
+
+#if defined(CONFIG_ARCH_ESPADA)
+	if (priv->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) {
+		ravb_write(ndev, ravb_read(ndev, CXR35)
+			 | CXR35_SEL_MODIN, CXR35);
+	} else if (priv->phy_interface == PHY_INTERFACE_MODE_RGMII) {
 		ravb_write(ndev, 0x3E80000, CXR35);
 	}
-#endif  /* CONFIG_ARCH_ESPADA */
 
-	phy_attached_info(phydev);
+#endif  /* CONFIG_ARCH_ESPADA */
 
 	return 0;
-
-err_phy_disconnect:
-	phy_disconnect(phydev);
-err_deregister_fixed_link:
-	if (of_phy_is_fixed_link(np))
-		of_phy_deregister_fixed_link(np);
-
-	return err;
 }
 
 /* PHY control start function */
@@ -1693,6 +1611,82 @@ static int ravb_set_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
 	return 0;
 }
 
+#if defined(CONFIG_ARCH_ESPADA)
+void ravb_init_eee(struct net_device *ndev)
+{
+	struct ravb_private *priv = netdev_priv(ndev);
+	int val;
+
+	priv->eee_enabled = priv->eee_active = false;
+
+	if (!priv->phydev)
+		return;
+
+	/* Tx Clock Stop Enable  */
+	/* PS1R */
+	val = phy_read_mmd(priv->phydev, MDIO_MMD_PCS, MDIO_STAT1);
+	if (val & RAVB_MDIO_STAT1_CLKSTOP_EN) {
+		ravb_write(ndev,
+			   ravb_read(ndev, LPTXMOD2) | LPTXMOD2_STP_TXC_LPI,
+			   LPTXMOD2);
+	}
+	/* PC1R Rx Clock Stop Enable */
+	val = phy_read_mmd(priv->phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+	phy_write_mmd(priv->phydev, MDIO_MMD_PCS, MDIO_CTRL1, val | MDIO_PCS_CTRL1_CLKSTOP_EN);
+}
+#endif /* CONFIG_ARCH_ESPADA */
+
+static int ravb_get_eee(struct net_device *ndev, struct ethtool_eee *data)
+{
+#if defined(CONFIG_ARCH_ESPADA)
+	struct ravb_private *priv = netdev_priv(ndev);
+
+	if (!priv->phydev)
+		return -ENODEV;
+
+	data->eee_enabled = priv->eee_enabled;
+	data->eee_active = priv->eee_active;
+	data->tx_lpi_enabled = true;
+	if (priv->speed == 1000)
+		data->tx_lpi_timer =
+		(ravb_read(ndev, LPTXGTH1) * LPTXGTH1_RESOLUTION) / RAVB_NS2MS;
+	else
+		data->tx_lpi_timer =
+		(ravb_read(ndev, LPTXMTH1) * LPTXMTH1_RESOLUTION) / RAVB_NS2MS;
+
+	return phy_ethtool_get_eee(priv->phydev, data);
+#endif
+	return 0;
+}
+
+void ravb_write_cxr20(struct net_device *ndev, u32 value)
+{
+	ravb_rcv_snd_disable(ndev);
+	ravb_write(ndev, value, ECMR);
+	ravb_rcv_snd_enable(ndev);
+}
+
+static int ravb_set_eee(struct net_device *ndev, struct ethtool_eee *data)
+{
+#if defined(CONFIG_ARCH_ESPADA)
+	struct ravb_private *priv = netdev_priv(ndev);
+
+	if (!priv->phydev)
+		return -ENODEV;
+
+	priv->eee_enabled = data->eee_enabled;
+	priv->eee_active = data->eee_enabled;
+
+	if (data->eee_enabled)
+		ravb_write_cxr20(ndev, ravb_read(ndev, ECMR) | CXR20_LPM);
+	else
+		ravb_write_cxr20(ndev, ravb_read(ndev, ECMR) & ~CXR20_LPM);
+
+	return phy_ethtool_set_eee(priv->phydev, data);
+#endif
+	return 0;
+}
+
 static const struct ethtool_ops ravb_ethtool_ops = {
 	.nway_reset		= phy_ethtool_nway_reset,
 	.get_msglevel		= ravb_get_msglevel,
@@ -1708,6 +1702,8 @@ static const struct ethtool_ops ravb_ethtool_ops = {
 	.set_link_ksettings	= phy_ethtool_set_link_ksettings,
 	.get_wol		= ravb_get_wol,
 	.set_wol		= ravb_set_wol,
+	.get_eee		= ravb_get_eee,
+	.set_eee		= ravb_set_eee,
 };
 
 static inline int ravb_hook_irq(unsigned int irq, irq_handler_t handler,
@@ -1731,58 +1727,38 @@ static inline int ravb_hook_irq(unsigned int irq, irq_handler_t handler,
 static int ravb_open(struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
-	struct platform_device *pdev = priv->pdev;
-	struct device *dev = &pdev->dev;
 	int error;
 
 	napi_enable(&priv->napi[RAVB_BE]);
 	napi_enable(&priv->napi[RAVB_NC]);
 
-	if (priv->chip_id == RCAR_GEN2 || priv->chip_id == ESPADA) {
-		error = request_irq(ndev->irq, ravb_interrupt, IRQF_SHARED,
-				    ndev->name, ndev);
+	error = request_irq(ndev->irq, ravb_interrupt, IRQF_SHARED, ndev->name,
+			    ndev);
+	if (error) {
+		netdev_err(ndev, "cannot request IRQ\n");
+		goto out_napi_off;
+	}
+
+	if (priv->chip_id == RCAR_GEN3) {
+		error = request_irq(priv->emac_irq, ravb_interrupt,
+				    IRQF_SHARED, ndev->name, ndev);
 		if (error) {
 			netdev_err(ndev, "cannot request IRQ\n");
-			goto out_napi_off;
-		}
-	} else {
-		error = ravb_hook_irq(ndev->irq, ravb_multi_interrupt, ndev,
-				      dev, "ch22:multi");
-		if (error)
-			goto out_napi_off;
-		error = ravb_hook_irq(priv->emac_irq, ravb_emac_interrupt, ndev,
-				      dev, "ch24:emac");
-		if (error)
 			goto out_free_irq;
-		error = ravb_hook_irq(priv->rx_irqs[RAVB_BE], ravb_be_interrupt,
-				      ndev, dev, "ch0:rx_be");
-		if (error)
-			goto out_free_irq_emac;
-		error = ravb_hook_irq(priv->tx_irqs[RAVB_BE], ravb_be_interrupt,
-				      ndev, dev, "ch18:tx_be");
-		if (error)
-			goto out_free_irq_be_rx;
-		error = ravb_hook_irq(priv->rx_irqs[RAVB_NC], ravb_nc_interrupt,
-				      ndev, dev, "ch1:rx_nc");
-		if (error)
-			goto out_free_irq_be_tx;
-		error = ravb_hook_irq(priv->tx_irqs[RAVB_NC], ravb_nc_interrupt,
-				      ndev, dev, "ch19:tx_nc");
-		if (error)
-			goto out_free_irq_nc_rx;
+		}
 	}
 
-	ravb_emac_init(ndev);
 	/* Device init */
 	error = ravb_dmac_init(ndev);
 	if (error)
-		goto out_free_irq_nc_tx;
+		goto out_free_irq2;
+	ravb_emac_init(ndev);
 
-#ifndef CONFIG_ARCH_ESPADA
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* Initialise PTP Clock driver */
-	if (priv->chip_id == RCAR_GEN2)
-		ravb_ptp_init(ndev, priv->pdev);
-#endif
+	ravb_ptp_init(ndev, priv->pdev);
+#endif /* CONFIG_ARCH_ESPADA */
 
 	netif_tx_start_all_queues(ndev);
 
@@ -1791,47 +1767,25 @@ static int ravb_open(struct net_device *ndev)
 	if (error)
 		goto out_ptp_stop;
 
+#if defined(CONFIG_ARCH_ESPADA)
+	priv->wol_ecspir = 0;
+	ravb_init_eee(ndev);
+	priv->do_suspend = RAVB_NOT_SUSPEND;
+#endif /* CONFIG_ARCH_ESPADA */
+
 	return 0;
 
 out_ptp_stop:
-#ifndef CONFIG_ARCH_ESPADA
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* Stop PTP Clock driver */
-	if (priv->chip_id == RCAR_GEN2)
-		ravb_ptp_stop(ndev);
-#else
-#endif
-out_free_irq_nc_tx:
-#ifndef CONFIG_ARCH_ESPADA
-	if (priv->chip_id == RCAR_GEN2)
-		goto out_free_irq;
-	free_irq(priv->tx_irqs[RAVB_NC], ndev);
-#else
-#endif
-out_free_irq_nc_rx:
-#ifndef CONFIG_ARCH_ESPADA
-	free_irq(priv->rx_irqs[RAVB_NC], ndev);
-#else
-#endif
-out_free_irq_be_tx:
-#ifndef CONFIG_ARCH_ESPADA
-	free_irq(priv->tx_irqs[RAVB_BE], ndev);
-#else
-#endif
-out_free_irq_be_rx:
-#ifndef CONFIG_ARCH_ESPADA
-	free_irq(priv->rx_irqs[RAVB_BE], ndev);
-#else
-#endif
-out_free_irq_emac:
-#ifndef CONFIG_ARCH_ESPADA
-	free_irq(priv->emac_irq, ndev);
-#else
-#endif
+	ravb_ptp_stop(ndev);
+#endif /* CONFIG_ARCH_ESPADA */
+out_free_irq2:
+	if (priv->chip_id == RCAR_GEN3)
+		free_irq(priv->emac_irq, ndev);
 out_free_irq:
-#ifndef CONFIG_ARCH_ESPADA
 	free_irq(ndev->irq, ndev);
-#else
-#endif
 out_napi_off:
 	napi_disable(&priv->napi[RAVB_NC]);
 	napi_disable(&priv->napi[RAVB_BE]);
@@ -1858,48 +1812,30 @@ static void ravb_tx_timeout_work(struct work_struct *work)
 	struct ravb_private *priv = container_of(work, struct ravb_private,
 						 work);
 	struct net_device *ndev = priv->ndev;
-	int error;
 
 	netif_tx_stop_all_queues(ndev);
 
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* Stop PTP Clock driver */
-	if (priv->chip_id == RCAR_GEN2)
-		ravb_ptp_stop(ndev);
+	ravb_ptp_stop(ndev);
+#endif /* CONFIG_ARCH_ESPADA */
 
 	/* Wait for DMA stopping */
-	if (ravb_stop_dma(ndev)) {
-		/* If ravb_stop_dma() fails, the hardware is still operating
-		 * for TX and/or RX. So, this should not call the following
-		 * functions because ravb_dmac_init() is possible to fail too.
-		 * Also, this should not retry ravb_stop_dma() again and again
-		 * here because it's possible to wait forever. So, this just
-		 * re-enables the TX and RX and skip the following
-		 * re-initialization procedure.
-		 */
-		ravb_rcv_snd_enable(ndev);
-		goto out;
-	}
+	ravb_stop_dma(ndev);
 
 	ravb_ring_free(ndev, RAVB_BE);
 	ravb_ring_free(ndev, RAVB_NC);
 
 	/* Device init */
-	error = ravb_dmac_init(ndev);
-	if (error) {
-		/* If ravb_dmac_init() fails, descriptors are freed. So, this
-		 * should return here to avoid re-enabling the TX and RX in
-		 * ravb_emac_init().
-		 */
-		netdev_err(ndev, "%s: ravb_dmac_init() failed, error %d\n",
-			   __func__, error);
-		return;
-	}
+	ravb_dmac_init(ndev);
 	ravb_emac_init(ndev);
 
-out:
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* Initialise PTP Clock driver */
-	if (priv->chip_id == RCAR_GEN2)
-		ravb_ptp_init(ndev, priv->pdev);
+	ravb_ptp_init(ndev, priv->pdev);
+#endif /* CONFIG_ARCH_ESPADA */
 
 	netif_tx_start_all_queues(ndev);
 }
@@ -1908,9 +1844,11 @@ static void ravb_tx_timeout_work(struct work_struct *work)
 static netdev_tx_t ravb_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
-	int num_tx_desc = priv->num_tx_desc;
 	u16 q = skb_get_queue_mapping(skb);
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	struct ravb_tstamp_skb *ts_skb;
+#endif /* CONFIG_ARCH_ESPADA */
 	struct ravb_tx_desc *desc;
 	unsigned long flags;
 	u32 dma_addr;
@@ -1919,107 +1857,103 @@ static netdev_tx_t ravb_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	u32 len;
 
 	spin_lock_irqsave(&priv->lock, flags);
+
+#if defined(CONFIG_ARCH_ESPADA)
+	if (priv->do_suspend == RAVB_SUSPEND) {
+#if 0
+		espada_gnetsetting_set_gberam_suspend(
+			espada_gnetsetting_get_gberam_suspend() 
+			| RAVB_SET_SUSPEND_ROLLBACK);
+#endif
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return NETDEV_TX_BUSY;
+	}
+#endif
+
 	if (priv->cur_tx[q] - priv->dirty_tx[q] > (priv->num_tx_ring[q] - 1) *
-	    num_tx_desc) {
+	    NUM_TX_DESC) {
 		netif_err(priv, tx_queued, ndev,
 			  "still transmitting with the full ring!\n");
 		netif_stop_subqueue(ndev, q);
 		spin_unlock_irqrestore(&priv->lock, flags);
 		return NETDEV_TX_BUSY;
 	}
+	entry = priv->cur_tx[q] % (priv->num_tx_ring[q] * NUM_TX_DESC);
+	priv->tx_skb[q][entry / NUM_TX_DESC] = skb;
 
 	if (skb_put_padto(skb, ETH_ZLEN))
-		goto exit;
-
-	entry = priv->cur_tx[q] % (priv->num_tx_ring[q] * num_tx_desc);
-	priv->tx_skb[q][entry / num_tx_desc] = skb;
-
-	if (num_tx_desc > 1) {
-		buffer = PTR_ALIGN(priv->tx_align[q], DPTR_ALIGN) +
-			 entry / num_tx_desc * DPTR_ALIGN;
-		len = PTR_ALIGN(skb->data, DPTR_ALIGN) - skb->data;
-
-		/* Zero length DMA descriptors are problematic as they seem
-		 * to terminate DMA transfers. Avoid them by simply using a
-		 * length of DPTR_ALIGN (4) when skb data is aligned to
-		 * DPTR_ALIGN.
-		 *
-		 * As skb is guaranteed to have at least ETH_ZLEN (60)
-		 * bytes of data by the call to skb_put_padto() above this
-		 * is safe with respect to both the length of the first DMA
-		 * descriptor (len) overflowing the available data and the
-		 * length of the second DMA descriptor (skb->len - len)
-		 * being negative.
-		 */
-		if (len == 0)
-			len = DPTR_ALIGN;
+		goto drop;
+
+	buffer = PTR_ALIGN(priv->tx_align[q], DPTR_ALIGN) +
+		 entry / NUM_TX_DESC * DPTR_ALIGN;
+	len = PTR_ALIGN(skb->data, DPTR_ALIGN) - skb->data;
+	/* Zero length DMA descriptors are problematic as they seem to
+	 * terminate DMA transfers. Avoid them by simply using a length of
+	 * DPTR_ALIGN (4) when skb data is aligned to DPTR_ALIGN.
+	 *
+	 * As skb is guaranteed to have at least ETH_ZLEN (60) bytes of
+	 * data by the call to skb_put_padto() above this is safe with
+	 * respect to both the length of the first DMA descriptor (len)
+	 * overflowing the available data and the length of the second DMA
+	 * descriptor (skb->len - len) being negative.
+	 */
+	if (len == 0)
+		len = DPTR_ALIGN;
 
-		memcpy(buffer, skb->data, len);
-		dma_addr = dma_map_single(ndev->dev.parent, buffer, len,
-					  DMA_TO_DEVICE);
-		if (dma_mapping_error(ndev->dev.parent, dma_addr))
-			goto drop;
+	memcpy(buffer, skb->data, len);
+	dma_addr = dma_map_single(ndev->dev.parent, buffer, len, DMA_TO_DEVICE);
+	if (dma_mapping_error(ndev->dev.parent, dma_addr))
+		goto drop;
 
-		desc = &priv->tx_ring[q][entry];
-		desc->ds_tagl = cpu_to_le16(len);
-		desc->dptr = cpu_to_le32(dma_addr);
+	desc = &priv->tx_ring[q][entry];
+	desc->ds_tagl = cpu_to_le16(len);
+	desc->dptr = cpu_to_le32(dma_addr);
 
-		buffer = skb->data + len;
-		len = skb->len - len;
-		dma_addr = dma_map_single(ndev->dev.parent, buffer, len,
-					  DMA_TO_DEVICE);
-		if (dma_mapping_error(ndev->dev.parent, dma_addr))
-			goto unmap;
+	buffer = skb->data + len;
+	len = skb->len - len;
+	dma_addr = dma_map_single(ndev->dev.parent, buffer, len, DMA_TO_DEVICE);
+	if (dma_mapping_error(ndev->dev.parent, dma_addr))
+		goto unmap;
 
-		desc++;
-	} else {
-		desc = &priv->tx_ring[q][entry];
-		len = skb->len;
-		dma_addr = dma_map_single(ndev->dev.parent, skb->data, skb->len,
-					  DMA_TO_DEVICE);
-		if (dma_mapping_error(ndev->dev.parent, dma_addr))
-			goto drop;
-	}
+	desc++;
 	desc->ds_tagl = cpu_to_le16(len);
 	desc->dptr = cpu_to_le32(dma_addr);
 
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* TX timestamp required */
 	if (q == RAVB_NC) {
 		ts_skb = kmalloc(sizeof(*ts_skb), GFP_ATOMIC);
 		if (!ts_skb) {
-			if (num_tx_desc > 1) {
-				desc--;
-				dma_unmap_single(ndev->dev.parent, dma_addr,
-						 len, DMA_TO_DEVICE);
-			}
+			desc--;
+			dma_unmap_single(ndev->dev.parent, dma_addr, len,
+					 DMA_TO_DEVICE);
 			goto unmap;
 		}
-		ts_skb->skb = skb_get(skb);
+		ts_skb->skb = skb;
 		ts_skb->tag = priv->ts_skb_tag++;
 		priv->ts_skb_tag &= 0x3ff;
 		list_add_tail(&ts_skb->list, &priv->ts_skb_list);
 
 		/* TAG and timestamp required flag */
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+		skb_tx_timestamp(skb);
 		desc->tagh_tsr = (ts_skb->tag >> 4) | TX_TSR;
-		desc->ds_tagl |= cpu_to_le16(ts_skb->tag << 12);
+		desc->ds_tagl |= le16_to_cpu(ts_skb->tag << 12);
 	}
+#endif /* CONFIG_ARCH_ESPADA */
 
-	skb_tx_timestamp(skb);
 	/* Descriptor type must be set after all the above writes */
 	dma_wmb();
-	if (num_tx_desc > 1) {
-		desc->die_dt = DT_FEND;
-		desc--;
-		desc->die_dt = DT_FSTART;
-	} else {
-		desc->die_dt = DT_FSINGLE;
-	}
-	ravb_modify(ndev, TCCR, TCCR_TSRQ0 << q, TCCR_TSRQ0 << q);
+	desc->die_dt = DT_FEND;
+	desc--;
+	desc->die_dt = DT_FSTART;
+
+	ravb_write(ndev, ravb_read(ndev, TCCR) | (TCCR_TSRQ0 << q), TCCR);
 
-	priv->cur_tx[q] += num_tx_desc;
+	priv->cur_tx[q] += NUM_TX_DESC;
 	if (priv->cur_tx[q] - priv->dirty_tx[q] >
-	    (priv->num_tx_ring[q] - 1) * num_tx_desc &&
+	    (priv->num_tx_ring[q] - 1) * NUM_TX_DESC &&
 	    !ravb_tx_free(ndev, q, true))
 		netif_stop_subqueue(ndev, q);
 
@@ -2033,13 +1967,13 @@ static netdev_tx_t ravb_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 			 le16_to_cpu(desc->ds_tagl), DMA_TO_DEVICE);
 drop:
 	dev_kfree_skb_any(skb);
-	priv->tx_skb[q][entry / num_tx_desc] = NULL;
+	priv->tx_skb[q][entry / NUM_TX_DESC] = NULL;
 	goto exit;
 }
 
 static u16 ravb_select_queue(struct net_device *ndev, struct sk_buff *skb,
-			     struct net_device *sb_dev,
-			     select_queue_fallback_t fallback)
+				struct net_device *sb_dev,
+				select_queue_fallback_t fallback)
 {
 	/* If skb needs TX timestamp, it is handled in network control queue */
 	return (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) ? RAVB_NC :
@@ -2092,10 +2026,15 @@ static void ravb_set_rx_mode(struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
 	unsigned long flags;
+	u32 ecmr;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	ravb_modify(ndev, ECMR, ECMR_PRM,
-		    ndev->flags & IFF_PROMISC ? ECMR_PRM : 0);
+	ecmr = ravb_read(ndev, ECMR);
+	if (ndev->flags & IFF_PROMISC)
+		ecmr |=  ECMR_PRM;
+	else
+		ecmr &= ~ECMR_PRM;
+	ravb_write(ndev, ecmr, ECMR);
 	mmiowb();
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
@@ -2103,7 +2042,6 @@ static void ravb_set_rx_mode(struct net_device *ndev)
 /* Device close function for Ethernet AVB */
 static int ravb_close(struct net_device *ndev)
 {
-	struct device_node *np = ndev->dev.parent->of_node;
 	struct ravb_private *priv = netdev_priv(ndev);
 	struct ravb_tstamp_skb *ts_skb, *ts_skb2;
 
@@ -2111,12 +2049,15 @@ static int ravb_close(struct net_device *ndev)
 
 	/* Disable interrupts by clearing the interrupt masks. */
 	ravb_write(ndev, 0, RIC0);
+	ravb_write(ndev, 0, RIC1);
 	ravb_write(ndev, 0, RIC2);
 	ravb_write(ndev, 0, TIC);
 
+#if defined(CONFIG_ARCH_ESPADA)
+#else /* CONFIG_ARCH_ESPADA */
 	/* Stop PTP Clock driver */
-	if (priv->chip_id == RCAR_GEN2)
-		ravb_ptp_stop(ndev);
+	ravb_ptp_stop(ndev);
+#endif /* CONFIG_ARCH_ESPADA */
 
 	/* Set the config mode to stop the AVB-DMAC's processes */
 	if (ravb_stop_dma(ndev) < 0)
@@ -2126,25 +2067,16 @@ static int ravb_close(struct net_device *ndev)
 	/* Clear the timestamp list */
 	list_for_each_entry_safe(ts_skb, ts_skb2, &priv->ts_skb_list, list) {
 		list_del(&ts_skb->list);
-		kfree_skb(ts_skb->skb);
 		kfree(ts_skb);
 	}
 
 	/* PHY disconnect */
-	if (ndev->phydev) {
-		phy_stop(ndev->phydev);
-		phy_disconnect(ndev->phydev);
-		if (of_phy_is_fixed_link(np))
-			of_phy_deregister_fixed_link(np);
-	}
-
-	if (priv->chip_id != RCAR_GEN2) {
-		free_irq(priv->tx_irqs[RAVB_NC], ndev);
-		free_irq(priv->rx_irqs[RAVB_NC], ndev);
-		free_irq(priv->tx_irqs[RAVB_BE], ndev);
-		free_irq(priv->rx_irqs[RAVB_BE], ndev);
-		free_irq(priv->emac_irq, ndev);
+	if (priv->phydev) {
+		phy_stop(priv->phydev);
+		phy_disconnect(priv->phydev);
+		priv->phydev = NULL;
 	}
+
 	free_irq(ndev->irq, ndev);
 
 	napi_disable(&priv->napi[RAVB_NC]);
@@ -2428,12 +2360,12 @@ static void ravb_set_delay_mode(struct net_device *ndev)
 static int ravb_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
 	struct ravb_private *priv;
 	enum ravb_chip_id chip_id;
 	struct net_device *ndev;
 	int error, irq, q;
 	struct resource *res;
-	int i;
 
 	if (!np) {
 		dev_err(&pdev->dev,
@@ -2453,13 +2385,12 @@ static int ravb_probe(struct platform_device *pdev)
 	if (!ndev)
 		return -ENOMEM;
 
-	ndev->features = NETIF_F_RXCSUM;
-	ndev->hw_features |= (NETIF_F_HW_CSUM | NETIF_F_RXCSUM);
-
 	/* The Ether-specific entries in the device structure. */
 	ndev->base_addr = res->start;
+	ndev->dma = -1;
 
-	chip_id = (enum ravb_chip_id)of_device_get_match_data(&pdev->dev);
+	match = of_match_device(of_match_ptr(ravb_match_table), &pdev->dev);
+	chip_id = (enum ravb_chip_id)match->data;
 
 	if (chip_id == RCAR_GEN3)
 		irq = platform_get_irq_byname(pdev, "ch22");
@@ -2502,22 +2433,6 @@ static int ravb_probe(struct platform_device *pdev)
 			goto out_release;
 		}
 		priv->emac_irq = irq;
-		for (i = 0; i < NUM_RX_QUEUE; i++) {
-			irq = platform_get_irq_byname(pdev, ravb_rx_irqs[i]);
-			if (irq < 0) {
-				error = irq;
-				goto out_release;
-			}
-			priv->rx_irqs[i] = irq;
-		}
-		for (i = 0; i < NUM_TX_QUEUE; i++) {
-			irq = platform_get_irq_byname(pdev, ravb_tx_irqs[i]);
-			if (irq < 0) {
-				error = irq;
-				goto out_release;
-			}
-			priv->tx_irqs[i] = irq;
-		}
 	}
 
 	priv->chip_id = chip_id;
@@ -2538,35 +2453,32 @@ static int ravb_probe(struct platform_device *pdev)
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_get_sync(&pdev->dev);
 
-	ndev->max_mtu = 2048 - (ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN);
-	ndev->min_mtu = ETH_MIN_MTU;
-
-	priv->num_tx_desc = chip_id == RCAR_GEN2 ?
-		NUM_TX_DESC_GEN2 : NUM_TX_DESC_GEN3;
-
 	/* Set function */
 	ndev->netdev_ops = &ravb_netdev_ops;
 	ndev->ethtool_ops = &ravb_ethtool_ops;
 
 	/* Set AVB config mode */
-	ravb_set_config_mode(ndev);
+	ravb_write(ndev, (ravb_read(ndev, CCC) & ~CCC_OPC) | CCC_OPC_CONFIG,
+		   CCC);
+
+#if defined(CONFIG_ARCH_ESPADA)
+	ndev->hw_features |= (NETIF_F_HW_CSUM | NETIF_F_RXCSUM);
+#else
+	/* Set CSEL value */
+	ravb_write(ndev, (ravb_read(ndev, CCC) & ~CCC_CSEL) | CCC_CSEL_HPB,
+		   CCC);
 
-#ifndef CONFIG_ARCH_ESPADA
 	/* Set GTI value */
-	error = ravb_set_gti(ndev);
-	if (error)
-		goto out_release;
+	ravb_write(ndev, ((1000 << 20) / 130) & GTI_TIV, GTI);
 
 	/* Request GTI loading */
-	ravb_modify(ndev, GCCR, GCCR_LTI, GCCR_LTI);
-
-	if (priv->chip_id != RCAR_GEN2)
-		ravb_set_delay_mode(ndev);
+	ravb_write(ndev, ravb_read(ndev, GCCR) | GCCR_LTI, GCCR);
 #endif
 
 	/* Allocate descriptor base address table */
 	priv->desc_bat_size = sizeof(struct ravb_desc) * DBAT_ENTRY_NUM;
-	priv->desc_bat = dma_alloc_coherent(ndev->dev.parent, priv->desc_bat_size,
+	priv->desc_bat = dma_alloc_coherent(ndev->dev.parent,
+					    priv->desc_bat_size,
 					    &priv->desc_bat_dma, GFP_KERNEL);
 	if (!priv->desc_bat) {
 		dev_err(&pdev->dev,
@@ -2582,17 +2494,28 @@ static int ravb_probe(struct platform_device *pdev)
 	/* Initialise HW timestamp list */
 	INIT_LIST_HEAD(&priv->ts_skb_list);
 
-#ifdef CONFIG_ARCH_ESPADA
-	/* Initialise PTP Clock driver */
-	if (chip_id != RCAR_GEN2)
-		ravb_ptp_init(ndev, pdev);
-#endif
-
 	/* Debug message level */
 	priv->msg_enable = RAVB_DEF_MSG_ENABLE;
 
 	/* Read and set MAC address */
+#if 0
+	/* MAC address set from SCP Config */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!res) {
+		dev_err(&pdev->dev, "invalid resource\n");
+		error = -EINVAL;
+		goto out_release;
+	}
+
+	priv->gbe_addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->addr)) {
+		error = PTR_ERR(priv->addr);
+		goto out_release;
+	}
+	ravb_set_mac_address_fromgberam(ndev);
+#else
 	ravb_read_mac_address(ndev, of_get_mac_address(np));
+#endif
 	if (!is_valid_ether_addr(ndev->dev_addr)) {
 		dev_warn(&pdev->dev,
 			 "no valid MAC address supplied, using a random one\n");
@@ -2614,8 +2537,6 @@ static int ravb_probe(struct platform_device *pdev)
 	if (error)
 		goto out_napi_del;
 
-	device_set_wakeup_capable(&pdev->dev, 1);
-
 	/* Print device information */
 	netdev_info(ndev, "Base address at %#x, %pM, IRQ %d.\n",
 		    (u32)ndev->base_addr, ndev->dev_addr, ndev->irq);
@@ -2631,12 +2552,9 @@ static int ravb_probe(struct platform_device *pdev)
 out_dma_free:
 	dma_free_coherent(ndev->dev.parent, priv->desc_bat_size, priv->desc_bat,
 			  priv->desc_bat_dma);
-
-	/* Stop PTP Clock driver */
-	if (chip_id != RCAR_GEN2)
-		ravb_ptp_stop(ndev);
 out_release:
-	free_netdev(ndev);
+	if (ndev)
+		free_netdev(ndev);
 
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -2648,10 +2566,6 @@ static int ravb_remove(struct platform_device *pdev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct ravb_private *priv = netdev_priv(ndev);
 
-	/* Stop PTP Clock driver */
-	if (priv->chip_id != RCAR_GEN2)
-		ravb_ptp_stop(ndev);
-
 	dma_free_coherent(ndev->dev.parent, priv->desc_bat_size, priv->desc_bat,
 			  priv->desc_bat_dma);
 	/* Set reset mode */
-- 
2.7.4


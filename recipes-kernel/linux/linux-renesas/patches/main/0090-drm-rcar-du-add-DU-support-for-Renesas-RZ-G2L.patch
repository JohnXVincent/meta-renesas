From ff5b3db6a10607fd0c214a5dd49a33ce8d1a3d50 Mon Sep 17 00:00:00 2001
From: Hien Huynh <hien.huynh.px@renesas.com>
Date: Mon, 1 Mar 2021 13:25:04 +0700
Subject: [PATCH 090/135] drm: rcar-du: add DU support for Renesas RZ/G2L

This commit adds inital DU support for Renesas RZ/G2L.
Including registers description of RZ/G2L DU.

Signed-off-by: Hien Huynh <hien.huynh.px@renesas.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c  | 126 +++++++++++++++++++++++---------
 drivers/gpu/drm/rcar-du/rcar_du_group.c |  17 ++++-
 drivers/gpu/drm/rcar-du/rcar_du_of.c    |   9 ++-
 drivers/gpu/drm/rcar-du/rcar_du_plane.c |   8 +-
 drivers/gpu/drm/rcar-du/rcar_du_regs.h  |  52 +++++++++++++
 drivers/gpu/drm/rcar-du/rcar_du_vsp.c   |   7 +-
 6 files changed, 175 insertions(+), 44 deletions(-)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index a2a4bc7..78ddbca 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -221,6 +221,40 @@ static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 	u32 dsmr;
 	u32 escr;
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L)) {
+		u32 ditr0, ditr1, ditr2, ditr3, ditr4, ditr5, pbcr0;
+
+		ditr0 = (DU_DITR0_DEMD_HIGH
+		| ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? DU_DITR0_VSPOL : 0)
+		| ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? DU_DITR0_HSPOL : 0));
+
+		ditr1 = DU_DITR1_VSA(mode->vsync_end - mode->vsync_start)
+		      | DU_DITR1_VACTIVE(mode->vdisplay);
+
+		ditr2 = DU_DITR2_VBP(mode->vtotal - mode->vsync_end)
+		      | DU_DITR2_VFP(mode->vsync_start - mode->vdisplay);
+
+		ditr3 = DU_DITR3_HSA(mode->hsync_end - mode->hsync_start)
+		      | DU_DITR3_HACTIVE(mode->hdisplay);
+
+		ditr4 = DU_DITR4_HBP(mode->htotal - mode->hsync_end)
+		      | DU_DITR4_HFP(mode->hsync_start - mode->hdisplay);
+
+		ditr5 = DU_DITR5_VSFT(0) | DU_DITR5_HSFT(0);
+
+		pbcr0 = DU_PBCR0_PB_DEP(0x1F);
+
+		rcar_du_write(rcdu, DU_DITR0, ditr0);
+		rcar_du_write(rcdu, DU_DITR1, ditr1);
+		rcar_du_write(rcdu, DU_DITR2, ditr2);
+		rcar_du_write(rcdu, DU_DITR3, ditr3);
+		rcar_du_write(rcdu, DU_DITR4, ditr4);
+		rcar_du_write(rcdu, DU_DITR5, ditr5);
+		rcar_du_write(rcdu, DU_PBCR0, pbcr0);
+
+		return;
+	}
+
 	if (rcdu->info->dpll_mask & (1 << rcrtc->index)) {
 		unsigned long target = mode_clock;
 		struct dpll_info dpll = { 0 };
@@ -346,6 +380,9 @@ static void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)
 	unsigned int i;
 	u32 dspr = 0;
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		return;
+
 	for (i = 0; i < rcrtc->group->num_planes; ++i) {
 		struct rcar_du_plane *plane = &rcrtc->group->planes[i];
 		unsigned int j;
@@ -486,16 +523,24 @@ static void rcar_du_crtc_wait_page_flip(struct rcar_du_crtc *rcrtc)
 
 static void rcar_du_crtc_setup(struct rcar_du_crtc *rcrtc)
 {
-	/* Set display off and background to black */
-	rcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));
-	rcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));
+	struct rcar_du_device *rcdu = rcrtc->group->dev;
 
-	/* Configure display timings and output routing */
-	rcar_du_crtc_set_display_timing(rcrtc);
-	rcar_du_group_set_routing(rcrtc->group);
+	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L)) {
+		/* Set display off and background to black */
+		rcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));
+		rcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));
 
-	/* Start with all planes disabled. */
-	rcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR, 0);
+		/* Configure display timings and output routing */
+		rcar_du_crtc_set_display_timing(rcrtc);
+		rcar_du_group_set_routing(rcrtc->group);
+
+		/* Start with all planes disabled. */
+		rcar_du_group_write(rcrtc->group,
+				    rcrtc->index % 2 ? DS2PR : DS1PR, 0);
+	} else {
+		/* Configure display timings and output routing */
+		rcar_du_crtc_set_display_timing(rcrtc);
+	}
 
 	/* Enable the VSP compositor. */
 	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
@@ -552,17 +597,20 @@ static void rcar_du_crtc_put(struct rcar_du_crtc *rcrtc)
 
 static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 {
+	struct rcar_du_device *rcdu = rcrtc->group->dev;
 	bool interlaced;
 
-	/*
-	 * Select master sync mode. This enables display operation in master
-	 * sync mode (with the HSYNC and VSYNC signals configured as outputs and
-	 * actively driven).
-	 */
-	interlaced = rcrtc->crtc.mode.flags & DRM_MODE_FLAG_INTERLACE;
-	rcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_TVM_MASK | DSYSR_SCM_MASK,
-				   (interlaced ? DSYSR_SCM_INT_VIDEO : 0) |
-				   DSYSR_TVM_MASTER);
+	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L)) {
+		/*
+		 * Select master sync mode. This enables display operation in master
+		 * sync mode (with the HSYNC and VSYNC signals configured as outputs and
+		 * actively driven).
+		 */
+		interlaced = rcrtc->crtc.mode.flags & DRM_MODE_FLAG_INTERLACE;
+		rcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_TVM_MASK | DSYSR_SCM_MASK,
+					   (interlaced ? DSYSR_SCM_INT_VIDEO : 0) |
+					   DSYSR_TVM_MASTER);
+	}
 
 	rcar_du_group_start_stop(rcrtc->group, true);
 }
@@ -1000,32 +1048,38 @@ static irqreturn_t rcar_du_crtc_irq(int irq, void *arg)
 	irqreturn_t ret = IRQ_NONE;
 	u32 status;
 
-	spin_lock(&rcrtc->vblank_lock);
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L)) {
+		status = rcar_du_crtc_read(rcrtc, DU_MCR0);
+		rcar_du_crtc_write(rcrtc, DU_MCR0, DU_MCR0_PB_CLR & status);
+		ret = IRQ_HANDLED;
+	} else {
+		spin_lock(&rcrtc->vblank_lock);
 
-	status = rcar_du_crtc_read(rcrtc, DSSR);
-	rcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);
+		status = rcar_du_crtc_read(rcrtc, DSSR);
+		rcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);
 
-	if (status & DSSR_VBK) {
-		/*
-		 * Wake up the vblank wait if the counter reaches 0. This must
-		 * be protected by the vblank_lock to avoid races in
-		 * rcar_du_crtc_disable_planes().
-		 */
-		if (rcrtc->vblank_count) {
-			if (--rcrtc->vblank_count == 0)
-				wake_up(&rcrtc->vblank_wait);
+		if (status & DSSR_VBK) {
+			/*
+			 * Wake up the vblank wait if the counter reaches 0. This must
+			 * be protected by the vblank_lock to avoid races in
+			 * rcar_du_crtc_disable_planes().
+			 */
+			if (rcrtc->vblank_count) {
+				if (--rcrtc->vblank_count == 0)
+					wake_up(&rcrtc->vblank_wait);
+			}
 		}
-	}
 
-	spin_unlock(&rcrtc->vblank_lock);
+		spin_unlock(&rcrtc->vblank_lock);
 
-	if (status & DSSR_VBK) {
-		if (rcdu->info->gen < 3) {
-			drm_crtc_handle_vblank(&rcrtc->crtc);
-			rcar_du_crtc_finish_page_flip(rcrtc);
-		}
+		if (status & DSSR_VBK) {
+			if (rcdu->info->gen < 3) {
+				drm_crtc_handle_vblank(&rcrtc->crtc);
+				rcar_du_crtc_finish_page_flip(rcrtc);
+			}
 
 		ret = IRQ_HANDLED;
+		}
 	}
 
 	return ret;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_group.c b/drivers/gpu/drm/rcar-du/rcar_du_group.c
index 3e87fbf..3909818 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_group.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_group.c
@@ -41,7 +41,9 @@ u32 rcar_du_group_read(struct rcar_du_group *rgrp, u32 reg)
 
 void rcar_du_group_write(struct rcar_du_group *rgrp, u32 reg, u32 data)
 {
-	rcar_du_write(rgrp->dev, rgrp->mmio_offset + reg, data);
+	struct rcar_du_device *rcdu = rgrp->dev;
+	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		rcar_du_write(rgrp->dev, rgrp->mmio_offset + reg, data);
 }
 
 static void rcar_du_group_setup_pins(struct rcar_du_group *rgrp)
@@ -96,6 +98,9 @@ static void rcar_du_group_setup_didsr(struct rcar_du_group *rgrp)
 	unsigned int i;
 	u32 didsr;
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		return;
+
 	/*
 	 * Configure input dot clock routing with a hardcoded configuration. If
 	 * the DU channel can use the LVDS encoder output clock as the dot
@@ -140,6 +145,9 @@ static void rcar_du_group_setup(struct rcar_du_group *rgrp)
 {
 	struct rcar_du_device *rcdu = rgrp->dev;
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		return;
+
 	/* Enable extended features */
 	rcar_du_group_write(rgrp, DEFR, DEFR_CODE | DEFR_DEFE);
 	if (rcdu->info->gen < 3) {
@@ -208,8 +216,11 @@ static void __rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start)
 {
 	struct rcar_du_crtc *rcrtc = &rgrp->dev->crtcs[rgrp->index * 2];
 
-	rcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_DRES | DSYSR_DEN,
-				   start ? DSYSR_DEN : DSYSR_DRES);
+	if (rcar_du_has(rgrp->dev, RCAR_DU_FEATURE_RZG2L))
+		rcar_du_write(rgrp->dev, DU_MCR0, start ? DU_MCR0_DI_EN : 0);
+	else
+		rcar_du_crtc_dsysr_clr_set(rcrtc, DSYSR_DRES | DSYSR_DEN,
+					   start ? DSYSR_DEN : DSYSR_DRES);
 }
 
 void rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start)
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_of.c b/drivers/gpu/drm/rcar-du/rcar_du_of.c
index afef696..47deacf 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_of.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_of.c
@@ -15,6 +15,7 @@
 #include <linux/of_fdt.h>
 #include <linux/of_graph.h>
 #include <linux/slab.h>
+#include <linux/sys_soc.h>
 
 #include "rcar_du_crtc.h"
 #include "rcar_du_drv.h"
@@ -317,7 +318,13 @@ static void __init rcar_du_of_lvds_patch(const struct of_device_id *of_ids)
 	of_node_put(du_node);
 }
 
+static const struct soc_device_attribute rzg2l_match[] = {
+	{ .family = "RZ/G2L" },
+	{ /* sentinel*/ }
+};
+
 void __init rcar_du_of_init(const struct of_device_id *of_ids)
 {
-	rcar_du_of_lvds_patch(of_ids);
+	if (!soc_device_match(rzg2l_match))
+		rcar_du_of_lvds_patch(of_ids);
 }
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_plane.c b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
index c20f7ed..a840bd1 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_plane.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
@@ -325,8 +325,12 @@ int rcar_du_atomic_check_planes(struct drm_device *dev,
 static void rcar_du_plane_write(struct rcar_du_group *rgrp,
 				unsigned int index, u32 reg, u32 data)
 {
-	rcar_du_write(rgrp->dev, rgrp->mmio_offset + index * PLANE_OFF + reg,
-		      data);
+	struct rcar_du_device *rcdu = rgrp->dev;
+
+	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		rcar_du_write(rgrp->dev,
+			      rgrp->mmio_offset + index * PLANE_OFF + reg,
+			      data);
 }
 
 static void rcar_du_plane_setup_scanout(struct rcar_du_group *rgrp,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_regs.h b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
index 9dfd220..38d11f7 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
@@ -19,6 +19,58 @@
 #define DU3_REG_OFFSET		0x70000
 
 /* -----------------------------------------------------------------------------
+ * RZ/G2L Display Registers
+ */
+
+#define DU_MCR0			0x00
+#define DU_MCR0_DPI_OE		BIT(0)
+#define DU_MCR0_DI_EN		BIT(8)
+#define DU_MCR0_PB_CLR		BIT(16)
+
+#define DU_MSR0			0x04
+#define DU_MSR0_ST_DI_BSY	BIT(8)
+#define DU_MSR0_ST_PB_WFULL	BIT(16)
+#define DU_MSR0_ST_PB_WINIT	BIT(18)
+#define DU_MSR0_ST_PB_REMPTY	BIT(20)
+#define DU_MSR0_ST_PB_RUF	BIT(21)
+#define DU_MSR0_ST_PB_RINIT	BIT(22)
+
+#define DU_MSR1			0x08
+
+#define DU_IMR0			0x0C
+#define DU_MSR0_IM_PB_RUF	BIT(0)
+
+#define DU_DITR0		0x10
+#define DU_DITR0_DPI_CLKMD	BIT(0)
+#define DU_DITR0_DEMD_LOW	0x0
+#define DU_DITR0_DEMD_HIGH	BIT(8) | BIT(9)
+#define DU_DITR0_VSPOL		BIT(16)
+#define DU_DITR0_HSPOL		BIT(17)
+
+#define DU_DITR1		0x14
+#define DU_DITR1_VSA(x)		((x) << 0)
+#define DU_DITR1_VACTIVE(x)	((x) << 16)
+
+#define DU_DITR2		0x18
+#define DU_DITR2_VBP(x)		((x) << 0)
+#define DU_DITR2_VFP(x)		((x) << 16)
+
+#define DU_DITR3		0x1C
+#define DU_DITR3_HSA(x)		((x) << 0)
+#define DU_DITR3_HACTIVE(x)	((x) << 16)
+
+#define DU_DITR4		0x20
+#define DU_DITR4_HBP(x)		((x) << 0)
+#define DU_DITR4_HFP(x)		((x) << 16)
+
+#define DU_DITR5		0x24
+#define DU_DITR5_VSFT(x)	((x) << 0)
+#define DU_DITR5_HSFT(x)	((x) << 16)
+
+#define DU_PBCR0		0x4C
+#define DU_PBCR0_PB_DEP(x)	((x) << 0)
+
+/* -----------------------------------------------------------------------------
  * Display Control Registers
  */
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_vsp.c b/drivers/gpu/drm/rcar-du/rcar_du_vsp.c
index 173a47f..6056ae7 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_vsp.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_vsp.c
@@ -351,9 +351,12 @@ int rcar_du_vsp_init(struct rcar_du_vsp *vsp, struct device_node *np,
 
 	 /*
 	  * The VSP2D (Gen3) has 5 RPFs, but the VSP1D (Gen2) is limited to
-	  * 4 RPFs.
+	  * 4 RPFs and VSP2D (RZ/G2L) has 2 RPFs.
 	  */
-	vsp->num_planes = rcdu->info->gen >= 3 ? 5 : 4;
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L))
+		vsp->num_planes = 2;
+	else
+		vsp->num_planes = rcdu->info->gen >= 3 ? 5 : 4;
 
 	vsp->planes = devm_kcalloc(rcdu->dev, vsp->num_planes,
 				   sizeof(*vsp->planes), GFP_KERNEL);
-- 
2.7.4


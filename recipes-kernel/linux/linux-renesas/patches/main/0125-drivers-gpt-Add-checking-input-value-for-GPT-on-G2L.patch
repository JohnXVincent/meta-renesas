From 8647ba7cbb3d5e7a95d5c68a639b12e36de18012 Mon Sep 17 00:00:00 2001
From: Long Luu <long.luu.ur@renesas.com>
Date: Thu, 11 Mar 2021 15:43:55 +0700
Subject: [PATCH 125/135] drivers: gpt: Add checking input value for GPT on G2L

This commit adds checking input value for GPT on G2L
to avoid prohibited setting. Since return value in functions
may cause deadlock so remove mutex in some functions which
already used mutex in pwm sysfs

Signed-off-by: Long Luu <long.luu.ur@renesas.com>
---
 drivers/pwm/gpt-rzg2l.c | 129 +++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 100 insertions(+), 29 deletions(-)

diff --git a/drivers/pwm/gpt-rzg2l.c b/drivers/pwm/gpt-rzg2l.c
index f471c6a..565810b 100644
--- a/drivers/pwm/gpt-rzg2l.c
+++ b/drivers/pwm/gpt-rzg2l.c
@@ -85,6 +85,7 @@ struct rzg2l_gpt_chip {
 	unsigned int index;
 	unsigned int overflow_count, buffer_mode_count;
 	unsigned long buffer[3];
+	unsigned int period_ns;
 };
 
 static inline struct rzg2l_gpt_chip *to_rzg2l_gpt_chip(struct pwm_chip *chip)
@@ -125,11 +126,12 @@ static void rzg2l_timer_count_stop(struct rzg2l_gpt_chip *pc)
 	rzg2l_gpt_write(pc, tmp, GTCR);
 }
 
-static unsigned long rzg2l_calculate_prescale(struct rzg2l_gpt_chip *pc,
+static int rzg2l_calculate_prescale(struct rzg2l_gpt_chip *pc,
 						int period_ns)
 {
 	unsigned long long c, clk_rate;
-	unsigned long period_cycles, prescale;
+	unsigned long period_cycles;
+	int prescale;
 
 	clk_rate = clk_get_rate(pc->clk);
 	c = clk_rate * period_ns;
@@ -159,7 +161,7 @@ static unsigned long rzg2l_calculate_prescale(struct rzg2l_gpt_chip *pc,
 		prescale = 5;
 	} else {
 		dev_err(pc->chip.dev, "gpt-rzg2l prescale over!!\n");
-		return -EINVAL;
+		return -1;
 	}
 
 	return prescale;
@@ -204,21 +206,64 @@ rzg2l_time_to_tick_number(struct rzg2l_gpt_chip *pc, int time_ns,
 	return period_cycles;
 }
 
+static unsigned long long
+rzg2l_tick_number_to_time(struct rzg2l_gpt_chip *pc, u32 tick_number,
+			unsigned long prescale)
+{
+	unsigned long long c, clk_rate, time_ns;
+
+	clk_rate = clk_get_rate(pc->clk);
+	c = (unsigned long long)tick_number * 1000000000;
+	do_div(c, clk_rate);
+	time_ns = c;
+
+	switch (prescale) {
+	case 0:
+		time_ns *= 1;
+		break;
+	case 1:
+		time_ns *= 4;
+		break;
+	case 2:
+		time_ns *= 16;
+		break;
+	case 3:
+		time_ns *= 64;
+		break;
+	case 4:
+		time_ns *= 256;
+		break;
+	case 5:
+		time_ns *= 1024;
+		break;
+	}
+
+	return time_ns;
+}
+
 static int rzg2l_gpt_config(struct pwm_chip *chip, struct pwm_device *pwm,
 				int duty_ns, int period_ns)
 {
 	struct rzg2l_gpt_chip *pc = to_rzg2l_gpt_chip(chip);
-	unsigned long prescale, pv, dc;
-	int rc;
+	unsigned long pv, dc;
+	int rc, prescale;
+
+	if ((duty_ns < 0) || (period_ns < 0)) {
+		dev_err(chip->dev, "Set time negative\n");
+		return -EINVAL;
+	}
 
 	prescale = rzg2l_calculate_prescale(pc, period_ns);
+	if (prescale < 0)
+		return -EINVAL;
+
 	pv = rzg2l_time_to_tick_number(pc, period_ns, prescale);
 	dc = rzg2l_time_to_tick_number(pc, duty_ns, prescale);
 
 	if (duty_ns == period_ns)
 		dc = pv;
 
-	mutex_lock(&pc->mutex);
+	pc->period_ns = period_ns;
 	/* NOTE: the clock to GPT has to be enabled first
 	 * before writing to the registers
 	 */
@@ -245,8 +290,6 @@ static int rzg2l_gpt_config(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	clk_disable_unprepare(pc->clk);
 
-	mutex_unlock(&pc->mutex);
-
 	return 0;
 }
 
@@ -255,8 +298,6 @@ static int rzg2l_gpt_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	struct rzg2l_gpt_chip *pc = to_rzg2l_gpt_chip(chip);
 	int rc = 0;
 
-	mutex_lock(&pc->mutex);
-
 	if (!pc->clk_enable) {
 		rc = clk_prepare_enable(pc->clk);
 		if (!rc)
@@ -264,8 +305,6 @@ static int rzg2l_gpt_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 		rzg2l_timer_count_start(pc);
 	}
 
-	mutex_unlock(&pc->mutex);
-
 	return rc;
 }
 
@@ -273,15 +312,11 @@ static void rzg2l_gpt_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct rzg2l_gpt_chip *pc = to_rzg2l_gpt_chip(chip);
 
-	mutex_lock(&pc->mutex);
-
 	if (pc->clk_enable) {
 		rzg2l_timer_count_stop(pc);
 		clk_disable_unprepare(pc->clk);
 		pc->clk_enable--;
 	}
-
-	mutex_unlock(&pc->mutex);
 }
 
 static int
@@ -294,10 +329,6 @@ rzg2l_gpt_capture(struct pwm_chip *chip, struct pwm_device *pwm,
 	unsigned int effective_ticks;
 	u64 high, low;
 
-	mutex_lock(&pc->mutex);
-
-	result->period = result->duty_cycle = 0;
-
 	rc = clk_prepare_enable(pc->clk);
 	if (rc < 0) {
 		dev_err(chip->dev, "Unavailable  clock\n");
@@ -306,6 +337,7 @@ rzg2l_gpt_capture(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	spin_lock_irqsave(&pc->lock, flags);
 
+	result->period = result->duty_cycle = 0;
 	pc->index = 0;
 	pc->snapshot[0] = 0;
 	pc->snapshot[1] = 0;
@@ -370,8 +402,6 @@ rzg2l_gpt_capture(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	clk_disable_unprepare(pc->clk);
 
-	mutex_unlock(&pc->mutex);
-
 	return ret;
 }
 
@@ -450,7 +480,7 @@ static irqreturn_t gpt_gtcib_interrupt(int irq, void *data)
 			if (tmp & INPUT_CAP_GTIOB_FALLING_EDGE)
 				rzg2l_gpt_write(pc, INPUT_CAP_GTIOB_RISING_EDGE,
 						GTICBSR);
-				pc->index++;
+			pc->index++;
 			break;
 		case 2:
 			/* Disable capture operation */
@@ -486,15 +516,22 @@ static ssize_t buff0_store(struct device *dev, struct device_attribute *attr,
 	if (ret)
 		return ret;
 
+	if (pc->period_ns < val)
+		return -EINVAL;
+
 	mutex_lock(&pc->mutex);
 
 	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
 	pc->buffer[0] = rzg2l_time_to_tick_number(pc, val, prescale);
+	if (pc->buffer[0] == 0) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	ret = clk_prepare_enable(pc->clk);
 	if (ret < 0) {
 		dev_err(pc->chip.dev, "Unavailable  clock\n");
-		return ret;
+		goto out;
 	}
 
 	/*Set compare match value in GTCCRA in GTCCRB*/
@@ -502,6 +539,7 @@ static ssize_t buff0_store(struct device *dev, struct device_attribute *attr,
 
 	clk_disable_unprepare(pc->clk);
 
+out:
 	mutex_unlock(&pc->mutex);
 
 	return ret ? : count;
@@ -512,8 +550,13 @@ static ssize_t buff0_show(struct device *dev, struct device_attribute *attr,
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct rzg2l_gpt_chip *pc = platform_get_drvdata(pdev);
+	unsigned long prescale;
+	unsigned long long time_ns;
 
-	return sprintf(buf, "%lu\n", pc->buffer[0]);
+	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
+	time_ns = rzg2l_tick_number_to_time(pc, pc->buffer[0], prescale);
+
+	return sprintf(buf, "%llu\n", time_ns);
 }
 
 static ssize_t buff1_store(struct device *dev, struct device_attribute *attr,
@@ -529,16 +572,24 @@ static ssize_t buff1_store(struct device *dev, struct device_attribute *attr,
 	if (ret)
 		return ret;
 
+	if (pc->period_ns < val)
+		return -EINVAL;
+
 	mutex_lock(&pc->mutex);
 
 	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
 	pc->buffer[1] = rzg2l_time_to_tick_number(pc, val, prescale);
+	if (pc->buffer[1] == 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	pc->buffer_mode_count = 2;
 
 	ret = clk_prepare_enable(pc->clk);
 	if (ret < 0) {
 		dev_err(pc->chip.dev, "Unavailable  clock\n");
-		return ret;
+		goto out;
 	}
 
 	/*Set buffer operation with CCRA CCRB in GTBER*/
@@ -550,6 +601,7 @@ static ssize_t buff1_store(struct device *dev, struct device_attribute *attr,
 
 	clk_disable_unprepare(pc->clk);
 
+out:
 	mutex_unlock(&pc->mutex);
 
 	return ret ? : count;
@@ -560,8 +612,13 @@ static ssize_t buff1_show(struct device *dev, struct device_attribute *attr,
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct rzg2l_gpt_chip *pc = platform_get_drvdata(pdev);
+	unsigned long prescale;
+	unsigned long long time_ns;
+
+	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
+	time_ns = rzg2l_tick_number_to_time(pc, pc->buffer[1], prescale);
 
-	return sprintf(buf, "%lu\n", pc->buffer[1]);
+	return sprintf(buf, "%llu\n", time_ns);
 }
 
 static ssize_t buff2_store(struct device *dev, struct device_attribute *attr,
@@ -577,16 +634,24 @@ static ssize_t buff2_store(struct device *dev, struct device_attribute *attr,
 	if (ret)
 		return ret;
 
+	if (pc->period_ns < val)
+		return -EINVAL;
+
 	mutex_lock(&pc->mutex);
 
 	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
 	pc->buffer[2] = rzg2l_time_to_tick_number(pc, val, prescale);
+	if (pc->buffer[2] == 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	pc->buffer_mode_count = 3;
 
 	ret = clk_prepare_enable(pc->clk);
 	if (ret < 0) {
 		dev_err(pc->chip.dev, "Unavailable  clock\n");
-		return ret;
+		goto out;
 	}
 
 	/*Set buffer operation with CCRA CCRB in GTBER*/
@@ -598,6 +663,7 @@ static ssize_t buff2_store(struct device *dev, struct device_attribute *attr,
 
 	clk_disable_unprepare(pc->clk);
 
+out:
 	mutex_unlock(&pc->mutex);
 
 	return ret ? : count;
@@ -608,8 +674,13 @@ static ssize_t buff2_show(struct device *dev, struct device_attribute *attr,
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct rzg2l_gpt_chip *pc = platform_get_drvdata(pdev);
+	unsigned long prescale;
+	unsigned long long time_ns;
+
+	prescale = rzg2l_gpt_read(pc, GTCR) >> 24;
+	time_ns = rzg2l_tick_number_to_time(pc, pc->buffer[2], prescale);
 
-	return sprintf(buf, "%lu\n", pc->buffer[2]);
+	return sprintf(buf, "%llu\n", time_ns);
 }
 
 static DEVICE_ATTR_RW(buff0);
-- 
2.7.4


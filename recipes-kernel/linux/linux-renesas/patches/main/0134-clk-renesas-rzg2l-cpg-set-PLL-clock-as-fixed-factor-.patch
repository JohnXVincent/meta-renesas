From b532443591cd8d824f5a5bcbfa11f7ea77ef05d8 Mon Sep 17 00:00:00 2001
From: Binh Nguyen <binh.nguyen.jz@renesas.com>
Date: Mon, 22 Mar 2021 22:22:49 +0700
Subject: [PATCH 134/135] clk: renesas-rzg2l-cpg: set PLL clock as fixed factor
 clocks

Having issue when support dynamic switch/divider for PLL core clock
This commit remove the implementation, PLL clocks become fixed factor
clocks.

Signed-off-by: Binh Nguyen <binh.nguyen.jz@renesas.com>
---
 drivers/clk/renesas/renesas-rzg2l-cpg.c | 232 --------------------------------
 1 file changed, 232 deletions(-)

diff --git a/drivers/clk/renesas/renesas-rzg2l-cpg.c b/drivers/clk/renesas/renesas-rzg2l-cpg.c
index a4ce18b..fb0e914 100644
--- a/drivers/clk/renesas/renesas-rzg2l-cpg.c
+++ b/drivers/clk/renesas/renesas-rzg2l-cpg.c
@@ -324,82 +324,6 @@ struct pll_clk {
 
 #define to_pll(_hw)	container_of(_hw, struct pll_clk, hw)
 
-static int rzg2l_pll_clock_endisable(struct clk_hw *hw, bool enable)
-{
-	struct pll_clk *pll_clk = to_pll(hw);
-	struct cpg_mssr_priv *priv = pll_clk->priv;
-	struct device *dev = priv->dev;
-	unsigned long flags;
-	u32 value;
-
-	dev_dbg(dev, "PLL CLK_ON %pC %s\n", hw->clk,
-		enable ? "ON" : "OFF");
-	spin_lock_irqsave(&priv->rmw_lock, flags);
-
-	if (enable) {
-		value = PLL_RES(pll_clk->stby_conf)
-			| PLL_RES(pll_clk->stby_conf) << 16;
-		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
-		udelay(10);
-		value = PLL_EN(pll_clk->stby_conf)
-			| PLL_EN(pll_clk->stby_conf) << 16;
-		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
-		udelay(10);
-
-		if(!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
-			& PLL_EN(pll_clk->mon_conf))
-		  && !!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
-			& PLL_RES(pll_clk->mon_conf)))
-			goto failed;
-	} else {
-		value = PLL_EN(pll_clk->stby_conf) << 16;
-		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
-		udelay(10);
-		value = PLL_RES(pll_clk->stby_conf) << 16;
-		writel(value, priv->base + PLL_REG(pll_clk->stby_conf));
-		udelay(10);
-
-		if(!!(readl(priv->base + PLL_REG(pll_clk->mon_conf))
-			& PLL_EN(pll_clk->mon_conf))
-		  && !(readl(priv->base + PLL_REG(pll_clk->mon_conf))
-			& PLL_RES(pll_clk->mon_conf)))
-			goto failed;
-	}
-
-	spin_unlock_irqrestore(&priv->rmw_lock, flags);
-
-	return 0;
-
-failed:
-	spin_unlock_irqrestore(&priv->rmw_lock, flags);
-	dev_err(dev, "Failed to %s %pC\n",
-			enable ? "Enable" : "Disable",
-			hw->clk);
-	return -ETIMEDOUT;
-}
-
-static int rzg2l_pll_clock_enable(struct clk_hw *hw)
-{
-	return rzg2l_pll_clock_endisable(hw, true);
-}
-
-static void rzg2l_pll_clock_disable(struct clk_hw *hw)
-{
-	rzg2l_pll_clock_endisable(hw, false);
-}
-
-static int rzg2l_pll_clock_is_enabled(struct clk_hw *hw)
-{
-	struct pll_clk *pll_clk = to_pll(hw);
-	struct cpg_mssr_priv *priv = pll_clk->priv;
-	u32 value;
-
-	value = readl(priv->base + PLL_REG(pll_clk->mon_conf));
-
-	return (!(value & PLL_EN(pll_clk->mon_conf))
-		  && !!(value & PLL_RES(pll_clk->mon_conf)));
-}
-
 static unsigned long rzg2l_cpg_pll_clk_recalc_rate(struct clk_hw *hw,
 						unsigned long parent_rate)
 {
@@ -430,164 +354,8 @@ static unsigned long rzg2l_cpg_pll_clk_recalc_rate(struct clk_hw *hw,
 	return DIV_ROUND_CLOSEST_ULL((u64)parent_rate * mult, div);
 }
 
-static long rzg2l_cpg_pll_clk_round_rate(struct clk_hw *hw,
-					unsigned long rate,
-					unsigned long *parent_rate)
-{
-	struct pll_clk *pll_clk = to_pll(hw);
-	unsigned long best_diff = (unsigned long)-1;
-	unsigned long diff;
-	unsigned int div, mult, best_mult, best_div;
-
-	if (pll_clk->type == CLK_TYPE_SAM_PLL) {
-		unsigned int m, p, s;
-		/*we will not support Floating point*/
-		/*mult = m + (k/65536) => mult = m*/
-		for (m = 64; m < 534; m++) {
-			for (p = 1; p < 5; p++) {
-				for (s = 0; s < 7; s++) {
-					div = p * (0x1 << s);
-					mult  = m;
-					diff = abs((*parent_rate * mult)
-						- (rate * div));
-					if (best_diff > diff) {
-						best_diff = diff;
-						best_mult = mult;
-						best_div = div;
-					}
-				}
-			}
-		}
-	} else if (pll_clk->type == CLK_TYPE_SI_PLL) {
-		unsigned int p1, p2, ref, fracin, intin;
-		/*we will not support Floating point*/
-		/*mult = intin + fracin/(0x1<<24) => mult = intin*/
-		fracin = 0;
-		for (p1 = 1; p1 <= 7; p1++) {
-			for (p2 = 1; p2 <= 7; p2++) {
-				for (ref = 1; ref <= 63; ref++) {
-					for (intin = 0; intin < 4096; intin++) {
-						mult = intin;
-						div = ref * p1 * p2;
-						diff = abs((*parent_rate * mult)
-							- (rate * div));
-						if (best_diff > diff) {
-							best_diff = diff;
-							best_mult = mult;
-							best_div = div;
-						}
-					}
-				}
-			}
-		}
-	} else {
-		return 0;
-	}
-
-	return DIV_ROUND_CLOSEST_ULL((u64)*parent_rate * best_mult, best_div);
-}
-
-static int rzg2l_cpg_pll_clk_set_rate(struct clk_hw *hw,
-				unsigned long rate,
-				unsigned long parent_rate)
-{
-	struct pll_clk *pll_clk = to_pll(hw);
-	struct cpg_mssr_priv *priv = pll_clk->priv;
-	unsigned long best_diff = (unsigned long)-1;
-	unsigned long diff, flags;
-	unsigned int div, mult, val1, val2;
-
-
-	if (pll_clk->type == CLK_TYPE_SAM_PLL) {
-		unsigned int m, p, s, best_m, best_p, best_s;
-		short best_k, k;
-		/*we will not support Floating point*/
-		/*mult = m + (k/65536) => mult = m*/
-		k = 0;
-		for (m = 64; m < 534; m++) {
-			for (p = 1; p < 5; p++) {
-				for (s = 0; s < 7; s++) {
-					div = p * (0x1 << s);
-					mult  = m;
-					diff = abs((parent_rate * mult)
-						- (rate * div));
-					if (best_diff > diff) {
-						best_diff = diff;
-						best_k = k;
-						best_m = m;
-						best_p = p;
-						best_s = s;
-					}
-				}
-			}
-		}
-
-		spin_lock_irqsave(&priv->rmw_lock, flags);
-
-		val1 = (best_k << 16) | best_m << 6 | best_p;
-		writel(val1, pll_clk->base + GET_REG1(pll_clk->conf));
-
-		val2 = (readl(pll_clk->base + GET_REG2(pll_clk->conf))
-			& (~0xf)) | best_s;
-		writel(val2, pll_clk->base + GET_REG2(pll_clk->conf));
-
-		spin_unlock_irqrestore(&priv->rmw_lock, flags);
-
-	} else if (pll_clk->type == CLK_TYPE_SI_PLL) {
-		unsigned int p1, p2, ref, fracin, intin, val3;
-		unsigned int best_p1, best_p2, best_ref,
-				best_fracin, best_intin;
-		/*we will not support Floating point*/
-		/*mult = intin + fracin/(0x1<<24) => mult = intin*/
-		fracin = 0;
-		for (p1 = 1; p1 <= 7; p1++) {
-			for (p2 = 1; p2 <= 7; p2++) {
-				for (ref = 1; ref <= 63; ref++) {
-					for (intin = 0; intin < 4096; intin++) {
-						mult = intin;
-						div = ref * p1 * p2;
-						diff = abs((parent_rate * mult)
-							- (rate * div));
-						if (best_diff > diff) {
-							best_diff = diff;
-							best_p1 = p1;
-							best_p2 = p2;
-							best_ref = ref;
-							best_fracin = fracin;
-							best_intin = intin;
-						}
-					}
-				}
-			}
-		}
-
-		spin_lock_irqsave(&priv->rmw_lock, flags);
-
-		val1 = (best_ref << 8) | (best_p2 << 4) | best_p1
-			| (0x1 << 24) | (0x1 << 20) | (0x1 << 16);
-		writel(val1, pll_clk->base + GET_REG1(pll_clk->conf));
-
-		val2 = (readl(pll_clk->base + GET_REG2(pll_clk->conf))
-			& (~0xffffff00)) | (best_fracin << 8);
-		writel(val2, pll_clk->base + GET_REG2(pll_clk->conf));
-
-		val3 = (readl(pll_clk->base + GET_REG3(pll_clk->conf))
-			& (~0x0fff0000)) | (best_intin << 16);
-		writel(val3, pll_clk->base + GET_REG3(pll_clk->conf));
-
-		spin_unlock_irqrestore(&priv->rmw_lock, flags);
-	}
-
-	return 0;
-}
-
 static const struct clk_ops rzg2l_cpg_pll_ops = {
 	.recalc_rate = rzg2l_cpg_pll_clk_recalc_rate,
-	.round_rate = rzg2l_cpg_pll_clk_round_rate,
-	.set_rate = rzg2l_cpg_pll_clk_set_rate,
-	.enable = rzg2l_pll_clock_enable,
-	.disable = rzg2l_pll_clock_disable,
-	.is_enabled = rzg2l_pll_clock_is_enabled,
 };
 
 struct clk * __init rzg2l_cpg_pll_clk_register(const struct cpg_core_clk *core,
-- 
2.7.4


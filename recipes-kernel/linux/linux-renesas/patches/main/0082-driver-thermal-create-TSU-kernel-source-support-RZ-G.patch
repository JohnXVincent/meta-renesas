From 626aa267fbe046062da49f414ef9aca531fcbe46 Mon Sep 17 00:00:00 2001
From: Tien Le <tien.le.xw@renesas.com>
Date: Mon, 1 Mar 2021 17:58:35 +0700
Subject: [PATCH 082/135] driver: thermal: create TSU kernel source support
 RZ/G2L

this patch create TSU kernel source support  R9A07G044L SoC.

Signed-off-by: Tien Le <tien.le.xw@renesas.com>
---
 drivers/thermal/rzg2l_thermal.c | 334 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 334 insertions(+)
 create mode 100644 drivers/thermal/rzg2l_thermal.c

diff --git a/drivers/thermal/rzg2l_thermal.c b/drivers/thermal/rzg2l_thermal.c
new file mode 100644
index 0000000..3df9ec7
--- /dev/null
+++ b/drivers/thermal/rzg2l_thermal.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *	RZ/G2L TSU thermal sensor driver
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reboot.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+#include <linux/reset.h>
+
+#include "thermal_hwmon.h"
+
+#define CTEMP_MASK	0xFFF
+#define D_OTP_25						1545
+#define D_OTP_105						2827
+#define RESOLUTION					625
+#define D_OTP_SL						6
+
+/* Register offsets */
+#define R_TSU_SM							0x00
+#define R_TSU_ST							0x04
+#define R_TSU_SCS							0x08
+#define R_TSU_SAD							0x0C
+#define R_TSU_SS							0x10
+#define R_OTPTSU_REG					0x14
+#define R_OTPTSUTRIM0_REG			0x18
+#define R_OTPTSUTRIM1_REG			0x1C
+#define R_OTPTSUTRIM2_REG			0x20
+#define R_OTPTSUTRIM3_vEG			0x24
+
+/* Sensor Mode Register(TSU_SM) */
+#define EN_TS				BIT(0)
+#define ADC_EN_TS		BIT(1)
+
+/* TSU_ST bits */
+#define TSU_START	BIT(0)
+
+#define MCELSIUS_X10				10000
+#define TEMP_25							25000
+
+typedef enum
+{
+		THERMAL_1_POINT_CAL = 0,							 /* 1-Point calibration */
+		THERMAL_2_POINT_CAL = 1									 /* 2-Point calibration */
+} r_thermal_calibration_t;
+
+struct rzg2l_thermal_tsc {
+	void __iomem *base;
+	struct thermal_zone_device *zone;
+		r_thermal_calibration_t cal;
+	int low;
+	int high;
+	int tj_t;
+};
+
+struct rzg2l_thermal_priv {
+	struct reset_control *rstc;
+	struct rzg2l_thermal_tsc *tsc;
+	void (*thermal_init)(struct rzg2l_thermal_tsc *tsc);
+};
+
+
+static inline u32 rzg2l_thermal_read(struct rzg2l_thermal_tsc *tsc,
+					 u32 reg)
+{
+	return ioread32(tsc->base + reg);
+}
+
+static inline void rzg2l_thermal_write(struct rzg2l_thermal_tsc *tsc,
+						 u32 reg, u32 data)
+{
+	iowrite32(data, tsc->base + reg);
+}
+
+static int rzg2l_thermal_round(int temp)
+{
+		int result;
+
+		result = temp / 10;
+
+		return result + TEMP_25;
+}
+
+static int rzg2l_thermal_get_temp(void *devdata, int *temp)
+{
+	struct rzg2l_thermal_tsc *tsc = devdata;
+	u32 sensor;
+		int val, result;
+
+	/* Read register */
+
+	sensor = rzg2l_thermal_read(tsc, R_TSU_SAD);
+
+	switch (tsc->cal)
+	{
+	case THERMAL_1_POINT_CAL:
+		/* 1-Point Calibration */
+
+				result = ((sensor - D_OTP_25) * RESOLUTION);
+
+		if (sensor >= D_OTP_25)
+			val = result;
+		else
+			val = (result * ((65 * MCELSIUS_X10)/(57 + D_OTP_SL)))/MCELSIUS_X10;
+		break;
+	case THERMAL_2_POINT_CAL:
+		/* 2-Point Calibration */
+
+				result = ((sensor - D_OTP_25) *((80 * MCELSIUS_X10)/(D_OTP_105 - D_OTP_25))); 
+		if (sensor >= D_OTP_25)
+			val = result;
+		else
+			val = (result * ((65 * MCELSIUS_X10)/(57 + D_OTP_SL)))/MCELSIUS_X10;
+		break;
+
+	default:
+		break;
+	}
+
+		*temp = rzg2l_thermal_round(val);
+
+	/* Make sure we are inside specifications */
+	if ((*temp	< -40000) || (*temp > 125000))
+		return -EIO;
+
+	return 0;
+}
+
+static int rzg2l_thermal_set_trips(void *devdata, int low, int high)
+{
+	struct rzg2l_thermal_tsc *tsc = devdata;
+
+	low = clamp_val(low, -40000, 120000);
+	high = clamp_val(high, -40000, 120000);
+
+	tsc->low = low;
+	tsc->high = high;
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops rzg2l_tz_of_ops = {
+				.get_temp		= rzg2l_thermal_get_temp,
+		.set_trips	= rzg2l_thermal_set_trips,
+};
+
+static void rzg2l_thermal_init(struct rzg2l_thermal_tsc *tsc)
+{
+	u32 reg_val;
+
+	rzg2l_thermal_write(tsc, R_TSU_SCS, 0x1);
+	rzg2l_thermal_write(tsc, R_TSU_SM, 0x3);
+	rzg2l_thermal_write(tsc, R_TSU_ST, 0);
+
+		udelay(60);
+
+	reg_val = rzg2l_thermal_read(tsc, R_TSU_ST);
+	reg_val |= TSU_START;
+	rzg2l_thermal_write(tsc, R_TSU_ST, reg_val);
+	rzg2l_thermal_write(tsc, R_TSU_SS, 0x1);
+
+		usleep_range(1000, 2000);
+
+}
+
+static int rzg2l_thermal_exit(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct thermal_zone_device *zone = platform_get_drvdata(pdev);
+
+	devm_thermal_zone_of_sensor_unregister(dev, zone);
+
+	pm_runtime_put(dev);
+	pm_runtime_disable(dev);
+
+	return 0;
+}
+
+static void rzg2l_hwmon_action(void *data)
+{
+	struct thermal_zone_device *zone = data;
+
+	thermal_remove_hwmon_sysfs(zone);
+}
+
+static int rzg2l_thermal_probe(struct platform_device *pdev)
+{
+	struct rzg2l_thermal_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct thermal_zone_device *zone;
+	int ret;
+
+	/* default values if FUSEs are missing */
+	/* TODO: Read values from hardware on supported platforms */
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->rstc)) {
+	dev_err(&pdev->dev, "failed to get cpg reset\n");
+	return PTR_ERR(priv->rstc);
+	}
+
+		reset_control_deassert(priv->rstc);
+
+	priv->thermal_init = rzg2l_thermal_init;
+
+	platform_set_drvdata(pdev, priv);
+
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	{
+		struct rzg2l_thermal_tsc *tsc;
+		struct device_node *np = dev->of_node;
+				u32 cal;
+
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res)
+			goto error_unregister;
+
+		tsc = devm_kzalloc(dev, sizeof(*tsc), GFP_KERNEL);
+		if (!tsc) {
+			ret = -ENOMEM;
+			goto error_unregister;
+		}
+
+				of_property_read_u32(np, "thermal-cal", &cal);
+
+		tsc->base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(tsc->base)) {
+			ret = PTR_ERR(tsc->base);
+			goto error_unregister;
+		}
+				tsc->cal = cal;
+		priv->tsc = tsc;
+
+		priv->thermal_init(tsc);
+
+		zone = devm_thermal_zone_of_sensor_register(dev, 0, tsc,
+								&rzg2l_tz_of_ops);
+		if (IS_ERR(zone)) {
+			dev_err(dev, "Can't register thermal zone\n");
+			ret = PTR_ERR(zone);
+			goto error_unregister;
+		}
+		tsc->zone = zone;
+
+		tsc->zone->tzp->no_hwmon = false;
+		ret = thermal_add_hwmon_sysfs(tsc->zone);
+		if (ret)
+			goto error_unregister;
+
+		ret = devm_add_action(dev, rzg2l_hwmon_action, zone);
+		if (ret) {
+			rzg2l_hwmon_action(zone);
+			goto error_unregister;
+		}
+
+		return 0;
+	}
+
+error_unregister:
+	rzg2l_thermal_exit(pdev);
+
+	return ret;
+}
+
+static int __maybe_unused rzg2l_thermal_suspend(struct device *dev)
+{
+	struct rzg2l_thermal_priv *priv = dev_get_drvdata(dev);
+		struct rzg2l_thermal_tsc *tsc = priv->tsc;
+		u32 reg_val;
+
+		reg_val = rzg2l_thermal_read(tsc, R_TSU_ST);
+		reg_val &= ~TSU_START;
+		rzg2l_thermal_write(tsc, R_TSU_ST, reg_val);
+		rzg2l_thermal_write(tsc, R_TSU_SM, 0);
+
+	return 0;
+}
+
+static int __maybe_unused rzg2l_thermal_resume(struct device *dev)
+{
+	struct rzg2l_thermal_priv *priv = dev_get_drvdata(dev);
+	struct rzg2l_thermal_tsc *tsc = priv->tsc;
+
+	priv->thermal_init(tsc);
+	rzg2l_thermal_set_trips(tsc, tsc->low, tsc->high);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(rzg2l_thermal_pm_ops, rzg2l_thermal_suspend,
+			 rzg2l_thermal_resume);
+
+static const struct of_device_id rzg2l_thermal_dt_ids[] = {
+	{
+		.compatible = "renesas,tsu-r9a07g044l",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, rzg2l_thermal_dt_ids);
+
+
+static struct platform_driver rzg2l_thermal_driver = {
+	.driver	= {
+		.name	= "rzg2l_thermal",
+		.of_match_table = rzg2l_thermal_dt_ids,
+		.pm = &rzg2l_thermal_pm_ops,
+	},
+	.probe		= rzg2l_thermal_probe,
+	.remove		= rzg2l_thermal_exit,
+};
+module_platform_driver(rzg2l_thermal_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("RZ/G2L TSU thermal sensor driver");
+MODULE_AUTHOR("Tien Le (tien.le.xw@renesas.com)");
-- 
2.7.4


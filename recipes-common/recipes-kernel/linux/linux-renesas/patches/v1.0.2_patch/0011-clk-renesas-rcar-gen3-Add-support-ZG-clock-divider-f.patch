From 8403d855fb47f1804b5fb498358bb25d7ea6bd11 Mon Sep 17 00:00:00 2001
From: Hiep Pham <hiep.pham.zy@renesas.com>
Date: Mon, 21 Feb 2022 11:42:36 +0700
Subject: [PATCH] clk-renesas-rcar-gen3-Add-support-ZG-clock-divider-f

Signed-off-by: Hiep Pham <hiep.pham.zy@renesas.com>
---
 drivers/clk/renesas/rcar-gen3-cpg.c | 149 +++++++++++++++++++++++++++++++++++-
 1 file changed, 146 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/renesas/rcar-gen3-cpg.c b/drivers/clk/renesas/rcar-gen3-cpg.c
index 9b74c0c..4844c06 100644
--- a/drivers/clk/renesas/rcar-gen3-cpg.c
+++ b/drivers/clk/renesas/rcar-gen3-cpg.c
@@ -29,8 +29,25 @@
 #define CPG_PLL2CR		0x002c
 #define CPG_PLL4CR		0x01f4
 
-#define CPG_RCKCR_CKSEL	BIT(15)	/* RCLK Clock Source Select */
+
+#define CPG_FRQCRB             0x00000004 
+#define CPG_FRQCRB_KICK        BIT(31)
+#define CPG_RCKCR_CKSEL	       BIT(15)	/* RCLK Clock Source Select */
 #define Z2FC_BIT_MASK_SFT_8    BIT(2)  /* Use Z2FC bit mask range to [12:8] */
+#define ZG_PARENT_PLL0         BIT(3)  /* Use PLL0 as ZG clock parent */
+#define CPG_FRQCRB_ZGFC_MASK   GENMASK(28, 24)
+#define CPG_FRQCRC_Z2FC_MASK   GENMASK(4, 0) 
+#define to_z_clk(_hw) container_of(_hw, struct cpg_z_clk, hw)
+#define Z_CLK_ROUND(f) (100000000 * DIV_ROUND_CLOSEST_ULL((f), 100000000))
+
+struct cpg_z_clk {
+        struct clk_hw hw;
+        void __iomem *reg;
+        void __iomem *kick_reg;
+        unsigned long mask;
+        unsigned int fixed_div;
+};
+
 
 static spinlock_t cpg_lock;
 
@@ -53,6 +70,127 @@ struct cpg_simple_notifier {
 	u32 saved;
 };
 
+
+static unsigned long cpg_zg_pll0_clk_recalc_rate(struct clk_hw *hw,
+                                               unsigned long parent_rate)
+{
+       struct cpg_z_clk *zclk = to_z_clk(hw);
+       unsigned long prate = parent_rate / zclk->fixed_div;
+       unsigned int div;
+       u32 val;
+
+       //val = clk_readl(zclk->reg) & zclk->mask;
+       val = readl(zclk->reg) & zclk->mask;
+       div = ((val >> __bf_shf(zclk->mask)) & 0x4) ? 2 : 1;
+       return Z_CLK_ROUND(prate / div);
+}
+
+static long cpg_zg_pll0_clk_round_rate(struct clk_hw *hw,
+                                       unsigned long rate,
+                                       unsigned long *parent_rate)
+{
+       struct cpg_z_clk *zclk = to_z_clk(hw);
+       unsigned long prate = *parent_rate / zclk->fixed_div;
+       unsigned int div;
+
+       div = DIV_ROUND_CLOSEST(prate, rate);
+       div = clamp(div, 1U, 2U);
+       *parent_rate = prate * zclk->fixed_div;
+
+       return Z_CLK_ROUND(prate / div);
+}
+
+static int cpg_zg_pll0_clk_set_rate(struct clk_hw *hw,
+                                       unsigned long rate,
+                                       unsigned long parent_rate)
+{
+       struct cpg_z_clk *zclk = to_z_clk(hw);
+       unsigned long prate = parent_rate / zclk->fixed_div;
+       unsigned int div;
+       unsigned int i;
+       u32 val, kick;
+
+       div = DIV_ROUND_CLOSEST(prate, rate);
+       div = clamp(div, 1U, 2U);
+
+       //if (clk_readl(zclk->kick_reg) & CPG_FRQCRB_KICK)
+       if (readl(zclk->kick_reg) & CPG_FRQCRB_KICK)
+               return -EBUSY;
+
+       //val = clk_readl(zclk->reg) & ~zclk->mask;
+       val = readl(zclk->reg) & ~zclk->mask;
+       val |= (((div == 2) ? 0x4 : 0x0) << __bf_shf(zclk->mask)) & zclk->mask;
+       //clk_writel(val, zclk->reg);
+       writel(val, zclk->reg);
+
+       /*
+        * Set KICK bit in FRQCRB to update hardware setting and wait for
+        * clock change completion.
+        */
+       //kick = clk_readl(zclk->kick_reg);
+       kick = readl(zclk->kick_reg);
+       kick |= CPG_FRQCRB_KICK;
+       //clk_writel(kick, zclk->kick_reg);
+       writel(kick, zclk->kick_reg);
+
+       /*
+        * Note: There is no HW information about the worst case latency.
+        *
+        * Using experimental measurements, it seems that no more than
+        * ~10 iterations are needed, independently of the CPU rate.
+        * Since this value might be dependent of external xtal rate, pll0
+        * rate or even the other emulation clocks rate, use 1000 as a
+        * "super" safe value.
+        */
+       for (i = 1000; i; i--) {
+               //if (!(clk_readl(zclk->kick_reg) & CPG_FRQCRB_KICK))
+               if (!(readl(zclk->kick_reg) & CPG_FRQCRB_KICK))
+                       return 0;
+
+               cpu_relax();
+       }
+
+       return -ETIMEDOUT;
+}
+
+static const struct clk_ops cpg_zg_pll0_clk_ops = {
+       .recalc_rate = cpg_zg_pll0_clk_recalc_rate,
+       .round_rate = cpg_zg_pll0_clk_round_rate,
+       .set_rate = cpg_zg_pll0_clk_set_rate,
+};
+
+static struct clk * __init cpg_zg_pll0_clk_register(const char *name,
+                                                       const char *parent_name,
+                                                       void __iomem *reg,
+                                                       unsigned int div)
+{
+       struct clk_init_data init;
+       struct cpg_z_clk *zclk;
+       struct clk *clk;
+
+       zclk = kzalloc(sizeof(*zclk), GFP_KERNEL);
+       if (!zclk)
+               return ERR_PTR(-ENOMEM);
+
+       init.name = name;
+       init.ops = &cpg_zg_pll0_clk_ops;
+       init.flags = 0;
+       init.parent_names = &parent_name;
+       init.num_parents = 1;
+
+       zclk->reg = reg + CPG_FRQCRB;
+       zclk->kick_reg = reg + CPG_FRQCRB;
+       zclk->hw.init = &init;
+       zclk->mask = CPG_FRQCRB_ZGFC_MASK;
+       zclk->fixed_div = div; /* PLLVCO x 1/div x 3DGE divider */
+
+       clk = clk_register(NULL, &zclk->hw);
+       if (IS_ERR(clk))
+               kfree(zclk);
+
+       return clk;
+}
+
 static int cpg_simple_notifier_call(struct notifier_block *nb,
 				    unsigned long action, void *data)
 {
@@ -94,6 +232,7 @@ static void cpg_simple_notifier_register(struct raw_notifier_head *notifiers,
 #define CPG_FRQCRC_Z2FC_MASK           GENMASK(4, 0)
 #define CPG_FRQCRC_ZFC_MASK            GENMASK(12, 8)
 
+/*
 struct cpg_z_clk {
 	struct clk_hw hw;
 	void __iomem *reg;
@@ -101,8 +240,8 @@ struct cpg_z_clk {
 	unsigned long mask;
 	unsigned int fixed_div;
 };
-
-#define to_z_clk(_hw)	container_of(_hw, struct cpg_z_clk, hw)
+*/
+//#define to_z_clk(_hw)	container_of(_hw, struct cpg_z_clk, hw)
 
 static unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,
 					   unsigned long parent_rate)
@@ -788,6 +927,10 @@ struct clk * __init rcar_gen3_cpg_clk_register(struct device *dev,
 					      __clk_get_name(parent));
 
 	case CLK_TYPE_GEN3_ZG:
+		if (cpg_quirks & ZG_PARENT_PLL0)
+			return cpg_zg_pll0_clk_register(core->name,
+							 __clk_get_name(parent),
+							base, core->div);
 		return cpg_zg_clk_register(core->name, __clk_get_name(parent),
 					   base, core->div, core->offset);
 
-- 
2.7.4


From 62c9d1d4a0cf70ce44cf12ba27bdf17bcd877f57 Mon Sep 17 00:00:00 2001
From: TraHT <traht@fsoft.com.vn>
Date: Mon, 3 Dec 2018 11:23:09 +0700
Subject: prio-preempt set affinity the CPUs core for each master and busy
 threads

     The prio-preempt rt app measures priority preemptive mechanism in RT system.
   Higher priority threads could fully take control of CPU(s) from lower priority
   threads.
     In the app, busy threads (high priority) take control all CPUs forever causing
   the system hung-up.

	 This modification helps re-scheduling a specific CPU to do the busy job and
   yielding other CPU(s) to do worker's job, as the result, prevents system hung-up
   during rt testing.

Signed-off-by: TraHT <traht@fsoft.com.vn>
---
 testcases/realtime/func/prio-preempt/prio-preempt.c | 20 ++++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/testcases/realtime/func/prio-preempt/prio-preempt.c b/testcases/realtime/func/prio-preempt/prio-preempt.c
index 9bd5e7a..d68f1b6 100644
--- a/testcases/realtime/func/prio-preempt/prio-preempt.c
+++ b/testcases/realtime/func/prio-preempt/prio-preempt.c
@@ -71,6 +71,7 @@

 #define NUM_WORKERS	27
 #define CHECK_LIMIT	1
+#define CPU_0 0x01 	/* Bind CPU 0 */

 volatile int busy_threads = 0;
 volatile int test_over = 0;
@@ -85,6 +86,8 @@ static int t_after_wait[NUM_WORKERS];

 static int ret = 0;

+static int numcpus;
+
 pthread_barrier_t barrier;

 void usage(void)
@@ -149,7 +152,14 @@ void *busy_thread(void *arg)
	printf("Busy Thread %d(%d): Running...\n", tid, mypri);
	pthread_mutex_unlock(&bmutex);

-	/* TODO: Add sched set affinity here */
+	/* Set affinity the others CPUs for the (numcpus-1) busy threads */
+	if(numcpus > 1){
+		unsigned long cpuset = CPU_0 << numcpus - 1;
+		if (pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset) != 0) {
+			printf("failed to pthread_setaffinity_np busy thread\n");
+		}
+		numcpus--;
+	}

	/* Busy loop */
	while (!test_over) ;
@@ -230,6 +240,12 @@ void *worker_thread(void *arg)

 void *master_thread(void *arg)
 {
+	/* Set affinity CPU #0 for the master thread */
+	unsigned long cpuset = CPU_0;
+	if (pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset) != 0) {
+		printf("failed to pthread_setaffinity_np master thread\n");
+	}
+
	int i, pri_boost;

	pthread_barrier_init(&barrier, NULL, 2);
@@ -289,7 +305,7 @@ void *master_thread(void *arg)

 int main(int argc, char *argv[])
 {
-	int pri_boost, numcpus;
+	int pri_boost;
	setup();

	pass_criteria = CHECK_LIMIT;
--
2.7.4

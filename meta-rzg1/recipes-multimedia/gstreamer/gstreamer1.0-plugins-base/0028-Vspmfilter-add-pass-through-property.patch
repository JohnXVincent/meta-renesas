From ce520a0b849dd7098efc33447fbff8c61e6d1564 Mon Sep 17 00:00:00 2001
From: TraHT <traht@fsoft.com.vn>
Date: Wed, 27 Feb 2019 09:02:38 +0700
Subject: [PATCH] Vspmfilter add pass-through property
    - Descriptions:
 After enabled, vspmfilter will passthrough the buffer without processing if
 input caps and output caps are same.
        + Enable pass-through=TRUE as default in gst_vspm_filter_init:
          => Using in the case playbin3     
            gst-launch-1.0 playbin uri=file:///<video>
        + Otional: TRUE, FALSE      
          => Seting FALSE to use with pipeline to improve performance for encoding

Signed-off-by: TraHT <traht@fsoft.com.vn>
---
 gst/vspmfilter/gstvspmfilter.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/gst/vspmfilter/gstvspmfilter.c b/gst/vspmfilter/gstvspmfilter.c
index bf02a1e..f2601e0 100644
--- a/gst/vspmfilter/gstvspmfilter.c
+++ b/gst/vspmfilter/gstvspmfilter.c
@@ -132,7 +132,8 @@ enum
 {
   PROP_0,
   PROP_VSPM_OUTBUF,
-  PROP_VSPM_DMABUF
+  PROP_VSPM_DMABUF,
+  PROP_VSPM_PASSTHROUGH
 };
 
 static gboolean
@@ -793,6 +794,10 @@ gst_vspm_filter_class_init (GstVspmFilterClass * klass)
       g_param_spec_boolean ("dmabuf-use", "Use DMABUF mode",
         "Whether or not to use dmabuf for output buffer",
         FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_VSPM_PASSTHROUGH,
+      g_param_spec_boolean ("pass-through", "Use PASSTHROUGH mode",
+        "Whether or not to use passthough mode",
+        TRUE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
   gstelement_class->change_state = gst_vspmfilter_change_state;
   gstbasetransform_class->transform_caps =
       GST_DEBUG_FUNCPTR (gst_vspm_filter_transform_caps);
@@ -887,6 +892,10 @@ gst_vspm_filter_init (GstVspmFilter * space)
   VspmbufArray *vspm_outbuf;
   guint i, j;
 
+  /* Enable pass-through as default */
+  GstBaseTransformClass *passt = GST_BASE_TRANSFORM_CLASS (space);
+  gst_base_transform_set_passthrough(passt,TRUE);
+
   space->vsp_info = g_malloc0 (sizeof (GstVspmFilterVspInfo));
   space->vspm_in = g_malloc0 (sizeof (Vspm_mmng_ar));
   space->vspm_out = g_malloc0 (sizeof (Vspm_mmng_ar));
@@ -945,6 +954,7 @@ gst_vspm_filter_set_property (GObject * object, guint property_id,
     const GValue * value, GParamSpec * pspec)
 {
   GstVspmFilter *space = GST_VIDEO_CONVERT_CAST (object);
+  GstBaseTransformClass *passt = GST_BASE_TRANSFORM_CLASS (space);
   GstBaseTransform *trans;
 
   trans = GST_BASE_TRANSFORM (object);
@@ -957,6 +967,9 @@ gst_vspm_filter_set_property (GObject * object, guint property_id,
       if (space->use_dmabuf)
           space->outbuf_allocate = TRUE;
       break;
+    case PROP_VSPM_PASSTHROUGH:
+      gst_base_transform_set_passthrough(passt,g_value_get_boolean (value));
+    break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -968,6 +981,7 @@ gst_vspm_filter_get_property (GObject * object, guint property_id,
     GValue * value, GParamSpec * pspec)
 {
   GstVspmFilter *space = GST_VIDEO_CONVERT_CAST (object);
+  GstBaseTransformClass *passt = GST_BASE_TRANSFORM_CLASS (space);
   switch (property_id) {
     case PROP_VSPM_OUTBUF:
       g_value_set_boolean (value, space->outbuf_allocate);
@@ -975,6 +989,9 @@ gst_vspm_filter_get_property (GObject * object, guint property_id,
     case PROP_VSPM_DMABUF:
       g_value_set_boolean (value, space->use_dmabuf);
       break;
+    case PROP_VSPM_PASSTHROUGH:
+      g_value_set_boolean (value, gst_base_transform_is_passthrough(passt));
+    break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
-- 
2.7.4


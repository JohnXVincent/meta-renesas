From 5f0240e1b7c7832bdeaf611f084d5c5f102cec51 Mon Sep 17 00:00:00 2001
From: "Nguyen Van Linh [FGA.BU13.RZG]" <LinhNV25@fsoft.com.vn>
Date: Sun, 16 Apr 2017 12:37:47 +0700
Subject: [PATCH 2/2] Board: iwg23s_Pi: Add iwg23s_Pi support
 Signed-off-by: Nguyen Van Linh [FGA.BU13.RZG]
 <LinhNV25@fsoft.com.vn>

---
 arch/arm/lib/bootm.c                    |    3 +
 board/renesas/iwg23s_Pi/Makefile        |   45 ++
 board/renesas/iwg23s_Pi/iwg23s_Pi.c     |  384 +++++++++++++
 board/renesas/iwg23s_Pi/iwg23s_Pi.h     |   43 ++
 board/renesas/iwg23s_Pi/lowlevel_init.S |  116 ++++
 boards.cfg                              |    1 +
 drivers/mmc/sh_sdhi.c                   |    4 +-
 drivers/mtd/spi/spi_flash.c             |    4 +
 drivers/mtd/spi/stmicro.c               |    6 +
 drivers/net/Makefile                    |    2 +
 drivers/net/ravb.c                      |  672 ++++++++++++++++++++++
 drivers/net/ravb.h                      |  917 +++++++++++++++++++++++++++++++
 drivers/net/sh_eth_miiphybb.c           |   52 ++
 drivers/net/sh_eth_miiphybb.h           |   41 ++
 drivers/serial/serial_sh.c              |    6 +
 drivers/serial/serial_sh.h              |   13 +-
 drivers/usb/host/ehci-r8a779x.c         |    2 +
 include/configs/iwg23s_Pi.h             |  241 ++++++++
 18 files changed, 2546 insertions(+), 6 deletions(-)
 create mode 100644 board/renesas/iwg23s_Pi/Makefile
 create mode 100644 board/renesas/iwg23s_Pi/iwg23s_Pi.c
 create mode 100644 board/renesas/iwg23s_Pi/iwg23s_Pi.h
 create mode 100644 board/renesas/iwg23s_Pi/lowlevel_init.S
 create mode 100644 drivers/net/ravb.c
 create mode 100644 drivers/net/ravb.h
 create mode 100644 drivers/net/sh_eth_miiphybb.c
 create mode 100644 drivers/net/sh_eth_miiphybb.h
 create mode 100644 include/configs/iwg23s_Pi.h

diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index 7dbb123..14b2d00 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -270,6 +270,9 @@ static int create_fdt(bootm_headers_t *images)
 #endif
 	fdt_fixup_ethernet(*of_flat_tree);
 	fdt_initrd(*of_flat_tree, *initrd_start, *initrd_end, 1);
+#ifdef CONFIG_IWG23S
+	iwg23s_fdt_update(*of_flat_tree);
+#endif
 #ifdef CONFIG_OF_BOARD_SETUP
 	ft_board_setup(*of_flat_tree, gd->bd);
 #endif
diff --git a/board/renesas/iwg23s_Pi/Makefile b/board/renesas/iwg23s_Pi/Makefile
new file mode 100644
index 0000000..c3c19bf
--- /dev/null
+++ b/board/renesas/iwg23s_Pi/Makefile
@@ -0,0 +1,45 @@
+#
+# Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2
+# as published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+
+include	$(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= iwg23s_Pi.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/renesas/iwg23s_Pi/iwg23s_Pi.c b/board/renesas/iwg23s_Pi/iwg23s_Pi.c
new file mode 100644
index 0000000..78f2dce
--- /dev/null
+++ b/board/renesas/iwg23s_Pi/iwg23s_Pi.c
@@ -0,0 +1,384 @@
+/*
+ * Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/*
+ * @file iwg23s_Pi.c 
+ *
+ * @brief Board file Description 
+ *
+ * @ingroup Main
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/processor.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/arch/rmobile.h>
+#include <netdev.h>
+#include <i2c.h>
+#include "iwg23s_Pi.h"
+#include <libfdt.h>
+#include <spi_flash.h>
+
+#define BSP_VERSION                             "iW-PRFCC-SC-01-R1.0-REL0.3-Linux3.10.31"
+#define SOM_VERSION                             "iW-PRFCC-AP-01-R1.x"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern char *name_spi;
+
+#define PLLECR		0xE61500D0
+#define PLL0CR		0xE61500D8
+#define PLL0ST		0x100
+
+#define s_init_wait(cnt) \
+		({	\
+			volatile u32 i = 0x10000 * cnt;	\
+			while (i > 0)	\
+				i--;	\
+		})
+
+void s_init(void)
+{
+	struct r8a7747x_rwdt *rwdt = (struct iwg23s_rwdt *)RWDT_BASE;
+	struct r8a7747x_swdt *swdt = (struct iwg23s_swdt *)SWDT_BASE;
+	u32 val;
+	u32 pll0_status;
+
+	/* Watchdog init */
+	writel(0xA5A5A500, &rwdt->rwtcsra);
+	writel(0xA5A5A500, &swdt->swtcsra);
+
+	/* cpu frequency setting */
+	val = readl(PLL0CR);
+	val &= ~0x7F000000;
+	val |= 0x31000000;	/* EXTAL 20MHz * (49+1) = 1GHz */
+	writel(val, PLL0CR);
+	do {
+		pll0_status = readl(PLLECR) & PLL0ST;
+	} while (pll0_status == 0x0);
+}
+
+#define TMU1_MSTP111    (1 << 11)
+
+#define I2C1_MSTP930	(1 << 30)
+#define SDHI1_MSTP313	(1 << 13)
+#define SDHI2_MSTP312	(1 << 12)
+
+#define SCIF1_MSTP720   (1 << 20)
+
+#define AVB_MSTP812	(1 << 12)
+
+#define SDCKCR		0xE6150074
+#define SDH_780MHZ	(0x0 << 8)
+#define SD0_97500KHZ	(0x6 << 4)
+#define SD1_156000KHZ	0xC
+#define SD2CKCR		0xE6150078
+#define SD2_97500KHZ	0x7
+
+#define SPI_MSTP918   (1 << 18)
+
+int board_early_init_f(void)
+{
+	u32 val;
+
+	/* TMU1 */
+	val = readl(MSTPSR1);
+	val &= ~TMU1_MSTP111;
+	writel(val, SMSTPCR1);
+
+	/* I2C1 */
+	val = readl(MSTPSR9);
+	val &= ~I2C1_MSTP930;
+	writel(val, SMSTPCR9);
+	/* SCIF1 */
+	val = readl(MSTPSR7);
+	val &= ~SCIF1_MSTP720;
+	writel(val, SMSTPCR7);
+#ifdef CONFIG_SPI
+	val = readl(MSTPSR9);
+	val &= ~SPI_MSTP918;
+	writel(val, SMSTPCR9);
+#endif
+
+	/* AVB */
+	val = readl(MSTPSR8);
+#ifdef CONFIG_RAVB
+	val &= ~AVB_MSTP812;
+#endif
+	writel(val, SMSTPCR8);
+
+	/* MMC/SD */
+	val = readl(MSTPSR3);
+	val &= ~(SDHI1_MSTP313 | SDHI2_MSTP312);
+	writel(val, SMSTPCR3);
+
+	/*
+	 * Set SD1 to the 156MHz as well.
+	 * Set SD2 to the 97.5MHz as well.
+	 */
+	writel(SDH_780MHZ | SD0_97500KHZ | SD1_156000KHZ,
+		SDCKCR);
+	writel(SD2_97500KHZ, SD2CKCR);
+
+	return 0;
+}
+
+DECLARE_GLOBAL_DATA_PTR;
+int board_init(void)
+{
+	u32 val;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = IWG23S_SDRAM_BASE + 0x100;
+
+	/* Init PFC controller */
+	r8a7747x_pinmux_init();
+
+#ifdef CONFIG_SCIF_CONSOLE
+	/* UART */
+	/* IWG23S: UART: UART MUX pin defined */
+	gpio_request(GPIO_FN_RX1_B, NULL);
+	gpio_request(GPIO_FN_TX1_B, NULL);
+#endif
+
+#ifdef CONFIG_SPI
+	gpio_request(GPIO_FN_QSPI0_SPCLK, NULL);
+	gpio_request(GPIO_FN_QSPI0_MOSI_IO0, NULL);
+	gpio_request(GPIO_FN_QSPI0_MISO_IO1, NULL);
+	gpio_request(GPIO_FN_QSPI0_SSL, NULL);
+#endif
+
+#ifdef CONFIG_RAVB
+	/* EtherAVB Enable */
+	gpio_request(GPIO_FN_AVB_TXD0, NULL);
+	gpio_request(GPIO_FN_AVB_TXD1, NULL);
+	gpio_request(GPIO_FN_AVB_TXD2, NULL);
+	gpio_request(GPIO_FN_AVB_TXD3, NULL);
+	gpio_request(GPIO_FN_AVB_TXD4, NULL);
+	gpio_request(GPIO_FN_AVB_TXD5, NULL);
+	gpio_request(GPIO_FN_AVB_TXD6, NULL);
+	gpio_request(GPIO_FN_AVB_TXD7, NULL);
+	gpio_request(GPIO_FN_AVB_RXD1, NULL);
+	gpio_request(GPIO_FN_AVB_RXD2, NULL);
+	gpio_request(GPIO_FN_AVB_RXD3, NULL);
+	gpio_request(GPIO_FN_AVB_RXD4, NULL);
+	gpio_request(GPIO_FN_AVB_RXD5, NULL);
+	gpio_request(GPIO_FN_AVB_RXD6, NULL);
+	gpio_request(GPIO_FN_AVB_RXD7, NULL);
+	gpio_request(GPIO_FN_AVB_RX_ER, NULL);
+	gpio_request(GPIO_FN_AVB_RX_CLK, NULL);
+	gpio_request(GPIO_FN_AVB_RX_DV, NULL);
+	gpio_request(GPIO_FN_AVB_CRS, NULL);
+	gpio_request(GPIO_FN_AVB_MDC, NULL);
+	gpio_request(GPIO_FN_AVB_MDIO, NULL);
+	gpio_request(GPIO_FN_AVB_GTX_CLK, NULL);
+	gpio_request(GPIO_FN_AVB_GTXREFCLK, NULL);
+	gpio_request(GPIO_FN_AVB_TX_EN, NULL);
+	gpio_request(GPIO_FN_AVB_TX_ER, NULL);
+	gpio_request(GPIO_FN_AVB_TX_CLK, NULL);
+	gpio_request(GPIO_FN_AVB_COL, NULL);
+	gpio_request(GPIO_FN_AVB_RXD0, NULL);
+
+	udelay(1);
+#endif
+
+#ifdef CONFIG_SH_SDHI
+	gpio_request(GPIO_FN_SD2_DATA0, NULL);
+	gpio_request(GPIO_FN_SD2_DATA1, NULL);
+	gpio_request(GPIO_FN_SD2_DATA2, NULL);
+	gpio_request(GPIO_FN_SD2_DATA3, NULL);
+	gpio_request(GPIO_FN_SD2_CLK, NULL);
+	gpio_request(GPIO_FN_SD2_CMD, NULL);
+	gpio_request(GPIO_FN_SD2_CD, NULL);
+	gpio_request(GPIO_GP_2_24, NULL);
+	gpio_direction_output(GPIO_GP_2_24, 1);
+
+	gpio_request(GPIO_FN_MMC0_CLK_SDHI1_CLK, NULL);
+	gpio_request(GPIO_FN_MMC0_CMD_SDHI1_CMD, NULL);
+	gpio_request(GPIO_FN_MMC0_D0_SDHI1_D0, NULL);
+	gpio_request(GPIO_FN_MMC0_D1_SDHI1_D1, NULL);
+	gpio_request(GPIO_FN_MMC0_D2_SDHI1_D2, NULL);
+	gpio_request(GPIO_FN_MMC0_D3_SDHI1_D3, NULL);
+	gpio_request(GPIO_FN_MMC0_D4, NULL);
+	gpio_request(GPIO_FN_MMC0_D5, NULL);
+	gpio_request(GPIO_FN_MMC0_D6, NULL);
+	gpio_request(GPIO_FN_MMC0_D7, NULL);
+	gpio_request(GPIO_GP_5_14, NULL);
+	gpio_direction_output(GPIO_GP_5_14, 1);
+	udelay(1000);
+	gpio_direction_output(GPIO_GP_5_14, 0);
+	udelay(1000);
+	gpio_direction_output(GPIO_GP_5_14, 1);
+#endif
+	gpio_request(GPIO_FN_USB1_PWEN, NULL);
+
+	sh_timer_init();
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret = -ENODEV;
+#ifdef CONFIG_RAVB
+	ret = ravb_initialize(bis);
+#endif
+
+	return ret;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = CONFIG_SYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+const struct rmobile_sysinfo sysinfo = {
+	CONFIG_RMOBILE_BOARD_STRING
+};
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = IWG23S_SDRAM_BASE;
+	gd->bd->bi_dram[0].size = IWG23S_SDRAM_SIZE;
+}
+
+/* IWG23S: Print: iWave BSP and SOM version print added */
+void print_board_info(void)
+{
+        printf("\n");
+        printf("Board Info:\n");
+        printf("\tBSP Version     : %s\n", BSP_VERSION);
+        printf("\tSOM Version     : %s\n", SOM_VERSION);
+        printf("\n");
+}
+
+int board_late_init(void)
+{
+	print_board_info();
+	return 0;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_SH_SDHI
+	/* use SDHI2 */
+	ret = sdhi_mmc_init(SDHI2_BASE, 2);
+	if (ret)
+		return ret;
+#endif
+
+	/* use SDHI1 for eMMC */
+	ret = sdhi_mmc_init(SDHI1_BASE, 1);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+void iwg23s_fdt_update(void *fdt)
+{
+	if(name_spi != "SST25VF016B")
+		fdt_setprop_string(fdt, "/spi@e6b10000", "compatible", "m25pe16");
+}
+
+void reset_cpu(ulong addr)
+{
+	u8 val;
+	/* Enable RWDT clock */
+	val = readl(MSTPSR4);
+	val &= ~RWDT_MSTP402;
+	writel(val, SMSTPCR4);
+
+	/* Enable RWDT reset request */
+	writel(RST_WDTRSTCR_RWDT, RST_BASE + RST_WDTRSTCR);
+	/* Set boot address */
+	writel(RST_CABAR_BOOTADR, RST_BASE + RST_CA7BAR);
+
+	/* Set the wdt counter to overflow just before */
+	writel(RWDT_RWTCNT_FULL, RWDT_BASE + RWDT_RWTCNT);
+	/* Start count up of RWDT */
+	writel(RWDT_RWTCSRA_START, RWDT_BASE + RWDT_RWTCSRA);
+}
+
+enum {
+	MSTP00, MSTP01, MSTP02, MSTP03, MSTP04, MSTP05,
+	MSTP07, MSTP08, MSTP09, MSTP10,
+	MSTP_NR,
+};
+
+struct mstp_ctl {
+	u32 s_addr;
+	u32 s_dis;
+	u32 s_ena;
+	u32 r_addr;
+	u32 r_dis;
+	u32 r_ena;
+} mstptbl[MSTP_NR] = {
+	[MSTP00] = { SMSTPCR0,  0x00440001, 0x00400000,
+		     RMSTPCR0,  0x00440001, 0x00000000 },
+	[MSTP01] = { SMSTPCR1,  0x9168998A, 0x00000000,
+		     RMSTPCR1,  0x9168998A, 0x00000000 },
+	[MSTP02] = { SMSTPCR2,  0x100C2120, 0x00002000,
+		     RMSTPCR2,  0x100C2120, 0x00000000 },
+	[MSTP03] = { SMSTPCR3,  0xEC087800, 0x00000000,
+		     RMSTPCR3,  0xEC087800, 0x00000000 },
+	[MSTP04] = { SMSTPCR4,  0x000003C4, 0x00000180,
+		     RMSTPCR4,  0x000003C4, 0x00000000 },
+	[MSTP05] = { SMSTPCR5,  0x40800004, 0x00000000,
+		     RMSTPCR5,  0x40800004, 0x00000000 },
+	[MSTP07] = { SMSTPCR7,  0x0DBFE078, 0x00100000,
+		     RMSTPCR7,  0x0DBFE078, 0x00000000 },
+	[MSTP08] = { SMSTPCR8,  0x00003C03, 0x00000000,
+		     RMSTPCR8,  0x00003C03, 0x00000000 },
+	[MSTP09] = { SMSTPCR9,  0xF8479F88, 0x00000000,
+		     RMSTPCR9,  0xF8479F88, 0x00000000 },
+	[MSTP10] = { SMSTPCR10, 0x7E3EFFE0, 0x00000000,
+		     RMSTPCR10, 0x7E3EFFE0, 0x00000000 },
+};
+
+#define TSTR1   4
+#define TSTR1_STR3      0x1
+
+void arch_preboot_os()
+{
+	u32 val;
+	int i;
+
+	/* stop TMU1 */
+	val = readb(TMU_BASE + TSTR1);
+	val &= ~TSTR1_STR3;
+	writeb(val, TMU_BASE + TSTR1);
+
+	/* stop all module clock*/
+	for (i = MSTP00; i < MSTP_NR; i++) {
+		val = readl(mstptbl[i].s_addr);
+		writel((val | mstptbl[i].s_dis) & ~(mstptbl[i].s_ena),
+		       mstptbl[i].s_addr);
+		val = readl(mstptbl[i].r_addr);
+		writel((val | mstptbl[i].r_dis) & ~(mstptbl[i].r_ena),
+		       mstptbl[i].r_addr);
+	}
+}
diff --git a/board/renesas/iwg23s_Pi/iwg23s_Pi.h b/board/renesas/iwg23s_Pi/iwg23s_Pi.h
new file mode 100644
index 0000000..b171fe4
--- /dev/null
+++ b/board/renesas/iwg23s_Pi/iwg23s_Pi.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+/*
+ * @file iwg23s_Pi.h 
+ *
+ * @brief Include file for Board file iwg23s_Pi.c
+ *
+ * @ingroup Main
+ */
+
+#define RWDT_MSTP402        0x00000004
+
+#define RST_BASE           0xE6160000
+#define RST_WDTRSTCR       0x00000054
+#define RST_CA7BAR         0x00000030
+#define RST_WDTRSTCR_RWDT  0xA55A0000
+#define RST_CABAR_BOOTADR  0x00E63410
+
+#define RWDT_BASE          0xE6020000
+#define RWDT_RWTCNT        0x00000000
+#define RWDT_RWTCSRA       0x00000004
+#define RWDT_RWTCNT_FULL   0x5A5AFFFF
+#define RWDT_RWTCSRA_START 0xA5A5A580
+
+extern int sh_timer_init(void);
+extern int mmcif_mmc_init(void);
+extern int sdhi_mmc_init(unsigned long addr, int ch);
+
+extern void arch_preboot_os(void);
diff --git a/board/renesas/iwg23s_Pi/lowlevel_init.S b/board/renesas/iwg23s_Pi/lowlevel_init.S
new file mode 100644
index 0000000..d861685
--- /dev/null
+++ b/board/renesas/iwg23s_Pi/lowlevel_init.S
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/*
+ * @file  lowlevel_init.S
+ * 
+ * @brief interrupts and L2 cache memory setting for iwave's iwg23s_Pi board 
+ *
+ * @ingroup interrupt Setting
+ */
+
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <version.h>
+#include <common.h>
+
+	.globl lowlevel_init
+lowlevel_init:
+#if 0
+	mrc	p15, 0, r4, c0, c0, 5	/* mpidr */
+	orr	r4, r4, r4, lsr #6
+	and	r4, r4, #7		/* id 0-3 = ca15.0,1,2,3 */
+
+	tst	r4, #4
+	ldreq	r1, =0xf0194000		/* ca15 snoop ctl */
+	ldrne	r1, =0xf0195000		/* ca7 snoop ctl */
+	tst	r4, #3
+	moveq	r0, #3
+	streq	r0, [r1, #0]		/* ca7.0, ca15.0 */
+1:	ldr	r0, [r1, #0]		/* all */
+	tst	r0, #3
+	beq	1b
+	ldr	r0, [r1, #0xc]
+	tst	r0, #1
+	bne	1b
+
+	/* which core is the master? */
+	ldr	r1, =0xe6188000
+	ldr	r0, [r1, #0x1c]	/* RESCNT */
+	tst	r0, #(1<<25)	/* MD8 */
+	moveq	r0, #4		/* ca7.0 is master */
+	movne	r0, #0		/* ca15.0 is master */
+	cmp	r4, r0
+	beq	do_lowlevel_init	@ CPU ID #0
+	b	do_cpu_waiting		@ CPU ID #1-#3
+#endif
+	b	do_lowlevel_init
+
+	.pool
+
+/*
+ * CPU ID #1-#3 come here
+ */
+	.align  4
+do_cpu_waiting:
+	ldr	r1, =0xe6180000	/* sysc */
+1:	ldr	r0, [r1, #0x20]	/* sbar */
+	tst	r0, r0
+	beq	1b
+	bx	r0
+
+/*
+ * Only CPU ID #0 comes here
+ */
+	.align  4
+do_lowlevel_init:
+
+#if 0
+	/* surpress wfe if ca15 */
+	tst	r4, #4
+	mrceq	p15, 0, r0, c1, c0, 1	/* actlr */
+	orreq	r0, r0, #(1<<7)
+	mcreq	p15, 0, r0, c1, c0, 1
+
+	/* and set l2 latency */
+	mrc	p15, 0, r0, c0, c0, 5		@ r0 = MPIDR
+	and	r0, r0, #0xf00
+	lsr	r0, r0, #8
+	tst	r0, #1				@ only need for cluster 0
+	bne	_exit_init_l2_a15
+
+	mrc	p15, 1, r0, c9, c0, 2		@ r0 = L2CTLR
+	and	r1, r0, #7
+	cmp	r1, #3				@ has already been set up?
+	bicne	r0, r0, #0xe7
+	orrne	r0, r0, #0x83			@ L2CTLR[7:6] + L2CTLR[2:0]
+	orrne	r0, r0, #0x20			@ L2CTLR[5]
+	mcrne	p15, 1, r0, c9, c0, 2
+_exit_init_l2_a15:
+#endif
+
+	ldr	r3, =(CONFIG_SYS_INIT_SP_ADDR)
+	sub	sp, r3, #4
+	str	lr, [sp]
+
+	/* initialize system */
+	bl	s_init
+
+	ldr	lr, [sp]
+	mov	pc, lr
+	nop
diff --git a/boards.cfg b/boards.cfg
index 8198aa2..1629192 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -316,6 +316,7 @@ alt_extram                   arm         armv7       alt                 renesas
 alt_media                    arm         armv7       alt                 renesas        rmobile     alt:QOS_PRI_MEDIA
 alt_gfx                      arm         armv7       alt                 renesas        rmobile     alt:QOS_PRI_GFX
 alt_vin                      arm         armv7       alt                 renesas        rmobile     alt:QOS_PRI_VIN
+iwg23s                       arm         armv7       iwg23s_Pi           renesas        rmobile     iwg23s_Pi:EXTRAM_BOOT
 socfpga_cyclone5                arm         armv7          socfpga_cyclone5    altera		    socfpga
 actux1_4_16                  arm         ixp         actux1              -              -           actux1:FLASH2X2
 actux1_4_32                  arm         ixp         actux1              -              -           actux1:FLASH2X2,RAM_32MB
diff --git a/drivers/mmc/sh_sdhi.c b/drivers/mmc/sh_sdhi.c
index 64c8a67..d6bae09 100644
--- a/drivers/mmc/sh_sdhi.c
+++ b/drivers/mmc/sh_sdhi.c
@@ -200,7 +200,7 @@ static void sdhi_sync_reset(struct sdhi_host *host)
 	defined(ALT_SDRAM_BASE) || defined(SKRZG1M_SDRAM_BASE) || defined(SKRZG1E_SDRAM_BASE)
 	if (host->ch == 0)
 		sdhi_writew(host, SDHI_HOST_MODE, 1);	/* 16bit access */
-#elif defined(ALEX_SDRAM_BASE) || defined(SKRZG1C_SDRAM_BASE)
+#elif defined(ALEX_SDRAM_BASE) || defined(SKRZG1C_SDRAM_BASE) || defined(IWG23S_SDRAM_BASE)
 	if ((host->ch == 0) || (host->ch == 2))
 		sdhi_writew(host, SDHI_HOST_MODE, 1);	/* 16bit access */
 #else
@@ -722,7 +722,7 @@ int sdhi_mmc_init(unsigned long addr, int ch)
 		host->bus_shift = 1;
 	else
 		host->bus_shift = 0;
-#elif defined(ALEX_SDRAM_BASE) || defined(SKRZG1C_SDRAM_BASE)
+#elif defined(ALEX_SDRAM_BASE) || defined(SKRZG1C_SDRAM_BASE) || defined(IWG23S_SDRAM_BASE)
 	if ((ch == 0) || (ch == 2)) {
 		host->quirks = SH_SDHI_QUIRK_16BIT_BUF;
 		host->bus_shift = 1;
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 16b1594..9448772 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -15,6 +15,7 @@
 #include <watchdog.h>
 
 #include "spi_flash_internal.h"
+char *name_spi;
 
 static void spi_flash_addr(u32 addr, u8 *cmd)
 {
@@ -539,6 +540,9 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	}
 
 	printf("SF: Detected %s with page size ", flash->name);
+#ifdef CONFIG_IWG23S
+	name_spi = flash->name;
+#endif
 	print_size(flash->sector_size, ", total ");
 	print_size(flash->size, "\n");
 
diff --git a/drivers/mtd/spi/stmicro.c b/drivers/mtd/spi/stmicro.c
index 30b626a..d74d879 100644
--- a/drivers/mtd/spi/stmicro.c
+++ b/drivers/mtd/spi/stmicro.c
@@ -110,6 +110,12 @@ static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
 		.nr_sectors = 512,
 		.name = "N25Q256",
 	},
+	{
+		.id = 0x8015,
+		.pages_per_sector = 16,
+		.nr_sectors = 512,
+		.name = "M25PE16",
+	},
 };
 
 struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 786a656..01d80c2 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -66,6 +66,8 @@ COBJS-$(CONFIG_PLB2800_ETHER) += plb2800_eth.o
 COBJS-$(CONFIG_RTL8139) += rtl8139.o
 COBJS-$(CONFIG_RTL8169) += rtl8169.o
 COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
+COBJS-$(CONFIG_SH_ETHER_BITBANG) += sh_eth_miiphybb.o
+COBJS-$(CONFIG_RAVB) += ravb.o
 COBJS-$(CONFIG_SMC91111) += smc91111.o
 COBJS-$(CONFIG_SMC911X) += smc911x.o
 COBJS-$(CONFIG_DRIVER_TI_EMAC) += davinci_emac.o
diff --git a/drivers/net/ravb.c b/drivers/net/ravb.c
new file mode 100644
index 0000000..2720e88
--- /dev/null
+++ b/drivers/net/ravb.c
@@ -0,0 +1,672 @@
+/*
+ * ravb.c - Driver for Renesas Ethernet AVB.
+ *
+ * Copyright (C) 2015  Renesas Electronics Corporation
+ *
+ * Based on the SuperH Ethernet driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include "ravb.h"
+
+static inline void ravb_flush_dcache(u32 addr, u32 len)
+{
+	flush_dcache_range(addr, addr + len);
+}
+
+static inline void ravb_invalidate_dcache(u32 addr, u32 len)
+{
+	u32 start = addr & ~((u32)ARCH_DMA_MINALIGN - 1);
+	u32 end = roundup(addr + len, ARCH_DMA_MINALIGN);
+	invalidate_dcache_range(start, end);
+}
+
+#define TIMEOUT_CNT 1000
+
+int ravb_send(struct eth_device *dev, void *packet, int len)
+{
+	struct ravb_dev *eth = dev->priv;
+	struct ravb_txdesc *desc = eth->tx_desc_cur;
+	int ret = 0, timeout;
+
+	if (!packet || len > 0xffff) {
+		printf(CARDNAME ": %s: Invalid argument\n", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* packet must be a 4 byte boundary */
+	if ((int)packet & 3) {
+		printf(CARDNAME ": %s: packet not 4 byte alligned\n", __func__);
+		ret = -EFAULT;
+		goto err;
+	}
+
+	/* Update tx descriptor */
+	ravb_flush_dcache((u32)packet, len);
+	memset(desc, 0x0, sizeof(struct ravb_txdesc));
+	desc->dptr = (u32)packet;
+	desc->ds = len;
+	desc->dt = DT_FSINGLE;
+	ravb_flush_dcache((u32)desc, sizeof(struct ravb_txdesc));
+	/* Restart the transmitter if disabled */
+	if (!(ravb_read(eth, TCCR) & TCCR_TSRQ0))
+		ravb_write(eth,
+			ravb_read(eth, TCCR) | TCCR_TSRQ0, TCCR);
+
+	/* Wait until packet is transmitted */
+	timeout = TIMEOUT_CNT;
+	ravb_invalidate_dcache((u32)desc, sizeof(struct ravb_txdesc));
+	while ((desc->dt == DT_FSINGLE) && timeout--) {
+		udelay(10);
+		ravb_invalidate_dcache((u32)desc, sizeof(struct ravb_txdesc));
+	}
+
+	if (timeout < 0) {
+		printf(CARDNAME ": transmit timeout\n");
+		ret = -ETIMEDOUT;
+		goto err;
+	}
+
+	eth->tx_desc_cur++;
+	if (eth->tx_desc_cur >= eth->tx_desc_base + NUM_TX_DESC)
+		eth->tx_desc_cur = eth->tx_desc_base;
+
+err:
+	return ret;
+}
+
+int ravb_recv(struct eth_device *dev)
+{
+	struct ravb_dev *eth = dev->priv;
+	struct ravb_rxdesc *desc = eth->rx_desc_cur;
+	int len = 0;
+	int limit = NUM_RX_DESC;
+	u8 *packet;
+
+	/* Check if the rx descriptor is ready */
+	ravb_invalidate_dcache((u32)desc, sizeof(struct ravb_rxdesc));
+	while (limit-- && desc->dt != DT_FEMPTY) {
+		/* Check for errors */
+		if (desc->msc & MSC_RX_ERR_MASK) {
+			desc->msc = 0x0;
+		} else {
+			len = desc->ds;
+			packet = (u8 *)desc->dptr;
+			ravb_invalidate_dcache((u32)packet, len);
+			NetReceive(packet, len);
+		}
+
+		/* Make current descriptor available again */
+		desc->ds = MAX_BUF_SIZE;
+		desc->dt = DT_FEMPTY;
+		ravb_flush_dcache((u32)desc, sizeof(struct ravb_rxdesc));
+		/* Point to the next descriptor */
+		eth->rx_desc_cur++;
+		if (eth->rx_desc_cur >=
+		    eth->rx_desc_base + NUM_RX_DESC)
+			eth->rx_desc_cur = eth->rx_desc_base;
+		desc = eth->rx_desc_cur;
+		ravb_invalidate_dcache((u32)desc, sizeof(struct ravb_rxdesc));
+	}
+
+	return len;
+}
+
+static int ravb_wait_setting(struct ravb_dev *eth, u16 reg, u32 bits)
+{
+	int i;
+
+	for (i = 0; i < 100; i++) {
+		if (ravb_read(eth, reg) & bits)
+			break;
+		mdelay(1);
+	}
+	if (i >= 100)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int ravb_reset(struct ravb_dev *eth)
+{
+	int ret = 0;
+
+	/* set config mode */
+	ravb_write(eth, CCC_OPC_CONFIG, CCC);
+
+	/* check the operating mode is changed to the config mode */
+	ret = ravb_wait_setting(eth, CSR, CSR_OPS_CONFIG);
+	if (ret < 0)
+		printf(CARDNAME  ": Software reset timeout\n");
+
+	return ret;
+}
+
+static int ravb_desc_bat_init(struct ravb_dev *eth)
+{
+	int i, ret = 0;
+	u32 alloc_desc_size = DBAT_ENTRY_NUM * sizeof(struct ravb_desc);
+	struct ravb_desc *cur_desc;
+
+	/* Allocate descriptor base address table. They should be aligned */
+	/* to size of struct ravb_desc. */
+	eth->desc_bat_base =
+		memalign(sizeof(struct ravb_desc), alloc_desc_size);
+	if (!eth->desc_bat_base) {
+		printf(CARDNAME ": memalign failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* Initialize all descriptors */
+	memset(eth->desc_bat_base, 0x0, alloc_desc_size);
+	for (cur_desc = eth->desc_bat_base, i = 0; i < DBAT_ENTRY_NUM;
+	     cur_desc++, i++) {
+		cur_desc->dt = DT_EOS;
+	}
+	ravb_flush_dcache((u32)eth->desc_bat_base, alloc_desc_size);
+
+	/* Register the descriptor base address table */
+	ravb_write(eth, (u32)eth->desc_bat_base, DBAT);
+
+err:
+	return ret;
+}
+
+static int ravb_tx_desc_init(struct ravb_dev *eth)
+{
+	int i, ret = 0;
+	u32 alloc_desc_size = (NUM_TX_DESC + 1) * sizeof(struct ravb_txdesc);
+	struct ravb_txdesc *cur_tx_desc;
+	struct ravb_desc *desc;
+
+	/* Allocate rx descriptors. They must be aligned to size of struct */
+	/* ravb_txdesc. */
+	eth->tx_desc_base =
+		memalign(sizeof(struct ravb_txdesc), alloc_desc_size);
+	if (!eth->tx_desc_base) {
+		printf(CARDNAME ": memalign failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	eth->tx_desc_cur = eth->tx_desc_base;
+
+	/* Initialize all descriptors */
+	memset(eth->tx_desc_base, 0x0, alloc_desc_size);
+	for (cur_tx_desc = eth->tx_desc_base, i = 0; i < NUM_TX_DESC;
+	     cur_tx_desc++, i++) {
+		cur_tx_desc->dt = DT_EEMPTY;
+	}
+	/* Mark the end of the descriptors */
+	cur_tx_desc->dt = DT_LINKFIX;
+	cur_tx_desc->dptr = (u32)eth->tx_desc_base;
+	ravb_flush_dcache((u32)eth->tx_desc_base, alloc_desc_size);
+
+	/* Point the controller to the tx descriptor list. Must use physical */
+	/* addresses */
+	desc = &eth->desc_bat_base[TX_QUEUE];
+	desc->dt = DT_LINKFIX;
+	desc->dptr = (u32)eth->tx_desc_base;
+	ravb_flush_dcache((u32)desc, sizeof(struct ravb_desc));
+
+err:
+	return ret;
+}
+
+static int ravb_rx_desc_init(struct ravb_dev *eth)
+{
+	int i , ret = 0;
+	u32 alloc_desc_size = (NUM_RX_DESC + 1) * sizeof(struct ravb_rxdesc);
+	u32 alloc_buf_size = NUM_RX_DESC * MAX_BUF_SIZE;
+	struct ravb_rxdesc *cur_rx_desc;
+	struct ravb_desc *desc;
+	u8 *rx_buf;
+
+	/* Allocate rx descriptors. They must be aligned to size of struct */
+	/* ravb_rxdesc. */
+	eth->rx_desc_base =
+		memalign(sizeof(struct ravb_rxdesc), alloc_desc_size);
+	if (!eth->rx_desc_base) {
+		printf(CARDNAME ": memalign failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	eth->rx_desc_cur = eth->rx_desc_base;
+
+	/* Allocate rx data buffers. They should be RAVB_ALIGN bytes */
+	/* aligned. */
+	eth->rx_buf_base =
+		(u8 *)memalign(RAVB_ALIGN, alloc_buf_size);
+	if (!eth->rx_buf_base) {
+		printf(CARDNAME ": alloc failed\n");
+		ret = -ENOMEM;
+		goto err_buf_alloc;
+	}
+	memset(eth->rx_buf_base, 0x0, alloc_buf_size);
+	ravb_flush_dcache((u32)eth->rx_buf_base, alloc_buf_size);
+
+	/* Initialize all descriptors */
+	memset(eth->rx_desc_base, 0x0, alloc_desc_size);
+	for (cur_rx_desc = eth->rx_desc_base,
+	     rx_buf = eth->rx_buf_base, i = 0;
+	     i < NUM_RX_DESC; cur_rx_desc++, rx_buf += MAX_BUF_SIZE, i++) {
+		cur_rx_desc->dt = DT_FEMPTY;
+		cur_rx_desc->ds = MAX_BUF_SIZE;
+		cur_rx_desc->dptr = (u32)rx_buf;
+	}
+	/* Mark the end of the descriptors */
+	cur_rx_desc->dt = DT_LINKFIX;
+	cur_rx_desc->dptr = (u32)eth->rx_desc_base;
+	ravb_flush_dcache((u32)eth->rx_desc_base, alloc_desc_size);
+
+	/* Point the controller to the rx descriptor list */
+	desc = &eth->desc_bat_base[RX_QUEUE];
+	desc->dt = DT_LINKFIX;
+	desc->dptr = (u32)eth->rx_desc_base;
+	ravb_flush_dcache((u32)desc, sizeof(struct ravb_desc));
+
+	return ret;
+
+err_buf_alloc:
+	free(eth->rx_desc_base);
+	eth->rx_desc_base = NULL;
+
+err:
+	return ret;
+}
+
+static void ravb_desc_bat_free(struct ravb_dev *eth)
+{
+	if (eth->desc_bat_base) {
+		free(eth->desc_bat_base);
+		eth->desc_bat_base = NULL;
+	}
+}
+
+static void ravb_tx_desc_free(struct ravb_dev *eth)
+{
+	if (eth->tx_desc_base) {
+		free(eth->tx_desc_base);
+		eth->tx_desc_base = NULL;
+	}
+}
+
+static void ravb_rx_desc_free(struct ravb_dev *eth)
+{
+	if (eth->rx_desc_base) {
+		free(eth->rx_desc_base);
+		eth->rx_desc_base = NULL;
+	}
+
+	if (eth->rx_buf_base) {
+		free(eth->rx_buf_base);
+		eth->rx_buf_base = NULL;
+	}
+}
+
+static int ravb_desc_init(struct ravb_dev *eth)
+{
+	int ret = 0;
+
+	ret = ravb_tx_desc_init(eth);
+	if (ret)
+		goto err_tx_init;
+
+	ret = ravb_rx_desc_init(eth);
+	if (ret)
+		goto err_rx_init;
+
+	return ret;
+
+err_rx_init:
+	ravb_tx_desc_free(eth);
+
+err_tx_init:
+	return ret;
+}
+
+static int ravb_phy_config(struct ravb_dev *eth)
+{
+	int ret = 0;
+	struct eth_device *dev = eth->dev;
+	struct phy_device *phydev;
+
+#ifdef CONFIG_IWG23S
+	int addr;
+         for (addr = 0; addr <  32; addr++)
+        {
+                phydev = phy_connect(
+                        miiphy_get_dev_by_name(dev->name),
+                        addr, dev, CONFIG_RAVB_PHY_MODE);
+                if (phydev == NULL)
+                        continue;
+                else
+                {
+                        printf("PHY detected at addr %d\n", addr);
+                        break;
+                }
+
+        }
+#else
+	phydev = phy_connect(
+			miiphy_get_dev_by_name(dev->name),
+			eth->phy_addr, dev, CONFIG_RAVB_PHY_MODE);
+#endif
+	if (!phydev)
+		return -1;
+
+	eth->phydev = phydev;
+	phy_config(phydev);
+
+	/* 10BASE is not supported for Ethernet AVB MAC */
+	phydev->supported &= ~(SUPPORTED_10baseT_Full
+			       | SUPPORTED_10baseT_Half);
+
+	return ret;
+}
+
+/* Set Mac address */
+static int ravb_write_hwaddr(struct eth_device *dev)
+{
+	struct ravb_dev *eth = dev->priv;
+	u32 val;
+	val = dev->enetaddr[0] << 24 | dev->enetaddr[1] << 16 |
+	      dev->enetaddr[2] << 8 | dev->enetaddr[3];
+	ravb_write(eth, val, MAHR);
+
+	val = dev->enetaddr[4] << 8 | dev->enetaddr[5];
+	ravb_write(eth, val, MALR);
+
+	return 0;
+}
+
+/* E-MAC init function */
+static int ravb_mac_init(struct ravb_dev *eth)
+{
+	struct eth_device *dev = eth->dev;
+
+	/* Disable MAC Interrupt */
+	ravb_write(eth, 0, ECSIPR);
+
+	/* Recv frame limit set register */
+	ravb_write(eth, RFLR_RFL_MIN, RFLR);
+
+	/* Set Mac address */
+	ravb_write_hwaddr(dev);
+
+	return 0;
+}
+
+/* AVB-DMAC init function */
+static int ravb_dmac_init(struct ravb_dev *eth)
+{
+	int ret = 0;
+
+	/* Set CONFIG mode */
+	ret = ravb_reset(eth);
+	if (ret)
+		return ret;
+
+	/* Disable all interrupts */
+	ravb_write(eth, 0, RIC0);
+	ravb_write(eth, 0, RIC1);
+	ravb_write(eth, 0, RIC2);
+	ravb_write(eth, 0, TIC);
+
+#if defined(__LITTLE_ENDIAN)
+	ravb_write(eth, ravb_read(eth, CCC) & ~CCC_BOC, CCC);
+#else
+	ravb_write(eth, ravb_read(eth, CCC) | CCC_BOC, CCC);
+#endif
+
+	/* AVB rx set */
+	ravb_write(eth, 0x18000001, RCR);
+
+	/* FIFO size set */
+	ravb_write(eth, 0x00222210, TGC);
+
+	return ret;
+}
+
+static int ravb_config(struct ravb_dev *eth, bd_t *bd)
+{
+	int ret = 0;
+	struct phy_device *phy;
+
+	/* Configure AVB-DMAC register */
+	ravb_dmac_init(eth);
+
+	/* Configure E-MAC registers */
+	ravb_mac_init(eth);
+
+	/* Configure phy */
+	ret = ravb_phy_config(eth);
+	if (ret) {
+		printf(CARDNAME ": Fail to connect phy\n");
+		goto err_phy_cfg;
+	}
+	phy = eth->phydev;
+
+	ret = phy_startup(phy);
+	if (ret) {
+		printf(CARDNAME ": phy startup failure\n");
+		return ret;
+	}
+
+	/* Set the transfer speed */
+	if (phy->speed == 100) {
+		printf(CARDNAME ": 100Base/");
+		ravb_write(eth, 0, GECMR);
+	} else if (phy->speed == 1000) {
+		printf(CARDNAME ": 1000Base/");
+		ravb_write(eth, 1, GECMR);
+	}
+
+	/* Check if full duplex mode is supported by the phy */
+	if (phy->duplex) {
+		printf("Full\n");
+		ravb_write(eth, ECMR_CHG_DM | ECMR_RE | ECMR_TE | ECMR_DM,
+			   ECMR);
+	} else {
+		printf("Half\n");
+		ravb_write(eth, ECMR_CHG_DM | ECMR_RE | ECMR_TE, ECMR);
+	}
+
+	return ret;
+
+err_phy_cfg:
+	return ret;
+}
+
+static void ravb_start(struct ravb_dev *eth)
+{
+	/* Setting the control will start the AVB-DMAC process. */
+	ravb_write(eth, CCC_OPC_OPERATION, CCC);
+}
+
+int ravb_init(struct eth_device *dev, bd_t *bd)
+{
+	int ret = 0;
+	struct ravb_dev *eth = dev->priv;
+
+	ret = ravb_reset(eth);
+	if (ret)
+		goto err;
+
+	ret = ravb_desc_bat_init(eth);
+	if (ret)
+		goto err;
+
+	ret = ravb_desc_init(eth);
+	if (ret)
+		goto err;
+
+	ret = ravb_config(eth, bd);
+	if (ret)
+		goto err_config;
+
+	ravb_start(eth);
+
+	return ret;
+
+err_config:
+	ravb_tx_desc_free(eth);
+	ravb_rx_desc_free(eth);
+	ravb_desc_bat_free(eth);
+err:
+	return ret;
+}
+
+static void ravb_stop(struct ravb_dev *eth)
+{
+	/* Setting the control will stop the Hardware process. */
+	ravb_write(eth, CCC_OPC_RESET, CCC);
+}
+
+static void ravb_halt(struct eth_device *dev)
+{
+	struct ravb_dev *eth = dev->priv;
+	ravb_reset(eth);
+	ravb_stop(eth);
+}
+
+int ravb_initialize(bd_t *bd)
+{
+	int ret = 0;
+	struct ravb_dev *eth = NULL;
+	struct eth_device *dev = NULL;
+
+	eth = (struct ravb_dev *)malloc(sizeof(struct ravb_dev));
+	if (!eth) {
+		printf(CARDNAME ": %s: malloc failed\n", __func__);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev = (struct eth_device *)malloc(sizeof(struct eth_device));
+	if (!dev) {
+		printf(CARDNAME ": %s: malloc failed\n", __func__);
+		ret = -ENOMEM;
+		goto err;
+	}
+	memset(dev, 0, sizeof(struct eth_device));
+	memset(eth, 0, sizeof(struct ravb_dev));
+
+	eth->phy_addr = CONFIG_RAVB_PHY_ADDR;
+
+	dev->priv = (void *)eth;
+	dev->iobase = 0;
+	dev->init = ravb_init;
+	dev->halt = ravb_halt;
+	dev->send = ravb_send;
+	dev->recv = ravb_recv;
+	dev->write_hwaddr = ravb_write_hwaddr;
+	eth->dev = dev;
+
+	sprintf(dev->name, CARDNAME);
+
+	/* Register Device to EtherNet subsystem */
+	eth_register(dev);
+
+	bb_miiphy_buses[dev->index].priv = eth;
+	miiphy_register(dev->name, bb_miiphy_read, bb_miiphy_write);
+
+	return ret;
+
+err:
+	if (dev)
+		free(dev);
+
+	if (eth)
+		free(eth);
+
+	printf(CARDNAME ": Failed\n");
+	return ret;
+}
+
+/******* for bb_miiphy *******/
+int ravb_bb_init(struct bb_miiphy_bus *bus)
+{
+	return 0;
+}
+
+int ravb_bb_mdio_active(struct bb_miiphy_bus *bus)
+{
+	struct ravb_dev *eth = bus->priv;
+
+	ravb_write(eth, ravb_read(eth, PIR) | PIR_MMD, PIR);
+
+	return 0;
+}
+
+int ravb_bb_mdio_tristate(struct bb_miiphy_bus *bus)
+{
+	struct ravb_dev *eth = bus->priv;
+
+	ravb_write(eth, ravb_read(eth, PIR) & ~PIR_MMD, PIR);
+
+	return 0;
+}
+
+int ravb_bb_set_mdio(struct bb_miiphy_bus *bus, int v)
+{
+	struct ravb_dev *eth = bus->priv;
+
+	if (v)
+		ravb_write(eth, ravb_read(eth, PIR) | PIR_MDO, PIR);
+	else
+		ravb_write(eth, ravb_read(eth, PIR) & ~PIR_MDO, PIR);
+
+	return 0;
+}
+
+int ravb_bb_get_mdio(struct bb_miiphy_bus *bus, int *v)
+{
+	struct ravb_dev *eth = bus->priv;
+
+	*v = (ravb_read(eth, PIR) & PIR_MDI) >> 3;
+
+	return 0;
+}
+
+int ravb_bb_set_mdc(struct bb_miiphy_bus *bus, int v)
+{
+	struct ravb_dev *eth = bus->priv;
+
+	if (v)
+		ravb_write(eth, ravb_read(eth, PIR) | PIR_MDC, PIR);
+	else
+		ravb_write(eth, ravb_read(eth, PIR) & ~PIR_MDC, PIR);
+
+	return 0;
+}
+
+int ravb_bb_delay(struct bb_miiphy_bus *bus)
+{
+	udelay(10);
+
+	return 0;
+}
diff --git a/drivers/net/ravb.h b/drivers/net/ravb.h
new file mode 100644
index 0000000..2634fba
--- /dev/null
+++ b/drivers/net/ravb.h
@@ -0,0 +1,917 @@
+/*
+ * ravb.h - Driver for Renesas Ethernet AVB.
+ *
+ * Copyright (C) 2015  Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <netdev.h>
+#include <asm/types.h>
+
+#define CARDNAME "ravb"
+
+#define NUM_TX_DESC	8
+#define NUM_RX_DESC	64
+#define RAVB_ALIGN	128
+
+/* Buffers must be big enough to hold the largest ethernet frame. Also, rx
+   buffers must be a multiple of 128 bytes */
+#define MAX_BUF_SIZE	(RAVB_ALIGN * 12)
+
+/* The ethernet avb descriptor definitions. */
+enum DT {
+	/* frame data */
+	DT_FSTART    = 5,
+	DT_FMID      = 4,
+	DT_FEND      = 6,
+	DT_FSINGLE   = 7,
+	/* chain control */
+	DT_LINK      = 8,
+	DT_LINKFIX   = 9,
+	DT_EOS       = 10,
+	/* HW/SW arbitration */
+	DT_FEMPTY    = 12,
+	DT_FEMPTY_IS = 13,
+	DT_FEMPTY_IC = 14,
+	DT_FEMPTY_ND = 15,
+	DT_LEMPTY    = 2,
+	DT_EEMPTY    = 3,
+	/* 0,1,11 is reserved */
+};
+
+struct ravb_desc {
+#if defined(__LITTLE_ENDIAN)
+	volatile u32 ds:12;	/* descriptor size */
+	volatile u32 cc:12;	/* content control */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 dt:4;	/* dscriotor type */
+#else
+	volatile u32 dt:4;	/* dscriotor type */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 cc:12;	/* content control */
+	volatile u32 ds:12;	/* descriptor size */
+#endif
+	volatile u32 dptr;	/* descpriptor pointer */
+};
+
+/* MAC reception status */
+enum MSC {
+	MSC_MC   = 1<<7, /* [7] Multicast frame reception */
+	MSC_CEEF = 1<<6, /* [6] Carrier extension error */
+	MSC_CRL  = 1<<5, /* [5] Carrier lost */
+	MSC_FRE  = 1<<4, /* [4] Fraction error (isn't a multiple of 8bits) */
+	MSC_RTLF = 1<<3, /* [3] Frame length error (frame too long) */
+	MSC_RTSF = 1<<2, /* [2] Frame length error (frame too short) */
+	MSC_RFE  = 1<<1, /* [1] Frame reception error (flagged by PHY) */
+	MSC_CRC  = 1<<0, /* [0] Frame CRC error */
+};
+
+#define MSC_RX_ERR_MASK (MSC_CRC | MSC_RFE | MSC_RTLF | MSC_RTSF | MSC_CEEF)
+
+struct ravb_txdesc {
+#if defined(__LITTLE_ENDIAN)
+	volatile u32 ds:12;	/* descriptor size */
+	volatile u32 tag:10;	/* frame tag */
+	volatile u32 tsr:1;	/* timestamp storeage request */
+	volatile u32 msc:1;	/* mac status storeage request */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 dt:4;	/* dscriotor type */
+#else
+	volatile u32 dt:4;	/* dscriotor type */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 msc:1;	/* mac status storeage request */
+	volatile u32 tsr:1;	/* timestamp storeage request */
+	volatile u32 tag:10;	/* frame tag */
+	volatile u32 ds:12;	/* descriptor size */
+#endif
+	volatile u32 dptr;	/* descpriptor pointer */
+};
+
+struct ravb_rxdesc {
+#if defined(__LITTLE_ENDIAN)
+	volatile u32 ds:12;	/* descriptor size */
+	volatile u32 ei:1;	/* error indication */
+	volatile u32 ps:2;	/* padding selection */
+	volatile u32 tr:1;	/* truncation indication */
+	volatile u32 msc:8;	/* mac status code */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 dt:4;	/* dscriotor type */
+#else
+	volatile u32 dt:4;	/* dscriotor type */
+	volatile u32 die:4;	/* descriptor interrupt enable */
+			/* 0:disable, other:enable */
+	volatile u32 msc:8;	/* mac status code */
+	volatile u32 ps:2;	/* padding selection */
+	volatile u32 ei:1;	/* error indication */
+	volatile u32 tr:1;	/* truncation indication */
+	volatile u32 ds:12;	/* descriptor size */
+#endif
+	volatile u32 dptr;	/* descpriptor pointer */
+};
+
+#define DBAT_ENTRY_NUM	(22)
+#define TX_QUEUE	(0)
+#define RX_QUEUE	(4)
+
+#define RFLR_RFL_MIN	0x05EE	/* Recv Frame length 1518 byte */
+
+struct ravb_dev {
+	struct ravb_desc *desc_bat_alloc;
+	struct ravb_desc *desc_bat_base;
+	struct ravb_txdesc *tx_desc_alloc;
+	struct ravb_txdesc *tx_desc_base;
+	struct ravb_txdesc *tx_desc_cur;
+	struct ravb_rxdesc *rx_desc_alloc;
+	struct ravb_rxdesc *rx_desc_base;
+	struct ravb_rxdesc *rx_desc_cur;
+	u8 *rx_buf_alloc;
+	u8 *rx_buf_base;
+	u8 mac_addr[6];
+	u8 phy_addr;
+	struct eth_device *dev;
+	struct phy_device *phydev;
+};
+
+/* from linux/drivers/net/ethernet/renesas/ravb.h */
+enum {
+	/* AVB-DMAC specific registers */
+	CCC,
+	DBAT,
+	DLR,
+	CSR,
+	CDAR0,
+	CDAR1,
+	CDAR2,
+	CDAR3,
+	CDAR4,
+	CDAR5,
+	CDAR6,
+	CDAR7,
+	CDAR8,
+	CDAR9,
+	CDAR10,
+	CDAR11,
+	CDAR12,
+	CDAR13,
+	CDAR14,
+	CDAR15,
+	CDAR16,
+	CDAR17,
+	CDAR18,
+	CDAR19,
+	CDAR20,
+	CDAR21,
+	ESR,
+	RCR,
+	RQC,
+	RPC,
+	UFCW,
+	UFCS,
+	UFCV0,
+	UFCV1,
+	UFCV2,
+	UFCV3,
+	UFCV4,
+	UFCD0,
+	UFCD1,
+	UFCD2,
+	UFCD3,
+	UFCD4,
+	SFO,
+	SFP0,
+	SFP1,
+	SFP2,
+	SFP3,
+	SFP4,
+	SFP5,
+	SFP6,
+	SFP7,
+	SFP8,
+	SFP9,
+	SFP10,
+	SFP11,
+	SFP12,
+	SFP13,
+	SFP14,
+	SFP15,
+	SFP16,
+	SFP17,
+	SFP18,
+	SFP19,
+	SFP20,
+	SFP21,
+	SFP22,
+	SFP23,
+	SFP24,
+	SFP25,
+	SFP26,
+	SFP27,
+	SFP28,
+	SFP29,
+	SFP30,
+	SFP31,
+	SFM0,
+	SFM1,
+	RTSR,
+	CIAR,
+	LIAR,
+	TGC,
+	TCCR,
+	TSR,
+	MFA,
+	TFA0,
+	TFA1,
+	TFA2,
+	CIVR0,
+	CIVR1,
+	CDVR0,
+	CDVR1,
+	CUL0,
+	CUL1,
+	CLL0,
+	CLL1,
+	DIC,
+	DIS,
+	EIC,
+	EIS,
+	RIC0,
+	RIS0,
+	RIC1,
+	RIS1,
+	RIC2,
+	RIS2,
+	TIC,
+	TIS,
+	ISS,
+	GCCR,
+	GMTT,
+	GPTC,
+	GTI,
+	GTO0,
+	GTO1,
+	GTO2,
+	GIC,
+	GIS,
+	GCPT,
+	GCT0,
+	GCT1,
+	GCT2,
+
+	/* Ether registers */
+	ECMR,
+	ECSR,
+	ECSIPR,
+	PIR,
+	PSR,
+	RDMLR,
+	PIPR,
+	RFLR,
+	IPGR,
+	APR,
+	MPR,
+	PFTCR,
+	PFRCR,
+	RFCR,
+	RFCF,
+	TPAUSER,
+	TPAUSECR,
+	BCFR,
+	BCFRR,
+	GECMR,
+	BCULR,
+	MAHR,
+	MALR,
+	TROCR,
+	CDCR,
+	LCCR,
+	CNDCR,
+	CEFCR,
+	FRECR,
+	TSFRCR,
+	TLFRCR,
+	CERCR,
+	CEECR,
+	MAFCR,
+	RTRATE,
+	CSMR,
+
+	/* This value must be written at last. */
+	RAVB_MAX_REGISTER_OFFSET,
+};
+
+static const u16 ravb_offset_rcar_gen2[RAVB_MAX_REGISTER_OFFSET] = {
+	/* AVB-DMAC registers */
+	[CCC] = 0x0000,
+	[DBAT] = 0x0004,
+	[DLR] = 0x0008,
+	[CSR] = 0x000C,
+	[CDAR0] = 0x0010,
+	[CDAR1] = 0x0014,
+	[CDAR2] = 0x0018,
+	[CDAR3] = 0x001C,
+	[CDAR4] = 0x0020,
+	[CDAR5] = 0x0024,
+	[CDAR6] = 0x0028,
+	[CDAR7] = 0x002C,
+	[CDAR8] = 0x0030,
+	[CDAR9] = 0x0034,
+	[CDAR10] = 0x0038,
+	[CDAR11] = 0x003C,
+	[CDAR12] = 0x0040,
+	[CDAR13] = 0x0044,
+	[CDAR14] = 0x0048,
+	[CDAR15] = 0x004C,
+	[CDAR16] = 0x0050,
+	[CDAR17] = 0x0054,
+	[CDAR18] = 0x0058,
+	[CDAR19] = 0x005C,
+	[CDAR20] = 0x0060,
+	[CDAR21] = 0x0064,
+	[ESR] = 0x0088,
+	[PSR] = 0x008C,
+	[RCR] = 0x0090,
+	[RQC] = 0x0094,
+	[RPC] = 0x00B0,
+	[UFCW] = 0x00BC,
+	[UFCS] = 0x00C0,
+	[UFCV0] = 0x00C4,
+	[UFCV1] = 0x00C8,
+	[UFCV2] = 0x00CC,
+	[UFCV3] = 0x00D0,
+	[UFCV4] = 0x00D4,
+	[UFCD0] = 0x00E0,
+	[UFCD1] = 0x00E4,
+	[UFCD2] = 0x00E8,
+	[UFCD3] = 0x00EC,
+	[UFCD4] = 0x00F0,
+	[SFO] = 0x00FC,
+	[SFP0] = 0x0100,
+	[SFP1] = 0x0104,
+	[SFP2] = 0x0108,
+	[SFP3] = 0x010c,
+	[SFP4] = 0x0110,
+	[SFP5] = 0x0114,
+	[SFP6] = 0x0118,
+	[SFP7] = 0x011c,
+	[SFP8] = 0x0120,
+	[SFP9] = 0x0124,
+	[SFP10] = 0x0128,
+	[SFP11] = 0x012c,
+	[SFP12] = 0x0130,
+	[SFP13] = 0x0134,
+	[SFP14] = 0x0138,
+	[SFP15] = 0x013c,
+	[SFP16] = 0x0140,
+	[SFP17] = 0x0144,
+	[SFP18] = 0x0148,
+	[SFP19] = 0x014c,
+	[SFP20] = 0x0150,
+	[SFP21] = 0x0154,
+	[SFP22] = 0x0158,
+	[SFP23] = 0x015c,
+	[SFP24] = 0x0160,
+	[SFP25] = 0x0164,
+	[SFP26] = 0x0168,
+	[SFP27] = 0x016c,
+	[SFP28] = 0x0170,
+	[SFP29] = 0x0174,
+	[SFP30] = 0x0178,
+	[SFP31] = 0x017c,
+	[SFM0] = 0x01C0,
+	[SFM1] = 0x01C4,
+	[RTSR] = 0x01D0,
+	[CIAR] = 0x0200,
+	[LIAR] = 0x0280,
+	[TGC] = 0x0300,
+	[TCCR] = 0x0304,
+	[TSR] = 0x0308,
+	[MFA] = 0x030C,
+	[TFA0] = 0x0310,
+	[TFA1] = 0x0314,
+	[TFA2] = 0x0318,
+	[CIVR0] = 0x0320,
+	[CIVR1] = 0x0324,
+	[CDVR0] = 0x0328,
+	[CDVR1] = 0x032C,
+	[CUL0] = 0x0330,
+	[CUL1] = 0x0334,
+	[CLL0] = 0x0338,
+	[CLL1] = 0x033C,
+	[DIC] = 0x0350,
+	[DIS] = 0x0354,
+	[EIC] = 0x0358,
+	[EIS] = 0x035C,
+	[RIC0] = 0x0360,
+	[RIS0] = 0x0364,
+	[RIC1] = 0x0368,
+	[RIS1] = 0x036C,
+	[RIC2] = 0x0370,
+	[RIS2] = 0x0374,
+	[TIC] = 0x0378,
+	[TIS] = 0x037C,
+	[ISS] = 0x0380,
+	[GCCR] = 0x0390,
+	[GMTT] 0x0394,
+	[GPTC] = 0x0398,
+	[GTI] = 0x039C,
+	[GTO0] = 0x03A0,
+	[GTO1] = 0x03A4,
+	[GTO2] = 0x03A8,
+	[GIC] = 0x03AC,
+	[GIS] = 0x03B0,
+	[GCPT] = 0x03B4,
+	[GCT0] = 0x03B8,
+	[GCT1] = 0x03BC,
+	[GCT2] = 0x03C0,
+
+	[ECMR]	= 0x0500,
+	[ECSR]	= 0x0510,
+	[ECSIPR]	= 0x0518,
+	[PIR]	= 0x0520,
+	[PSR]	= 0x0528,
+	[PIPR]	= 0x052c,
+	[RFLR]	= 0x0508,
+	[APR]	= 0x0554,
+	[MPR]	= 0x0558,
+	[PFTCR]	= 0x055c,
+	[PFRCR]	= 0x0560,
+	[TPAUSER]	= 0x0564,
+	[GECMR]	= 0x05b0,
+	[BCULR]	= 0x05b4,
+	[MAHR]	= 0x05c0,
+	[MALR]	= 0x05c8,
+	[TROCR]	= 0x0700,
+	[CDCR]	= 0x0708,
+	[LCCR]	= 0x0710,
+	[CEFCR]	= 0x0740,
+	[FRECR]	= 0x0748,
+	[TSFRCR]	= 0x0750,
+	[TLFRCR]	= 0x0758,
+	[RFCR]	= 0x0760,
+	[CERCR]	= 0x0768,
+	[CEECR]	= 0x0770,
+	[MAFCR]	= 0x0778,
+};
+
+/* Register Address */
+#define BASE_IO_ADDR	0xE6800000
+
+/* Register's bits of Ethernet AVB */
+/* CCC */
+enum CCC_BIT {
+	CCC_OPC		= 0x00000003,
+	CCC_OPC_RESET	= 0x00000000,
+	CCC_OPC_CONFIG	= 0x00000001,
+	CCC_OPC_OPERATION = 0x00000002,
+	CCC_DTSR	= 0x00000100,
+	CCC_CSEL	= 0x00030000,
+	CCC_CSEL_HPB	= 0x00010000,
+	CCC_CSEL_ETH_TX	= 0x00020000,
+	CCC_CSEL_GMII_REF = 0x00030000,
+	CCC_BOC		= 0x00100000,
+	CCC_LBME	= 0x01000000,
+};
+
+/* CSR */
+enum CSR_BIT {
+	CSR_OPS		= 0x0000000F,
+	CSR_OPS_RESET	= 0x00000001,
+	CSR_OPS_CONFIG	= 0x00000002,
+	CSR_OPS_OPERATION = 0x00000004,
+	CSR_DTS		= 0x00000100,
+	CSR_TPO0	= 0x00010000,
+	CSR_TPO1	= 0x00020000,
+	CSR_TPO2	= 0x00040000,
+	CSR_TPO3	= 0x00080000,
+	CSR_RPO		= 0x00100000,
+};
+
+enum ESR_BIT {
+	ESR_EQN	= 0x0000000f,
+	ESR_ET	= 0x00000f00,
+	ESR_EIL	= 0x00001000,
+};
+
+enum RCR_BIT {
+	RCR_EFFS	= 0x00000001,
+	RCR_ENCF	= 0x00000002,
+	RCR_ESF	= 0x0000000c,
+	RCR_ETS0	= 0x00000010,
+	RCR_ETS2	= 0x00000020,
+	RCR_RFCL	= 0x1fff0000,
+};
+
+enum RQC_BIT {
+	RQC_RSM0	= 0x00000003,
+	TSEL0	= 0x00000004,
+	UFCC0	= 0x00000030,
+	RQC_RSM1	= 0x00000300,
+	TSEL1	= 0x00000400,
+	UFCC1	= 0x00003000,
+	RQC_RSM2	= 0x00030000,
+	TSEL2	= 0x00040000,
+	UFCC2	= 0x00300000,
+	RQC_RSM3	= 0x03000000,
+	TSEL3	= 0x04000000,
+	UFCC3	= 0x30000000,
+};
+
+enum RPC_BIT {
+	RPC_PCNT	= 0x00000700,
+	RPC_DCNT	= 0x00ff0000,
+};
+
+enum RTC_BIT {
+	RTC_MFL0	= 0x00000fff,
+	RTC_MFL1	= 0x0fff0000,
+};
+
+enum UFCW_BIT {
+	UFCW_WL0	= 0x0000003f,
+	UFCW_WL1	= 0x00003f00,
+	UFCW_WL2	= 0x003f0000,
+	UFCW_WL3	= 0x3f000000,
+};
+
+enum UFCS_BIT {
+	UFCS_SL0	= 0x0000003f,
+	UFCS_SL1	= 0x00003f00,
+	UFCS_SL2	= 0x003f0000,
+	UFCS_SL3	= 0x3f000000,
+};
+
+enum UFCV_BIT {
+	UFCV_CV0	= 0x0000003f,
+	UFCV_CV1	= 0x00003f00,
+	UFCV_CV2	= 0x003f0000,
+	UFCV_CV3	= 0x3f000000,
+};
+
+enum UFCD_BIT {
+	UFCD_DV0	= 0x0000003f,
+	UFCD_DV1	= 0x00003f00,
+	UFCD_DV2	= 0x003f0000,
+	UFCD_DV3	= 0x3f000000,
+};
+
+enum SFO_BIT {
+	SFO_FPB	= 0x0000003f,
+};
+
+enum TGC_BIT {
+	TGC_TSM0	= 0x00000001,
+	TGC_TSM1	= 0x00000002,
+	TGC_TSM2	= 0x00000004,
+	TGC_TSM3	= 0x00000008,
+	TGC_TQP	= 0x00000030,
+	TGC_TBD0	= 0x00000300,
+	TGC_TBD1	= 0x00003000,
+	TGC_TBD2	= 0x00030000,
+	TGC_TBD3	= 0x00300000,
+};
+
+enum TCCR_BIT {
+	TCCR_TSRQ0	= 0x00000001,
+	TCCR_TSRQ1	= 0x00000002,
+	TCCR_TSRQ2	= 0x00000004,
+	TCCR_TSRQ3	= 0x00000008,
+	TCCR_TFEN	= 0x00000100,
+	TCCR_TFR	= 0x00000200,
+	TCCR_MFEN	= 0x00010000,
+	TCCR_MFR	= 0x00020000,
+};
+
+enum TSR_BIT {
+	TSR_CCS0	= 0x00000003,
+	TSR_CCS1	= 0x0000000c,
+	TSR_TFFL	= 0x00000700,
+	TSR_MFFL	= 0x001f0000,
+};
+
+enum MFA_BIT {
+	MFA_MSV	= 0x0000000f,
+	MFA_MST	= 0x03ff0000,
+};
+
+enum GCCR_BIT {
+	GCCR_TCR	= 0x00000003,
+	GCCR_LTO	= 0x00000004,
+	GCCR_LTI	= 0x00000008,
+	GCCR_LPTC	= 0x00000010,
+	GCCR_LMTT	= 0x00000020,
+	GCCR_TCSS	= 0x00000300,
+};
+
+enum DIC_BIT {
+	DIC_DPE1	= 0x00000002,
+	DIC_DPE2	= 0x00000004,
+	DIC_DPE3	= 0x00000008,
+	DIC_DPE4	= 0x00000010,
+	DIC_DPE5	= 0x00000020,
+	DIC_DPE6	= 0x00000040,
+	DIC_DPE7	= 0x00000080,
+	DIC_DPE8	= 0x00000100,
+	DIC_DPE9	= 0x00000200,
+	DIC_DPE10	= 0x00000400,
+	DIC_DPE11	= 0x00000800,
+	DIC_DPE12	= 0x00001000,
+	DIC_DPE13	= 0x00002000,
+	DIC_DPE14	= 0x00004000,
+	DIC_DPE15	= 0x00008000,
+};
+
+enum DIS_BIT {
+	DIS_DPF1	= 0x00000002,
+	DIS_DPF2	= 0x00000004,
+	DIS_DPF3	= 0x00000008,
+	DIS_DPF4	= 0x00000010,
+	DIS_DPF5	= 0x00000020,
+	DIS_DPF6	= 0x00000040,
+	DIS_DPF7	= 0x00000080,
+	DIS_DPF8	= 0x00000100,
+	DIS_DPF9	= 0x00000200,
+	DIS_DPF10	= 0x00000400,
+	DIS_DPF11	= 0x00000800,
+	DIS_DPF12	= 0x00001000,
+	DIS_DPF13	= 0x00002000,
+	DIS_DPF14	= 0x00004000,
+	DIS_DPF15	= 0x00008000,
+};
+
+enum EIC_BIT {
+	EIC_MREE	= 0x00000001,
+	EIC_MTEE	= 0x00000002,
+	EIC_QEE	= 0x00000004,
+	EIC_SEE	= 0x00000008,
+	EIC_CLLE0	= 0x00000010,
+	EIC_CLLE1	= 0x00000020,
+	EIC_CULE0	= 0x00000040,
+	EIC_CULE1	= 0x00000080,
+	EIC_TFFE	= 0x00000100,
+	EIC_MFFE	= 0x00000200,
+};
+
+enum EIS_BIT {
+	EIS_MREF	= 0x00000001,
+	EIS_MTEF	= 0x00000002,
+	EIS_QEF	= 0x00000004,
+	EIS_SEF	= 0x00000008,
+	EIS_CLLF0	= 0x00000010,
+	EIS_CLLF1	= 0x00000020,
+	EIS_CULF0	= 0x00000040,
+	EIS_CULF1	= 0x00000080,
+	EIS_TFFF	= 0x00000100,
+	EIS_MFFF	= 0x00000200,
+	EIS_QFS	= 0x00010000,
+};
+
+enum RIC0_BIT {
+	RIC0_FRE0	= 0x00000001,
+	RIC0_FRE1	= 0x00000002,
+	RIC0_FRE2	= 0x00000004,
+	RIC0_FRE3	= 0x00000008,
+	RIC0_FRE4	= 0x00000010,
+	RIC0_FRE5	= 0x00000020,
+	RIC0_FRE6	= 0x00000040,
+	RIC0_FRE7	= 0x00000080,
+	RIC0_FRE8	= 0x00000100,
+	RIC0_FRE9	= 0x00000200,
+	RIC0_FRE10	= 0x00000400,
+	RIC0_FRE11	= 0x00000800,
+	RIC0_FRE12	= 0x00001000,
+	RIC0_FRE13	= 0x00002000,
+	RIC0_FRE14	= 0x00004000,
+	RIC0_FRE15	= 0x00008000,
+	RIC0_FRE16	= 0x00010000,
+	RIC0_FRE17	= 0x00020000,
+};
+
+enum RIS0_BIT {
+	RIS0_FRF0	= 0x00000001,
+	RIS0_FRF1	= 0x00000002,
+	RIS0_FRF2	= 0x00000004,
+	RIS0_FRF3	= 0x00000008,
+	RIS0_FRF4	= 0x00000010,
+	RIS0_FRF5	= 0x00000020,
+	RIS0_FRF6	= 0x00000040,
+	RIS0_FRF7	= 0x00000080,
+	RIS0_FRF8	= 0x00000100,
+	RIS0_FRF9	= 0x00000200,
+	RIS0_FRF10	= 0x00000400,
+	RIS0_FRF11	= 0x00000800,
+	RIS0_FRF12	= 0x00001000,
+	RIS0_FRF13	= 0x00002000,
+	RIS0_FRF14	= 0x00004000,
+	RIS0_FRF15	= 0x00008000,
+	RIS0_FRF16	= 0x00010000,
+	RIS0_FRF17	= 0x00020000,
+};
+
+enum RIC1_BIT {
+	RIC1_RWE0	= 0x00000001,
+	RIC1_RWE1	= 0x00000002,
+	RIC1_RWE2	= 0x00000004,
+	RIC1_RWE3	= 0x00000008,
+	RIC1_RWE4	= 0x00000010,
+	RIC1_RWE5	= 0x00000020,
+	RIC1_RWE6	= 0x00000040,
+	RIC1_RWE7	= 0x00000080,
+	RIC1_RWE8	= 0x00000100,
+	RIC1_RWE9	= 0x00000200,
+	RIC1_RWE10	= 0x00000400,
+	RIC1_RWE11	= 0x00000800,
+	RIC1_RWE12	= 0x00001000,
+	RIC1_RWE13	= 0x00002000,
+	RIC1_RWE14	= 0x00004000,
+	RIC1_RWE15	= 0x00008000,
+	RIC1_RWE16	= 0x00010000,
+	RIC1_RWE17	= 0x00020000,
+	RIC1_RFWE	= 0x80000000,
+};
+
+enum RIS1_BIT {
+	RIS1_RWF0	= 0x00000001,
+	RIS1_RWF1	= 0x00000002,
+	RIS1_RWF2	= 0x00000004,
+	RIS1_RWF3	= 0x00000008,
+	RIS1_RWF4	= 0x00000010,
+	RIS1_RWF5	= 0x00000020,
+	RIS1_RWF6	= 0x00000040,
+	RIS1_RWF7	= 0x00000080,
+	RIS1_RWF8	= 0x00000100,
+	RIS1_RWF9	= 0x00000200,
+	RIS1_RWF10	= 0x00000400,
+	RIS1_RWF11	= 0x00000800,
+	RIS1_RWF12	= 0x00001000,
+	RIS1_RWF13	= 0x00002000,
+	RIS1_RWF14	= 0x00004000,
+	RIS1_RWF15	= 0x00008000,
+	RIS1_RWF16	= 0x00010000,
+	RIS1_RWF17	= 0x00020000,
+	RIS1_RFWF	= 0x80000000,
+};
+
+enum RIC2_BIT {
+	RIC2_QFE0	= 0x00000001,
+	RIC2_QFE1	= 0x00000002,
+	RIC2_QFE2	= 0x00000004,
+	RIC2_QFE3	= 0x00000008,
+	RIC2_QFE4	= 0x00000010,
+	RIC2_QFE5	= 0x00000020,
+	RIC2_QFE6	= 0x00000040,
+	RIC2_QFE7	= 0x00000080,
+	RIC2_QFE8	= 0x00000100,
+	RIC2_QFE9	= 0x00000200,
+	RIC2_QFE10	= 0x00000400,
+	RIC2_QFE11	= 0x00000800,
+	RIC2_QFE12	= 0x00001000,
+	RIC2_QFE13	= 0x00002000,
+	RIC2_QFE14	= 0x00004000,
+	RIC2_QFE15	= 0x00008000,
+	RIC2_QFE16	= 0x00010000,
+	RIC2_QFE17	= 0x00020000,
+	RIC2_RFFE	= 0x80000000,
+};
+
+enum RIS2_BIT {
+	RIS2_QFF0	= 0x00000001,
+	RIS2_QFF1	= 0x00000002,
+	RIS2_QFF2	= 0x00000004,
+	RIS2_QFF3	= 0x00000008,
+	RIS2_QFF4	= 0x00000010,
+	RIS2_QFF5	= 0x00000020,
+	RIS2_QFF6	= 0x00000040,
+	RIS2_QFF7	= 0x00000080,
+	RIS2_QFF8	= 0x00000100,
+	RIS2_QFF9	= 0x00000200,
+	RIS2_QFF10	= 0x00000400,
+	RIS2_QFF11	= 0x00000800,
+	RIS2_QFF12	= 0x00001000,
+	RIS2_QFF13	= 0x00002000,
+	RIS2_QFF14	= 0x00004000,
+	RIS2_QFF15	= 0x00008000,
+	RIS2_QFF16	= 0x00010000,
+	RIS2_QFF17	= 0x00020000,
+	RIS2_RFFF	= 0x80000000,
+};
+
+
+enum TIC_BIT {
+	TIC_FTE0	= 0x00000001,
+	TIC_FTE1	= 0x00000002,
+	TIC_FTE2	= 0x00000004,
+	TIC_FTE3	= 0x00000008,
+	TIC_TFUE	= 0x00000100,
+	TIC_TFWE	= 0x00000200,
+	TIC_MFUE	= 0x00000400,
+	TIC_MFWE	= 0x00000800,
+};
+
+enum TIS_BIT {
+	TIS_FTF0	= 0x00000001,
+	TIS_FTF1	= 0x00000002,
+	TIS_FTF2	= 0x00000004,
+	TIS_FTF3	= 0x00000008,
+	TIS_TFUF	= 0x00000100,
+	TIS_TFWF	= 0x00000200,
+	TIS_MFUF	= 0x00000400,
+	TIS_MFWF	= 0x00000800,
+};
+
+enum GIC_BIT {
+	GIC_PTCE	= 0x00000001,
+	GIC_PTOE	= 0x00000002,
+	GIC_PTME	= 0x00000004,
+};
+
+enum GIS_BIT {
+	GIS_PTCF	= 0x00000001,
+	GIS_PTOF	= 0x00000002,
+	GIS_PTMF	= 0x00000004,
+};
+
+enum ISS_BIT {
+	ISS_FRS	= 0x00000001,
+	ISS_RWS	= 0x00000002,
+	ISS_FTS	= 0x00000004,
+	ISS_ES	= 0x00000040,
+	ISS_MS	= 0x00000080,
+	ISS_TFUS	= 0x00000100,
+	ISS_TFWS	= 0x00000200,
+	ISS_MFUS	= 0x00000400,
+	ISS_MFWA	= 0x00000800,
+	ISS_RFWS	= 0x00001000,
+	ISS_CGIS	= 0x00002000,
+	ISS_DPS1	= 0x00020000,
+	ISS_DPS2	= 0x00040000,
+	ISS_DPS3	= 0x00080000,
+	ISS_DPS4	= 0x00100000,
+	ISS_DPS5	= 0x00200000,
+	ISS_DPS6	= 0x00400000,
+	ISS_DPS7	= 0x00800000,
+	ISS_DPS8	= 0x01000000,
+	ISS_DPS9	= 0x02000000,
+	ISS_DPS10	= 0x04000000,
+	ISS_DPS11	= 0x08000000,
+	ISS_DPS12	= 0x10000000,
+	ISS_DPS13	= 0x20000000,
+	ISS_DPS14	= 0x40000000,
+	ISS_DPS15	= 0x80000000,
+};
+
+/* PIR */
+enum PIR_BIT {
+	PIR_MDI = 0x08, PIR_MDO = 0x04, PIR_MMD = 0x02, PIR_MDC = 0x01,
+};
+
+/* ECMR */
+enum ECMR_BIT {
+	ECMR_TRCCM = 0x04000000, ECMR_RCSC = 0x00800000, ECMR_DPAD = 0x00200000,
+	ECMR_RZPF = 0x00100000, ECMR_PFR = 0x00040000, ECMR_RXF = 0x00020000,
+	ECMR_MPDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,
+	ECMR_DM = 0x00000002, ECMR_PRM = 0x00000001,
+};
+
+#define ECMR_CHG_DM (ECMR_TRCCM | ECMR_RZPF | ECMR_PFR | ECMR_RXF)
+
+/* MPR */
+enum MPR_BIT {
+	MPR_MP = 0x00000001,
+};
+
+static inline unsigned long ravb_reg_addr(struct ravb_dev *eth,
+					    int enum_index)
+{
+	const u16 *reg_offset = ravb_offset_rcar_gen2;
+	return BASE_IO_ADDR + reg_offset[enum_index];
+}
+
+static inline void ravb_write(struct ravb_dev *eth, unsigned long data,
+				int enum_index)
+{
+	writel(data, ravb_reg_addr(eth, enum_index));
+}
+
+static inline unsigned long ravb_read(struct ravb_dev *eth,
+					int enum_index)
+{
+	return readl(ravb_reg_addr(eth, enum_index));
+}
diff --git a/drivers/net/sh_eth_miiphybb.c b/drivers/net/sh_eth_miiphybb.c
new file mode 100644
index 0000000..7002901
--- /dev/null
+++ b/drivers/net/sh_eth_miiphybb.c
@@ -0,0 +1,52 @@
+/*
+ * sh_eth_miiphybb.c - MII bit-bang driver for Renesas ethernet controler.
+ *
+ * Copyright (C) 2015  Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <config.h>
+#include <miiphy.h>
+
+#include "sh_eth_miiphybb.h"
+
+struct bb_miiphy_bus bb_miiphy_buses[] = {
+#ifdef CONFIG_SH_ETHER
+	{
+		.name		= "sh_eth",
+		.init		= sh_eth_bb_init,
+		.mdio_active	= sh_eth_bb_mdio_active,
+		.mdio_tristate	= sh_eth_bb_mdio_tristate,
+		.set_mdio	= sh_eth_bb_set_mdio,
+		.get_mdio	= sh_eth_bb_get_mdio,
+		.set_mdc	= sh_eth_bb_set_mdc,
+		.delay		= sh_eth_bb_delay,
+	},
+#endif
+#ifdef CONFIG_RAVB
+	{
+		.name		= "ravb",
+		.init		= ravb_bb_init,
+		.mdio_active	= ravb_bb_mdio_active,
+		.mdio_tristate	= ravb_bb_mdio_tristate,
+		.set_mdio	= ravb_bb_set_mdio,
+		.get_mdio	= ravb_bb_get_mdio,
+		.set_mdc	= ravb_bb_set_mdc,
+		.delay		= ravb_bb_delay,
+	},
+#endif
+};
+int bb_miiphy_buses_num = ARRAY_SIZE(bb_miiphy_buses);
diff --git a/drivers/net/sh_eth_miiphybb.h b/drivers/net/sh_eth_miiphybb.h
new file mode 100644
index 0000000..a730af2
--- /dev/null
+++ b/drivers/net/sh_eth_miiphybb.h
@@ -0,0 +1,41 @@
+/*
+ * sh_eth_miiphybb.h - MII bit-bang driver for Renesas ethernet controler.
+ *
+ * Copyright (C) 2015  Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <config.h>
+#include <miiphy.h>
+
+#ifdef CONFIG_SH_ETHER
+extern int sh_eth_bb_init(struct bb_miiphy_bus *bus);
+extern int sh_eth_bb_mdio_active(struct bb_miiphy_bus *bus);
+extern int sh_eth_bb_mdio_tristate(struct bb_miiphy_bus *bus);
+extern int sh_eth_bb_set_mdio(struct bb_miiphy_bus *bus, int v);
+extern int sh_eth_bb_get_mdio(struct bb_miiphy_bus *bus, int *v);
+extern int sh_eth_bb_set_mdc(struct bb_miiphy_bus *bus, int v);
+extern int sh_eth_bb_delay(struct bb_miiphy_bus *bus);
+#endif
+#ifdef CONFIG_RAVB
+extern int ravb_bb_init(struct bb_miiphy_bus *bus);
+extern int ravb_bb_mdio_active(struct bb_miiphy_bus *bus);
+extern int ravb_bb_mdio_tristate(struct bb_miiphy_bus *bus);
+extern int ravb_bb_set_mdio(struct bb_miiphy_bus *bus, int v);
+extern int ravb_bb_get_mdio(struct bb_miiphy_bus *bus, int *v);
+extern int ravb_bb_set_mdc(struct bb_miiphy_bus *bus, int v);
+extern int ravb_bb_delay(struct bb_miiphy_bus *bus);
+#endif
diff --git a/drivers/serial/serial_sh.c b/drivers/serial/serial_sh.c
index edfaae2..826e6d7 100644
--- a/drivers/serial/serial_sh.c
+++ b/drivers/serial/serial_sh.c
@@ -71,6 +71,12 @@ static void sh_serial_setbrg(void)
 #else
 	sci_out(&sh_sci, SCBRR, SCBRR_VALUE(gd->baudrate, CONFIG_SCIF_CLK_FREQ));
 #endif
+#if defined(CONFIG_IWG23S)
+	sci_out(&sh_sci, SCBRR, SCBRR_VALUE(gd->baudrate, CONFIG_SYS_CLK_FREQ));
+#else
+	sci_out(&sh_sci, DL, DL_VALUE(gd->baudrate, CONFIG_SCIF_CLK_FREQ));
+	udelay((1000000 * 2 * 16 / CONFIG_SYS_CLK_FREQ) * 1000 + 1);
+#endif
 #else
 	sci_out(&sh_sci, SCBRR, SCBRR_VALUE(gd->baudrate, CONFIG_SYS_CLK_FREQ));
 #endif
diff --git a/drivers/serial/serial_sh.h b/drivers/serial/serial_sh.h
index 84b4de5..2355d8e 100644
--- a/drivers/serial/serial_sh.h
+++ b/drivers/serial/serial_sh.h
@@ -234,6 +234,11 @@ struct uart_port {
 #else
 	# define SCSCR_INIT(port)	0x30	/* TIE=0,RIE=0,TE=1,RE=1,REIE=0, */
 #endif
+#if defined(CONFIG_IWG23S)
+# define SCSCR_INIT(port)       0x30    /* TIE=0,RIE=0,TE=1,RE=1,REIE=0, */
+#else
+# define SCSCR_INIT(port)	0x32	/* TIE=0,RIE=0,TE=1,RE=1,REIE=0, */
+#endif
 #else
 # error CPU subtype not defined
 #endif
@@ -309,10 +314,10 @@ struct uart_port {
 # define SCIF2_RFDC_MASK 0x001f
 # define SCIF2_TXROOM_MAX 16
 #elif defined(CONFIG_R8A7790) || defined(CONFIG_R8A7791) || \
-	defined(CONFIG_R8A7793) || defined(CONFIG_R8A7794) || \
-	defined(CONFIG_R8A7743) || defined(CONFIG_R8A7745)
+	  defined(CONFIG_R8A7793) || defined(CONFIG_R8A7794) || \
+	  defined(CONFIG_R8A7743) || defined(CONFIG_R8A7745)
 # define SCIF_ERRORS (SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK)
-#  define SCIF_RFDC_MASK	0x001f
+# define SCIF_RFDC_MASK	0x003f
 #else
 # define SCIF_ERRORS (SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK)
 # define SCIF_RFDC_MASK 0x001f
@@ -760,7 +765,7 @@ static inline int scbrr_calc(struct uart_port port, int bps, int clk)
 	  defined(CONFIG_R8A7743) || defined(CONFIG_R8A7745) || \
 	  defined(CONFIG_R8A7794X)|| defined(CONFIG_R8A7747X)
 #define DL_VALUE(bps, clk) (clk / bps / 16) /* External Clock */
-#define SCBRR_VALUE(bps, clk) (clk / bps / 32 - 1) /* Internal Clock */
+#define SCBRR_VALUE(bps, clk) ((clk)/(32*bps)-1) /* Internal Clock */
 #else /* Generic SH */
 #define SCBRR_VALUE(bps, clk) ((clk+16*bps)/(32*bps)-1)
 #endif
diff --git a/drivers/usb/host/ehci-r8a779x.c b/drivers/usb/host/ehci-r8a779x.c
index 289d81b..1b006b5 100644
--- a/drivers/usb/host/ehci-r8a779x.c
+++ b/drivers/usb/host/ehci-r8a779x.c
@@ -36,6 +36,8 @@
 #define PHYS_OFFSET	SKRZG1M_SDRAM_BASE
 #elif defined(SKRZG1C_SDRAM_BASE)
 #define PHYS_OFFSET	SKRZG1C_SDRAM_BASE
+#elif defined(IWG23S_SDRAM_BASE)
+#define PHYS_OFFSET     IWG23S_SDRAM_BASE
 #else
 #error
 #endif
diff --git a/include/configs/iwg23s_Pi.h b/include/configs/iwg23s_Pi.h
new file mode 100644
index 0000000..98f317e
--- /dev/null
+++ b/include/configs/iwg23s_Pi.h
@@ -0,0 +1,241 @@
+/*
+ *
+ * Copyright (c) 2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __IWG23S_H
+#define __IWG23S_H
+
+#undef DEBUG
+#define CONFIG_ARMV7
+#define CONFIG_R8A7747X
+#define CONFIG_IWG23S
+#define CONFIG_RMOBILE
+#define CONFIG_RMOBILE_BOARD_STRING "R8A77947X iW-RainboW-G23S-Pi\n"
+#define CONFIG_SH_GPIO_PFC
+#define CONFIG_SYS_THUMB_BUILD
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_BOOTD
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_DEFAULT_FDT_FILE         "r8a7747x-iwg23s_Pi.dtb"
+#define CONFIG_SYS_HUSH_PARSER
+
+
+#include <asm/arch/rmobile.h>
+
+#define	CONFIG_CMD_EDITENV
+#define	CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_SDRAM
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_CMD_USB
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_EXT4_WRITE
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+
+#define	CONFIG_CMDLINE_TAG
+#define	CONFIG_SETUP_MEMORY_TAGS
+#define	CONFIG_INITRD_TAG
+#define	CONFIG_CMDLINE_EDITING
+
+#define CONFIG_OF_LIBFDT
+#define BOARD_LATE_INIT
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS		"console=ttySC1"
+
+#define CONFIG_VERSION_VARIABLE
+#undef	CONFIG_SHOW_BOOT_PROGRESS
+
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_USE_ARCH_MEMSET
+#define CONFIG_USE_ARCH_MEMCPY
+#define CONFIG_TMU_TIMER
+
+/* STACK */
+#if defined(CONFIG_EXTRAM_BOOT)
+#define CONFIG_SYS_INIT_SP_ADDR		0x7003FFFC
+#else
+#define CONFIG_SYS_INIT_SP_ADDR		0xE633FFFC
+#endif
+#define STACK_AREA_SIZE				0xC000
+#define LOW_LEVEL_MERAM_STACK	\
+		(CONFIG_SYS_INIT_SP_ADDR + STACK_AREA_SIZE - 4)
+
+/* MEMORY */
+#define IWG23S_SDRAM_BASE	0x40000000
+#define IWG23S_SDRAM_SIZE	0x20000000
+#define IWG23S_UBOOT_SDRAM_SIZE	0x20000000
+
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_PROMPT		"iWave-G23S> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_PBSIZE		256
+#define CONFIG_SYS_MAXARGS		32
+#define CONFIG_SYS_BARGSIZE		512
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 38400, 115200 }
+
+/* SCIF */
+#define CONFIG_SCIF_CONSOLE
+#define CONFIG_CONS_SCIF1
+#define SCIF1_BASE		0xE6E68000
+#undef	CONFIG_SYS_CONSOLE_INFO_QUIET
+#undef	CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#undef	CONFIG_SYS_CONSOLE_ENV_OVERWRITE
+
+#define CONFIG_SYS_MEMTEST_START	(IWG23S_SDRAM_BASE)
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + \
+					 504 * 1024 * 1024)
+#undef	CONFIG_SYS_IWG23S_MEMTEST
+#undef	CONFIG_SYS_MEMTEST_SCRATCH
+#undef	CONFIG_SYS_LOADS_BAUD_CHANGE
+
+#define CONFIG_SYS_SDRAM_BASE		(IWG23S_SDRAM_BASE)
+#define CONFIG_SYS_SDRAM_SIZE		(IWG23S_UBOOT_SDRAM_SIZE)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x7fc0)
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_SYS_MONITOR_BASE		0x00000000
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(1 * 1024 * 1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	(256)
+#define CONFIG_SYS_BOOTMAPSZ		(8 * 1024 * 1024)
+
+#if defined(CONFIG_EXTRAM_BOOT)
+#define CONFIG_SYS_TEXT_BASE	0x70000000
+#else
+#define CONFIG_SYS_TEXT_BASE	0xE6304000
+#endif
+
+/* FLASH */
+#define CONFIG_SPI
+#define CONFIG_SH_QSPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_QUAD
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SH_QSPI_BASE	0xE6B10000
+
+/* ENV setting */
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SECT_SIZE	(8 * 1024)
+#define CONFIG_ENV_ADDR		0xC0000
+#define CONFIG_ENV_OFFSET	(CONFIG_ENV_ADDR)
+#define CONFIG_ENV_SIZE		(CONFIG_ENV_SECT_SIZE)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"bootm_low=0x40e00000\0" \
+	"bootfile=uImage\0" \
+	"bootm_size=0x100000\0" \
+	"loadaddr=0x40007fc0\0" \
+	"fdt_addr=0x40f00000\0" \
+	"ethaddr=00:01:02:03:04:05\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"kernel=uImage\0" \
+                "bootargs_base=console=ttySC1,115200n8 ignore_loglevel vmalloc=384M\0" \
+                "bootargs_mmc=setenv bootargs ${bootargs_base} " \
+                        "root=/dev/mmcblk1p2 rootwait rootfstype=ext3 rw\0" \
+                "bootcmd_mmc=run bootargs_mmc;mmc dev 1;" \
+                        "fatload mmc 1 ${loadaddr} ${kernel};fatload mmc 1 ${fdt_addr} ${fdt_file};bootm ${loadaddr} - ${fdt_addr}\0" \
+       		"bootargs_msd=setenv bootargs ${bootargs_base} " \
+                        "root=/dev/mmcblk0p2 rootwait rootfstype=ext3 rw\0" \
+                "bootcmd_msd=run bootargs_msd;mmc dev 0;" \
+                        "fatload mmc 0 ${loadaddr} ${kernel};fatload mmc 0 ${fdt_addr} ${fdt_file};bootm ${loadaddr} - ${fdt_addr}\0" \
+                "bootcmd=run bootcmd_mmc\0" \
+
+/* network */
+#define CONFIG_IWG23S_ETHERB
+#define CONFIG_NFS_TIMEOUT 10000UL
+
+/* Ethernet AVB */
+#if defined(CONFIG_IWG23S_ETHERB)
+#define CONFIG_RAVB
+#define CONFIG_RAVB_PHY_ADDR	0x0
+#define CONFIG_RAVB_PHY_MODE PHY_INTERFACE_MODE_GMII
+#endif
+
+/* Renesas Ethernet controler Common */
+#if defined(CONFIG_RAVB)
+#define CONFIG_NET_MULTI
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_BITBANGMII
+#define CONFIG_BITBANGMII_MULTI
+#define CONFIG_SH_ETHER_BITBANG
+#endif
+
+/* Board Clock */
+#define	CONFIG_SYS_CLK_FREQ	65000000
+#define       CONFIG_SCIF_CLK_FREQ    65000000
+
+#define CONFIG_SYS_TMU_CLK_DIV	4
+#define CONFIG_SYS_HZ		1000
+
+/* I2C */
+#define CONFIG_SH_I2C		1
+#define CONFIG_SYS_I2C_MODULE	1
+#define CONFIG_SYS_I2C_SPEED	400000 /* 400 kHz */
+#define CONFIG_SYS_I2C_SLAVE	0x7F
+#define CONFIG_SH_I2C_DATA_HIGH	4
+#define CONFIG_SH_I2C_DATA_LOW	5
+#define CONFIG_SH_I2C_CLOCK	10000000
+#define CONFIG_SH_I2C_BASE0	0xE6518000
+
+/* FS */
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_VFAT
+
+/* USB */
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_R8A779x
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+
+/* SD */
+#define CONFIG_MMC			1
+#define CONFIG_GENERIC_MMC		1
+#define CONFIG_SH_SDHI			1
+#define CONFIG_SH_SDHI_FREQ		78000000
+#define CONFIG_MMC_SH_SDHI_NR_CHANNEL	3
+
+/* eMMC */
+#define CONFIG_SH_SDHI_MMC
+
+/* USB-ether */
+#define CONFIG_MII
+#define CONFIG_USB_HOST_ETHER   /* Enable USB Ethernet adapters */
+#define CONFIG_USB_ETHER_ASIX   /* Asix, or whatever driver(s) you want */
+
+#endif	/* __IWG23S_H */
-- 
1.7.9.5


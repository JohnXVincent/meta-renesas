From 16e652160828c16d8579b20ea4deb5965aec9f7c Mon Sep 17 00:00:00 2001
From: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>
Date: Fri, 23 Jun 2017 00:24:13 +0700
Subject: [PATCH 05/12] watchdog: renesas-wdt: add restart handler

different SoC may have different implementation for restart handler
this commit add a restart handler for RZ/G1M but it also can be used
for other SoCs in Gen2 series which have a Cortex-A15 core

Signed-off-by: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>

%% original patch: 0026-watchdog-renesas-wdt-add-restart-handler.patch
---
 drivers/watchdog/renesas_wdt.c | 44 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/drivers/watchdog/renesas_wdt.c b/drivers/watchdog/renesas_wdt.c
index cf61c92..59cbdad 100644
--- a/drivers/watchdog/renesas_wdt.c
+++ b/drivers/watchdog/renesas_wdt.c
@@ -17,6 +17,10 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/watchdog.h>
+#include <linux/reboot.h>
+
+#define WDTRSTCR        0xE6160054	/*Watchdog Timer Reset Control Register*/
+#define CA15BAR         0xE6160020	/*Cortex A15 Boot Address Register*/
 
 #define RWTCNT		0
 #define RWTCSRA		4
@@ -37,6 +41,7 @@ struct rwdt_priv {
 	void __iomem *base;
 	struct watchdog_device wdev;
 	struct clk *clk;
+	struct notifier_block restart_handler;
 	unsigned int clks_per_sec;
 	u8 cks;
 };
@@ -100,6 +105,30 @@ static const struct watchdog_info rwdt_ident = {
 	.identity = "Renesas WDT Watchdog",
 };
 
+static int rwdt_restart_handler_ca15(struct notifier_block *nb, unsigned long mode, void *cmd)
+{
+	struct rwdt_priv *priv = container_of(nb, struct rwdt_priv, restart_handler);
+	void __iomem *wdtrstcr = ioremap_nocache(WDTRSTCR, 4);
+	void __iomem *ca15bar  = ioremap_nocache(CA15BAR, 4);
+
+	BUG_ON(!ca15bar);
+	BUG_ON(!wdtrstcr);
+
+	// /* Enabling RWDT Reset request */
+	iowrite32(0xA55A0002, wdtrstcr);
+	/* setting ROM Address as SYS Boot Address */
+	iowrite32(0x00000002, ca15bar);
+	iowrite32(0x00000012, ca15bar);
+
+	rwdt_start(&priv->wdev);
+	rwdt_write(priv, 0xffff, RWTCNT);
+
+	iounmap(wdtrstcr);
+	iounmap(ca15bar);
+
+	return NOTIFY_DONE;
+}
+
 static const struct watchdog_ops rwdt_ops = {
 	.owner = THIS_MODULE,
 	.start = rwdt_start,
@@ -173,6 +202,20 @@ static int rwdt_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/*
+	 * register restart handler base on machine here
+	 * same ARM core architecture (e.g ARM cortex A15) can use same handler 
+	 */
+	if (of_machine_is_compatible("renesas,r8a7743")) {
+		priv->restart_handler.notifier_call = rwdt_restart_handler_ca15;
+		/* 255: Highest priority restart handler */
+		priv->restart_handler.priority = 255;
+		ret = register_restart_handler(&priv->restart_handler);
+		if (ret)
+			dev_err(&pdev->dev,
+				"Failed to register restart handler (err = %d)\n", ret);
+	}
+
 	return 0;
 }
 
@@ -194,6 +237,7 @@ static int rwdt_remove(struct platform_device *pdev)
  */
 static const struct of_device_id rwdt_ids[] = {
 	{ .compatible = "renesas,rcar-gen3-wdt", },
+	{ .compatible = "renesas,rcar-gen2-wdt", },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, rwdt_ids);
-- 
1.9.1


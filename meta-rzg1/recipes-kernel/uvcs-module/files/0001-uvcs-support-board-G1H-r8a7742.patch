From fbabb8267c9830a7e36db22d486077ff3ab75c07 Mon Sep 17 00:00:00 2001
From: thongsyho <thong.ho.px@rvc.renesas.com>
Date: Tue, 10 Apr 2018 13:42:22 +0700
Subject: [PATCH] uvcs: support board G1H r8a7742

Signed-off-by: thongsyho <thong.ho.px@rvc.renesas.com>
---
 source/uvcs_lkm/uvcs_lkm.c          | 100 ++++++++++++++++++++++++-
 source/uvcs_lkm/uvcs_lkm_internal.h |  34 ++++++++-
 source/uvcs_lkm/uvcs_lkm_uf_io.c    | 142 +++++++++++++++++++++++++++++++++---
 3 files changed, 259 insertions(+), 17 deletions(-)

diff --git a/source/uvcs_lkm/uvcs_lkm.c b/source/uvcs_lkm/uvcs_lkm.c
index 6c9af75..6fa5ada 100644
--- a/source/uvcs_lkm/uvcs_lkm.c
+++ b/source/uvcs_lkm/uvcs_lkm.c
@@ -618,6 +618,29 @@ static int uvcs_probe(struct platform_device *pdev)
 				goto err_exit;
 			drv_info->vcp_devnum++;
 		}
+
+		if (0 == strcmp("vcp1",of_data->name)) {
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+			/* vcp */
+			if ((ch >= UVCS_VCP_DEVNUM)
+			||	(drv_info->vcpinf[ch].reg_vlc != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id = drv_info->devnum;
+			pdata->device_vcp = true;
+			pdata->hwinf = &drv_info->vcpinf[ch];
+			result = uvcs_get_vcp_resource(pdev,
+					&drv_info->vcpinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vcp_devnum++;
+		}
+
 		if (0 == strcmp("vpc0",of_data->name)) {
 			/* vpc */
 			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
@@ -625,7 +648,30 @@ static int uvcs_probe(struct platform_device *pdev)
 			goto err_exit;
 			}
 
-			if ((ch >= UVCS_VCP_DEVNUM)
+			if ((ch >= UVCS_VPC_DEVNUM)
+			||	(drv_info->vpcinf[ch].reg_vpc != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id_vpc = drv_info->devnum;
+			pdata->device_vpc = true;
+			pdata->hwinf_vpc = &drv_info->vpcinf[ch];
+			result = uvcs_get_vpc_resource(pdev,
+					&drv_info->vpcinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vpc_devnum++;
+		}
+
+		if (0 == strcmp("vpc1",of_data->name)) {
+			/* vpc */
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+
+			if ((ch >= UVCS_VPC_DEVNUM)
 			||	(drv_info->vpcinf[ch].reg_vpc != NULL)) {
 				result = -EINVAL;
 				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
@@ -640,6 +686,52 @@ static int uvcs_probe(struct platform_device *pdev)
 				goto err_exit;
 			drv_info->vpc_devnum++;
 		}
+
+		if (0 == strcmp("vpc0xy",of_data->name)) {
+			/* vpcxy */
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+
+			if ((ch >= UVCS_VPCXY_DEVNUM)
+			||	(drv_info->vpcxyinf[ch].reg_vpcxy != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id_vpcxy = drv_info->devnum;
+			pdata->device_vpcxy = true;
+			pdata->hwinf_vpcxy = &drv_info->vpcxyinf[ch];
+			result = uvcs_get_vpcxy_resource(pdev,
+					&drv_info->vpcxyinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vpcxy_devnum++;
+		}
+
+		if (0 == strcmp("vpc1xy",of_data->name)) {
+			/* vpcxy */
+			if (of_property_read_u32(pdev->dev.of_node, "renesas,#ch", &ch) < 0) {
+			dev_err(&pdev->dev, "of_property_read_u32() failed #%d\n", __LINE__);
+			goto err_exit;
+			}
+
+			if ((ch >= UVCS_VPCXY_DEVNUM)
+			||	(drv_info->vpcxyinf[ch].reg_vpcxy != NULL)) {
+				result = -EINVAL;
+				dev_err(&pdev->dev, "property error #%d\n", __LINE__);
+				goto err_exit;
+			}
+			pdata->device_id_vpcxy = drv_info->devnum;
+			pdata->device_vpcxy = true;
+			pdata->hwinf_vpcxy = &drv_info->vpcxyinf[ch];
+			result = uvcs_get_vpcxy_resource(pdev,
+					&drv_info->vpcxyinf[ch], of_data->iparch, of_data->name);
+			if (result)
+				goto err_exit;
+			drv_info->vpcxy_devnum++;
+		}
 	}
 
 	pm_suspend_ignore_children(&pdev->dev, true);
@@ -666,6 +758,12 @@ static int uvcs_remove(struct platform_device *pdev)
 	if (pdata->device_vcp)
 		uvcs_put_vcp_resource((struct uvcs_vcp_hwinf *)pdata->hwinf);
 
+	if (pdata->device_vpc)
+		uvcs_put_vpc_resource((struct uvcs_vpc_hwinf *)pdata->hwinf_vpc);
+
+	if (pdata->device_vpcxy)
+		uvcs_put_vpcxy_resource((struct uvcs_vpcxy_hwinf *)pdata->hwinf_vpcxy);
+
 	pm_runtime_disable(&pdev->dev);
 	drv_info->pdev = NULL;
 	platform_set_drvdata(pdev, NULL);
diff --git a/source/uvcs_lkm/uvcs_lkm_internal.h b/source/uvcs_lkm/uvcs_lkm_internal.h
index b9141fb..5d6b28e 100644
--- a/source/uvcs_lkm/uvcs_lkm_internal.h
+++ b/source/uvcs_lkm/uvcs_lkm_internal.h
@@ -141,6 +141,7 @@
 
 #define UVCS_VCP_DEVNUM         (3u)
 #define UVCS_VPC_DEVNUM         (3u)
+#define UVCS_VPCXY_DEVNUM       (3u)
 #define UVCS_MAX_DEVNUM         (6u)
 
 /******************************************************************************/
@@ -170,6 +171,12 @@ struct uvcs_vpc_hwinf {
 	struct platform_device	*pdev;
 };
 
+struct uvcs_vpcxy_hwinf {
+	u32						 pa_vpcxy;
+	void					*reg_vpcxy;
+	struct platform_device	*pdev;
+};
+
 struct uvcs_thr_ctrl {
 	struct task_struct	*thread;
 	wait_queue_head_t	 evt_wait_q;
@@ -201,12 +208,15 @@ struct uvcs_mdl_param {
 };
 
 struct uvcs_platform_data {
-	u32					 device_id;
-	bool				 device_vcp;
-	u32					 device_id_vpc;
-	bool				 device_vpc;
+	u32					device_id;
+	bool				device_vcp;
+	u32					device_id_vpc;
+	bool				device_vpc;
+	u32					device_id_vpcxy;
+	bool				device_vpcxy;
 	void				*hwinf;
 	void				*hwinf_vpc;
+	void				*hwinf_vpcxy;
 };
 
 struct uvcs_drv_info {
@@ -229,8 +239,10 @@ struct uvcs_drv_info {
 	u32                     devnum;
 	u32                     vcp_devnum;
 	u32                     vpc_devnum;
+	u32                     vpcxy_devnum;
 	struct uvcs_vcp_hwinf   vcpinf[UVCS_VCP_DEVNUM];
 	struct uvcs_vpc_hwinf   vpcinf[UVCS_VPC_DEVNUM];
+	struct uvcs_vpcxy_hwinf   vpcxyinf[UVCS_VPCXY_DEVNUM];
 };
 
 /******************************************************************************/
@@ -262,8 +274,22 @@ int uvcs_get_vpc_resource(
 				u32 iparch,
 				const char *name
 				);
+int uvcs_get_vpcxy_resource(
+				struct platform_device *pdev,
+				struct uvcs_vpcxy_hwinf *vpcxyinf,
+				u32 iparch,
+				const char *name
+				);
 void uvcs_put_vcp_resource(
 				struct uvcs_vcp_hwinf *vcpinf
 				);
 
+void uvcs_put_vpc_resource(
+			struct uvcs_vpc_hwinf *vpcinf
+			);
+
+void uvcs_put_vpcxy_resource(
+			struct uvcs_vpcxy_hwinf *vpcxyinf
+			);
+
 #endif /* UVCS_LKM_INTERNAL_H */
diff --git a/source/uvcs_lkm/uvcs_lkm_uf_io.c b/source/uvcs_lkm/uvcs_lkm_uf_io.c
index bc54648..ef75e62 100644
--- a/source/uvcs_lkm/uvcs_lkm_uf_io.c
+++ b/source/uvcs_lkm/uvcs_lkm_uf_io.c
@@ -893,6 +893,17 @@ int uvcs_get_vcp_resource(
 	}
 	vcpinf->irq_ce = (int)res->start;
 
+	if (0 == strcmp("vcp0",name)) {
+		clk_vcp[0] = clk_get(NULL, "vcp0");
+		clk_enable(clk_vcp[0]);
+	} else if (0 == strcmp("vcp1",name)) {
+		clk_vcp[1] = clk_get(NULL, "vcp1");
+		clk_enable(clk_vcp[1]);
+	} else {
+		dev_err(&pdev->dev, "These clock properties of vcp do not match RZG chip\n");
+		goto err_exit_1;
+	}
+
 	vcpinf->reg_vlc = ioremap_nocache(vcpinf->pa_vlc,
 									UVCS_REG_SIZE_VLC);
 
@@ -903,16 +914,29 @@ int uvcs_get_vcp_resource(
 
 	vcpinf->reg_ce = ioremap_nocache(vcpinf->pa_ce,
 									UVCS_REG_SIZE_VPC);
-	reg_vlc[0]= vcpinf->reg_vlc;
-	reg_ce[0] = vcpinf->reg_ce;
-	reg_vlc[1] = 0;
-	reg_ce[1] = 0;
-
 	if (vcpinf->reg_ce == NULL) {
 		dev_err(&pdev->dev, "failed to remap (reg_1, %u)\n", iparch);
 		goto err_exit_2;
 	}
 
+	if (0 == strcmp("vcp0",name)) {
+		reg_vlc[0]= vcpinf->reg_vlc;
+		reg_ce[0] = vcpinf->reg_ce;
+	} else if (0 == strcmp("vcp1",name)) {
+		reg_vlc[1]= vcpinf->reg_vlc;
+		reg_ce[1] = vcpinf->reg_ce;
+	}
+	else {
+		reg_vlc[0]= 0;
+		reg_ce[0] = 0;
+		reg_vlc[1]= 0;
+		reg_ce[1] = 0;
+		dev_err(&pdev->dev, "These properties of vcp do not match RZG chip\n");
+		goto err_exit_3;
+	}
+
+
+
 	strcpy(vcpinf->irq_name_vlc, dev_name(&pdev->dev));
 	strcat(vcpinf->irq_name_vlc, " ");
 	strcat(vcpinf->irq_name_vlc, name);
@@ -926,6 +950,10 @@ int uvcs_get_vcp_resource(
 
 	return 0;
 
+err_exit_3:
+	iounmap(vcpinf->reg_ce);
+	vcpinf->reg_ce = NULL;
+
 err_exit_2:
 	iounmap(vcpinf->reg_vlc);
 	vcpinf->reg_vlc = NULL;
@@ -960,8 +988,16 @@ int uvcs_get_vpc_resource(
 	}
 	vpcinf->pa_vpc = (u32)res->start;
 
-	clk_vpc[0] = clk_get(NULL, "vpc0");
-	clk_enable(clk_vpc[0]);
+	if (0 == strcmp("vpc0",name)) {
+		clk_vpc[0] = clk_get(NULL, "vpc0");
+		clk_enable(clk_vpc[0]);
+	} else if (0 == strcmp("vpc1",name)) {
+		clk_vpc[1] = clk_get(NULL, "vpc1");
+		clk_enable(clk_vpc[1]);
+	} else {
+		dev_err(&pdev->dev, "These clock properties of vpc do not match RZG chip\n");
+		goto err_exit_1;
+	}
 
 
 	vpcinf->reg_vpc = ioremap_nocache(vpcinf->pa_vpc,
@@ -972,8 +1008,16 @@ int uvcs_get_vpc_resource(
 		goto err_exit_2;
 	}
 
-	reg_vpc[0] = vpcinf->reg_vpc;
-	reg_vpc[1] = 0;
+	if (0 == strcmp("vpc0",name)) {
+		reg_vpc[0] = vpcinf->reg_vpc;
+	} else if (0 == strcmp("vpc1",name)) {
+		reg_vpc[1] = vpcinf->reg_vpc;
+	} else {
+		reg_vpc[0] = 0;
+		reg_vpc[1] = 0;
+		dev_err(&pdev->dev, "These register properties of vpc do not match RZG chip\n");
+		goto err_exit_2;
+	}
 
 	return 0;
 
@@ -986,6 +1030,61 @@ err_exit_0:
 	return result;
 }
 
+int uvcs_get_vpcxy_resource(
+				struct platform_device *pdev,
+				struct uvcs_vpcxy_hwinf *vpcxyinf,
+				u32 iparch,
+				const char *name
+				)
+{
+	int result = -EFAULT;
+	struct resource *res;
+	int ch;
+
+
+	if ((pdev == NULL) || (vpcxyinf == NULL))
+		goto err_exit_0;
+
+	vpcxyinf->reg_vpcxy = NULL;
+	result = -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "resource not found (reg_0, %u)\n", iparch);
+		goto err_exit_1;
+	}
+	vpcxyinf->pa_vpcxy = (u32)res->start;
+
+	vpcxyinf->reg_vpcxy = ioremap_nocache(vpcxyinf->pa_vpcxy,
+									UVCS_REG_SIZE_SINGLE);
+
+	if (vpcxyinf->reg_vpcxy == NULL) {
+		dev_err(&pdev->dev, "failed to remap (reg_0, %u)\n", iparch);
+		goto err_exit_2;
+	}
+
+	if (0 == strcmp("vpc0xy",name)) {
+		reg_vpcxy[0] = vpcxyinf->reg_vpcxy;
+	} else if (0 == strcmp("vpc1xy",name)) {
+		reg_vpcxy[1] = vpcxyinf->reg_vpcxy;
+	} else {
+		reg_vpcxy[0] = 0;
+		reg_vpcxy[1] = 0;
+		dev_err(&pdev->dev, "These register properties of vpcxy do not match RZG chip\n");
+		goto err_exit_2;
+	}
+
+	return 0;
+
+err_exit_2:
+	iounmap(vpcxyinf->reg_vpcxy);
+	vpcxyinf->reg_vpcxy = NULL;
+
+err_exit_1:
+err_exit_0:
+	return result;
+}
+
 void uvcs_put_vcp_resource(
 			struct uvcs_vcp_hwinf *vcpinf
 			)
@@ -998,10 +1097,29 @@ void uvcs_put_vcp_resource(
 		}
 		iounmap(vcpinf->reg_vlc);
 		vcpinf->reg_vlc = NULL;
-		if (reg_vpc[0])
-			iounmap((void *)reg_vpc[0]);
-		reg_vpc[0] = 0;
 	}
 
 
 }
+
+void uvcs_put_vpc_resource(
+			struct uvcs_vpc_hwinf *vpcinf
+			)
+{
+	if ((vpcinf)
+	&&	(vpcinf->reg_vpc)) {
+			iounmap(vpcinf->reg_vpc);
+			vpcinf->reg_vpc = NULL;
+	}
+}
+
+void uvcs_put_vpcxy_resource(
+			struct uvcs_vpcxy_hwinf *vpcxyinf
+			)
+{
+	if ((vpcxyinf)
+	&&	(vpcxyinf->reg_vpcxy)) {
+			iounmap(vpcxyinf->reg_vpcxy);
+			vpcxyinf->reg_vpcxy = NULL;
+	}
+}
-- 
1.9.1


From cd95d88c64d66154ccf28597bfc333a165ab5c47 Mon Sep 17 00:00:00 2001
From: Khai Nguyen <khai.nguyen.wx@renesas.com>
Date: Fri, 15 Apr 2022 10:29:30 +0700
Subject: [PATCH] add switching voltage sd

Signed-off-by: Khai Nguyen <khai.nguyen.wx@renesas.com>
---
 .../renesas/r9a09g011gbg-evaluation-board.dts |   1 +
 drivers/mmc/host/renesas_sdhi.h               |   2 +
 drivers/mmc/host/renesas_sdhi_core.c          | 143 ++++++++++++++----
 3 files changed, 116 insertions(+), 30 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index adb402a03c7d..6841e239f6eb 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -171,6 +171,7 @@ &uart0 {
 };
 
 &sdhi0 {
+    psc-pins = <0>;
     status = "okay";
 };
 
diff --git a/drivers/mmc/host/renesas_sdhi.h b/drivers/mmc/host/renesas_sdhi.h
index cb962c7883dc..554270f37eeb 100644
--- a/drivers/mmc/host/renesas_sdhi.h
+++ b/drivers/mmc/host/renesas_sdhi.h
@@ -60,6 +60,8 @@ struct renesas_sdhi {
 	struct pinctrl_state *pins_default, *pins_uhs;
 	void __iomem *scc_ctl;
 	u32 scc_tappos;
+	u32 psc_pins;
+	u8  switching_volt_type;
 	u32 scc_tappos_hs400;
 	const u8 *adjust_hs400_calib_table;
 	bool needs_adjust_hs400;
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index 2a48e9aaff2c..7ab249c7bbcd 100644
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -50,6 +50,42 @@
 
 #define SDHI_GEN3_MMC0_ADDR	0xee140000
 
+#define B2REG_PSC_BASE_ADDR     (0x00000000A3700000ULL)
+#define B2REG_PSC_SDSEL_OFSET   (0x0080)
+
+#define MAX_CHIP_NAME_SIZE     	       (20)
+#define PSC_REG_SD_3_3V                (0)
+#define PSC_REG_SD_1_8V         (1)
+
+enum switching_voltage_mode{
+       psc_mode,
+       pfc_mode,
+};
+
+static const struct soc_device_attribute soc_whitelist[] = {
+       { .soc_id = "r8arzv2m" },
+       { /* sentinel */ }
+};
+
+static int psc_voltage_switch(uint32_t pins, uint8_t voltage)
+{
+
+       uint32_t data;
+       void __iomem * remap_addr;
+
+       remap_addr = ioremap(B2REG_PSC_BASE_ADDR,sizeof(*remap_addr));
+       if (!remap_addr) {
+	       return -EINVAL;
+    	}
+
+       data = (voltage << pins) | BIT((pins+16));
+       writel(data , remap_addr + B2REG_PSC_SDSEL_OFSET);
+       iounmap(remap_addr);
+
+       return 0;
+}
+
+
 static void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)
 {
 	u32 val;
@@ -219,30 +255,49 @@ static int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 	struct pinctrl_state *pin_state;
 	int ret;
 
-	switch (ios->signal_voltage) {
-	case MMC_SIGNAL_VOLTAGE_330:
-		pin_state = priv->pins_default;
-		break;
-	case MMC_SIGNAL_VOLTAGE_180:
-		pin_state = priv->pins_uhs;
-		break;
-	default:
-		return -EINVAL;
-	}
+       u8 psc_state;
+
+          if(priv->switching_volt_type == pfc_mode){
+               switch (ios->signal_voltage) {
+               case MMC_SIGNAL_VOLTAGE_330:
+                       pin_state = priv->pins_default;
+                       break;
+               case MMC_SIGNAL_VOLTAGE_180:
+                       pin_state = priv->pins_uhs;
+                       break;
+               default:
+                       return -EINVAL;
+               }
+
+               /*
+                * If anything is missing, assume signal voltage is fixed at
+                * 3.3V and succeed/fail accordingly.
+                */
+               if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
+                       return ios->signal_voltage ==
+                               MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
+
+               ret = mmc_regulator_set_vqmmc(host->mmc, ios);
+               if (ret)
+                       return ret;
+
+               return pinctrl_select_state(priv->pinctrl, pin_state);
+       	 } 
+         else if(priv->switching_volt_type == psc_mode){
+               switch (ios->signal_voltage) {
+               case MMC_SIGNAL_VOLTAGE_330:
+                               psc_state = PSC_REG_SD_3_3V;
+                       break;
+               case MMC_SIGNAL_VOLTAGE_180:
+                               psc_state = PSC_REG_SD_1_8V;
+                       break;
+               default:
+                       return -EINVAL;
+               }
+               return psc_voltage_switch(priv->psc_pins, psc_state);
+         } 
 
-	/*
-	 * If anything is missing, assume signal voltage is fixed at
-	 * 3.3V and succeed/fail accordingly.
-	 */
-	if (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))
-		return ios->signal_voltage ==
-			MMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;
-
-	ret = mmc_regulator_set_vqmmc(host->mmc, ios);
-	if (ret < 0)
-		return ret;
-
-	return pinctrl_select_state(priv->pinctrl, pin_state);
+	return 0;
 }
 
 /* SCC registers */
@@ -924,6 +979,7 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	int num_irqs, irq, ret, i;
 	struct resource *res;
 	u16 ver;
+	u32 psc_pins = 0;
 
 	of_data = of_device_get_match_data(&pdev->dev);
 
@@ -966,13 +1022,40 @@ int renesas_sdhi_probe(struct platform_device *pdev,
 	if (IS_ERR(priv->clk_cd))
 		priv->clk_cd = NULL;
 
-	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
-	if (!IS_ERR(priv->pinctrl)) {
-		priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
-						PINCTRL_STATE_DEFAULT);
-		priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
-						"state_uhs");
-	}
+       /* Voltage switching type depends on the soc_id.
+        * If the soc_device_match finds a soc_id, it run power slaveport control mode.
+        * If you use pin function control unit, do not write a soc_id to whitelist.
+        */
+
+       const struct soc_device_attribute *soc = soc_device_match(soc_whitelist);
+
+       if (soc){
+               priv->switching_volt_type = psc_mode;
+
+               if(of_property_read_u32(pdev->dev.of_node, "psc-pins", &psc_pins))
+                       priv->switching_volt_type = pfc_mode;
+
+               else
+               {
+                       priv->psc_pins = psc_pins;
+
+                       if(   32 <= priv->psc_pins ){
+                               return -EINVAL;
+                       }
+               }
+       }
+       else
+               priv->switching_volt_type = pfc_mode;
+
+       if(priv->switching_volt_type == pfc_mode){
+               priv->pinctrl = devm_pinctrl_get(&pdev->dev);
+               if (!IS_ERR(priv->pinctrl)) {
+                       priv->pins_default = pinctrl_lookup_state(priv->pinctrl,
+                                                       PINCTRL_STATE_DEFAULT);
+                       priv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,
+                                                       "state_uhs");
+               }
+       }
 
 	host = tmio_mmc_host_alloc(pdev, mmc_data);
 	if (IS_ERR(host))
-- 
2.25.1

